var cg = Object.defineProperty;
var hg = (x, f, y) => f in x ? cg(x, f, { enumerable: !0, configurable: !0, writable: !0, value: y }) : x[f] = y;
var Eu = (x, f, y) => hg(x, typeof f != "symbol" ? f + "" : f, y);
import ug, { Map as dg } from "mapbox-gl";
var pg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Kp = { exports: {} };
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v4.7.1/LICENSE.txt
 */
(function(x, f) {
  (function(y, b) {
    x.exports = b();
  })(pg, function() {
    var y = {}, b = {};
    function k(v, c, z) {
      if (b[v] = z, v === "index") {
        var U = "var sharedModule = {}; (" + b.shared + ")(sharedModule); (" + b.worker + ")(sharedModule);", X = {};
        return b.shared(X), b.index(y, X), typeof window < "u" && y.setWorkerUrl(window.URL.createObjectURL(new Blob([U], { type: "text/javascript" }))), y;
      }
    }
    k("shared", ["exports"], function(v) {
      function c(i, e, n, a) {
        return new (n || (n = Promise))(function(u, d) {
          function m(C) {
            try {
              I(a.next(C));
            } catch (N) {
              d(N);
            }
          }
          function S(C) {
            try {
              I(a.throw(C));
            } catch (N) {
              d(N);
            }
          }
          function I(C) {
            var N;
            C.done ? u(C.value) : (N = C.value, N instanceof n ? N : new n(function(D) {
              D(N);
            })).then(m, S);
          }
          I((a = a.apply(i, e || [])).next());
        });
      }
      function z(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var U = X;
      function X(i, e) {
        this.x = i, this.y = e;
      }
      X.prototype = { clone: function() {
        return new X(this.x, this.y);
      }, add: function(i) {
        return this.clone()._add(i);
      }, sub: function(i) {
        return this.clone()._sub(i);
      }, multByPoint: function(i) {
        return this.clone()._multByPoint(i);
      }, divByPoint: function(i) {
        return this.clone()._divByPoint(i);
      }, mult: function(i) {
        return this.clone()._mult(i);
      }, div: function(i) {
        return this.clone()._div(i);
      }, rotate: function(i) {
        return this.clone()._rotate(i);
      }, rotateAround: function(i, e) {
        return this.clone()._rotateAround(i, e);
      }, matMult: function(i) {
        return this.clone()._matMult(i);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(i) {
        return this.x === i.x && this.y === i.y;
      }, dist: function(i) {
        return Math.sqrt(this.distSqr(i));
      }, distSqr: function(i) {
        var e = i.x - this.x, n = i.y - this.y;
        return e * e + n * n;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(i) {
        return Math.atan2(this.y - i.y, this.x - i.x);
      }, angleWith: function(i) {
        return this.angleWithSep(i.x, i.y);
      }, angleWithSep: function(i, e) {
        return Math.atan2(this.x * e - this.y * i, this.x * i + this.y * e);
      }, _matMult: function(i) {
        var e = i[2] * this.x + i[3] * this.y;
        return this.x = i[0] * this.x + i[1] * this.y, this.y = e, this;
      }, _add: function(i) {
        return this.x += i.x, this.y += i.y, this;
      }, _sub: function(i) {
        return this.x -= i.x, this.y -= i.y, this;
      }, _mult: function(i) {
        return this.x *= i, this.y *= i, this;
      }, _div: function(i) {
        return this.x /= i, this.y /= i, this;
      }, _multByPoint: function(i) {
        return this.x *= i.x, this.y *= i.y, this;
      }, _divByPoint: function(i) {
        return this.x /= i.x, this.y /= i.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var i = this.y;
        return this.y = this.x, this.x = -i, this;
      }, _rotate: function(i) {
        var e = Math.cos(i), n = Math.sin(i), a = n * this.x + e * this.y;
        return this.x = e * this.x - n * this.y, this.y = a, this;
      }, _rotateAround: function(i, e) {
        var n = Math.cos(i), a = Math.sin(i), u = e.y + a * (this.x - e.x) + n * (this.y - e.y);
        return this.x = e.x + n * (this.x - e.x) - a * (this.y - e.y), this.y = u, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, X.convert = function(i) {
        return i instanceof X ? i : Array.isArray(i) ? new X(i[0], i[1]) : i;
      };
      var O = z(U), j = F;
      function F(i, e, n, a) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (a - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = e, this.p2x = n, this.p2y = a;
      }
      F.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, e) {
        if (e === void 0 && (e = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, a = 0; a < 8; a++) {
          var u = this.sampleCurveX(n) - i;
          if (Math.abs(u) < e) return n;
          var d = this.sampleCurveDerivativeX(n);
          if (Math.abs(d) < 1e-6) break;
          n -= u / d;
        }
        var m = 0, S = 1;
        for (n = i, a = 0; a < 20 && (u = this.sampleCurveX(n), !(Math.abs(u - i) < e)); a++) i > u ? m = n : S = n, n = 0.5 * (S - m) + m;
        return n;
      }, solve: function(i, e) {
        return this.sampleCurveY(this.solveCurveX(i, e));
      } };
      var mt = z(j);
      let ot, yt;
      function st() {
        return ot == null && (ot = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), ot;
      }
      function gt() {
        if (yt == null && (yt = !1, st())) {
          const e = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (e) {
            for (let a = 0; a < 5 * 5; a++) {
              const u = 4 * a;
              e.fillStyle = `rgb(${u},${u + 1},${u + 2})`, e.fillRect(a % 5, Math.floor(a / 5), 1, 1);
            }
            const n = e.getImageData(0, 0, 5, 5).data;
            for (let a = 0; a < 5 * 5 * 4; a++) if (a % 4 != 3 && n[a] !== a) {
              yt = !0;
              break;
            }
          }
        }
        return yt || !1;
      }
      function zt(i, e, n, a) {
        const u = new mt(i, e, n, a);
        return (d) => u.solve(d);
      }
      const Jt = zt(0.25, 0.1, 0.25, 1);
      function Kt(i, e, n) {
        return Math.min(n, Math.max(e, i));
      }
      function pe(i, e, n) {
        const a = n - e, u = ((i - e) % a + a) % a + e;
        return u === e ? n : u;
      }
      function Ot(i, ...e) {
        for (const n of e) for (const a in n) i[a] = n[a];
        return i;
      }
      let kt = 1;
      function $t(i, e, n) {
        const a = {};
        for (const u in i) a[u] = e.call(this, i[u], u, i);
        return a;
      }
      function ae(i, e, n) {
        const a = {};
        for (const u in i) e.call(this, i[u], u, i) && (a[u] = i[u]);
        return a;
      }
      function at(i) {
        return Array.isArray(i) ? i.map(at) : typeof i == "object" && i ? $t(i, at) : i;
      }
      const lt = {};
      function It(i) {
        lt[i] || (typeof console < "u" && console.warn(i), lt[i] = !0);
      }
      function St(i, e, n) {
        return (n.y - i.y) * (e.x - i.x) > (e.y - i.y) * (n.x - i.x);
      }
      function Wt(i) {
        return typeof WorkerGlobalScope < "u" && i !== void 0 && i instanceof WorkerGlobalScope;
      }
      let Xt = null;
      function Ht(i) {
        return typeof ImageBitmap < "u" && i instanceof ImageBitmap;
      }
      const jt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function ee(i, e, n, a, u) {
        return c(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
          const d = new VideoFrame(i, { timestamp: 0 });
          try {
            const m = d == null ? void 0 : d.format;
            if (!m || !m.startsWith("BGR") && !m.startsWith("RGB")) throw new Error(`Unrecognized format ${m}`);
            const S = m.startsWith("BGR"), I = new Uint8ClampedArray(a * u * 4);
            if (yield d.copyTo(I, function(C, N, D, G, W) {
              const J = 4 * Math.max(-N, 0), rt = (Math.max(0, D) - D) * G * 4 + J, dt = 4 * G, vt = Math.max(0, N), Dt = Math.max(0, D);
              return { rect: { x: vt, y: Dt, width: Math.min(C.width, N + G) - vt, height: Math.min(C.height, D + W) - Dt }, layout: [{ offset: rt, stride: dt }] };
            }(i, e, n, a, u)), S) for (let C = 0; C < I.length; C += 4) {
              const N = I[C];
              I[C] = I[C + 2], I[C + 2] = N;
            }
            return I;
          } finally {
            d.close();
          }
        });
      }
      let ie, Se;
      const K = "AbortError";
      function pt() {
        return new Error(K);
      }
      const xt = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function Tt(i) {
        return xt.REGISTERED_PROTOCOLS[i.substring(0, i.indexOf("://"))];
      }
      const Et = "global-dispatcher";
      class Rt extends Error {
        constructor(e, n, a, u) {
          super(`AJAXError: ${n} (${e}): ${a}`), this.status = e, this.statusText = n, this.url = a, this.body = u;
        }
      }
      const qt = () => Wt(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Gt = function(i, e) {
        if (/:\/\//.test(i.url) && !/^https?:|^file:/.test(i.url)) {
          const a = Tt(i.url);
          if (a) return a(i, e);
          if (Wt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, targetMapId: Et }, e);
        }
        if (!(/^file:/.test(n = i.url) || /^file:/.test(qt()) && !/^\w+:/.test(n))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(a, u) {
            return c(this, void 0, void 0, function* () {
              const d = new Request(a.url, { method: a.method || "GET", body: a.body, credentials: a.credentials, headers: a.headers, cache: a.cache, referrer: qt(), signal: u.signal });
              a.type !== "json" || d.headers.has("Accept") || d.headers.set("Accept", "application/json");
              const m = yield fetch(d);
              if (!m.ok) {
                const C = yield m.blob();
                throw new Rt(m.status, m.statusText, a.url, C);
              }
              let S;
              S = a.type === "arrayBuffer" || a.type === "image" ? m.arrayBuffer() : a.type === "json" ? m.json() : m.text();
              const I = yield S;
              if (u.signal.aborted) throw pt();
              return { data: I, cacheControl: m.headers.get("Cache-Control"), expires: m.headers.get("Expires") };
            });
          }(i, e);
          if (Wt(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: i, mustQueue: !0, targetMapId: Et }, e);
        }
        var n;
        return function(a, u) {
          return new Promise((d, m) => {
            var S;
            const I = new XMLHttpRequest();
            I.open(a.method || "GET", a.url, !0), a.type !== "arrayBuffer" && a.type !== "image" || (I.responseType = "arraybuffer");
            for (const C in a.headers) I.setRequestHeader(C, a.headers[C]);
            a.type === "json" && (I.responseType = "text", !((S = a.headers) === null || S === void 0) && S.Accept || I.setRequestHeader("Accept", "application/json")), I.withCredentials = a.credentials === "include", I.onerror = () => {
              m(new Error(I.statusText));
            }, I.onload = () => {
              if (!u.signal.aborted) if ((I.status >= 200 && I.status < 300 || I.status === 0) && I.response !== null) {
                let C = I.response;
                if (a.type === "json") try {
                  C = JSON.parse(I.response);
                } catch (N) {
                  return void m(N);
                }
                d({ data: C, cacheControl: I.getResponseHeader("Cache-Control"), expires: I.getResponseHeader("Expires") });
              } else {
                const C = new Blob([I.response], { type: I.getResponseHeader("Content-Type") });
                m(new Rt(I.status, I.statusText, a.url, C));
              }
            }, u.signal.addEventListener("abort", () => {
              I.abort(), m(pt());
            }), I.send(a.body);
          });
        }(i, e);
      };
      function we(i) {
        if (!i || i.indexOf("://") <= 0 || i.indexOf("data:image/") === 0 || i.indexOf("blob:") === 0) return !0;
        const e = new URL(i), n = window.location;
        return e.protocol === n.protocol && e.host === n.host;
      }
      function be(i, e, n) {
        n[i] && n[i].indexOf(e) !== -1 || (n[i] = n[i] || [], n[i].push(e));
      }
      function Ie(i, e, n) {
        if (n && n[i]) {
          const a = n[i].indexOf(e);
          a !== -1 && n[i].splice(a, 1);
        }
      }
      class Pe {
        constructor(e, n = {}) {
          Ot(this, n), this.type = e;
        }
      }
      class ti extends Pe {
        constructor(e, n = {}) {
          super("error", Ot({ error: e }, n));
        }
      }
      class Qt {
        on(e, n) {
          return this._listeners = this._listeners || {}, be(e, n, this._listeners), this;
        }
        off(e, n) {
          return Ie(e, n, this._listeners), Ie(e, n, this._oneTimeListeners), this;
        }
        once(e, n) {
          return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, be(e, n, this._oneTimeListeners), this) : new Promise((a) => this.once(e, a));
        }
        fire(e, n) {
          typeof e == "string" && (e = new Pe(e, n || {}));
          const a = e.type;
          if (this.listens(a)) {
            e.target = this;
            const u = this._listeners && this._listeners[a] ? this._listeners[a].slice() : [];
            for (const S of u) S.call(this, e);
            const d = this._oneTimeListeners && this._oneTimeListeners[a] ? this._oneTimeListeners[a].slice() : [];
            for (const S of d) Ie(a, S, this._oneTimeListeners), S.call(this, e);
            const m = this._eventedParent;
            m && (Ot(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), m.fire(e));
          } else e instanceof ti && console.error(e.error);
          return this;
        }
        listens(e) {
          return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
        }
        setEventedParent(e, n) {
          return this._eventedParent = e, this._eventedParentData = n, this;
        }
      }
      var Y = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const ui = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function Ge(i, e) {
        const n = {};
        for (const a in i) a !== "ref" && (n[a] = i[a]);
        return ui.forEach((a) => {
          a in e && (n[a] = e[a]);
        }), n;
      }
      function se(i, e) {
        if (Array.isArray(i)) {
          if (!Array.isArray(e) || i.length !== e.length) return !1;
          for (let n = 0; n < i.length; n++) if (!se(i[n], e[n])) return !1;
          return !0;
        }
        if (typeof i == "object" && i !== null && e !== null) {
          if (typeof e != "object" || Object.keys(i).length !== Object.keys(e).length) return !1;
          for (const n in i) if (!se(i[n], e[n])) return !1;
          return !0;
        }
        return i === e;
      }
      function _e(i, e) {
        i.push(e);
      }
      function ze(i, e, n) {
        _e(n, { command: "addSource", args: [i, e[i]] });
      }
      function ke(i, e, n) {
        _e(e, { command: "removeSource", args: [i] }), n[i] = !0;
      }
      function Ze(i, e, n, a) {
        ke(i, n, a), ze(i, e, n);
      }
      function di(i, e, n) {
        let a;
        for (a in i[n]) if (Object.prototype.hasOwnProperty.call(i[n], a) && a !== "data" && !se(i[n][a], e[n][a])) return !1;
        for (a in e[n]) if (Object.prototype.hasOwnProperty.call(e[n], a) && a !== "data" && !se(i[n][a], e[n][a])) return !1;
        return !0;
      }
      function ai(i, e, n, a, u, d) {
        i = i || {}, e = e || {};
        for (const m in i) Object.prototype.hasOwnProperty.call(i, m) && (se(i[m], e[m]) || n.push({ command: d, args: [a, m, e[m], u] }));
        for (const m in e) Object.prototype.hasOwnProperty.call(e, m) && !Object.prototype.hasOwnProperty.call(i, m) && (se(i[m], e[m]) || n.push({ command: d, args: [a, m, e[m], u] }));
      }
      function wi(i) {
        return i.id;
      }
      function Ei(i, e) {
        return i[e.id] = e, i;
      }
      class oe {
        constructor(e, n, a, u) {
          this.message = (e ? `${e}: ` : "") + a, u && (this.identifier = u), n != null && n.__line__ && (this.line = n.__line__);
        }
      }
      function ei(i, ...e) {
        for (const n of e) for (const a in n) i[a] = n[a];
        return i;
      }
      class oi extends Error {
        constructor(e, n) {
          super(n), this.message = n, this.key = e;
        }
      }
      class Te {
        constructor(e, n = []) {
          this.parent = e, this.bindings = {};
          for (const [a, u] of n) this.bindings[a] = u;
        }
        concat(e) {
          return new Te(this, e);
        }
        get(e) {
          if (this.bindings[e]) return this.bindings[e];
          if (this.parent) return this.parent.get(e);
          throw new Error(`${e} not found in scope.`);
        }
        has(e) {
          return !!this.bindings[e] || !!this.parent && this.parent.has(e);
        }
      }
      const cr = { kind: "null" }, le = { kind: "number" }, si = { kind: "string" }, Ce = { kind: "boolean" }, zi = { kind: "color" }, Sr = { kind: "object" }, Ee = { kind: "value" }, Xr = { kind: "collator" }, Vi = { kind: "formatted" }, Mr = { kind: "padding" }, Er = { kind: "resolvedImage" }, ut = { kind: "variableAnchorOffsetCollection" };
      function V(i, e) {
        return { kind: "array", itemType: i, N: e };
      }
      function Z(i) {
        if (i.kind === "array") {
          const e = Z(i.itemType);
          return typeof i.N == "number" ? `array<${e}, ${i.N}>` : i.itemType.kind === "value" ? "array" : `array<${e}>`;
        }
        return i.kind;
      }
      const et = [cr, le, si, Ce, zi, Vi, Sr, V(Ee), Mr, Er, ut];
      function ct(i, e) {
        if (e.kind === "error") return null;
        if (i.kind === "array") {
          if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !ct(i.itemType, e.itemType)) && (typeof i.N != "number" || i.N === e.N)) return null;
        } else {
          if (i.kind === e.kind) return null;
          if (i.kind === "value") {
            for (const n of et) if (!ct(n, e)) return null;
          }
        }
        return `Expected ${Z(i)} but found ${Z(e)} instead.`;
      }
      function Pt(i, e) {
        return e.some((n) => n.kind === i.kind);
      }
      function Mt(i, e) {
        return e.some((n) => n === "null" ? i === null : n === "array" ? Array.isArray(i) : n === "object" ? i && !Array.isArray(i) && typeof i == "object" : n === typeof i);
      }
      function At(i, e) {
        return i.kind === "array" && e.kind === "array" ? i.itemType.kind === e.itemType.kind && typeof i.N == "number" : i.kind === e.kind;
      }
      const bt = 0.96422, Ut = 0.82521, te = 4 / 29, Bt = 6 / 29, me = 3 * Bt * Bt, Ne = Bt * Bt * Bt, $e = Math.PI / 180, xi = 180 / Math.PI;
      function Ke(i) {
        return (i %= 360) < 0 && (i += 360), i;
      }
      function yi([i, e, n, a]) {
        let u, d;
        const m = Zi((0.2225045 * (i = pi(i)) + 0.7168786 * (e = pi(e)) + 0.0606169 * (n = pi(n))) / 1);
        i === e && e === n ? u = d = m : (u = Zi((0.4360747 * i + 0.3850649 * e + 0.1430804 * n) / bt), d = Zi((0.0139322 * i + 0.0971045 * e + 0.7141733 * n) / Ut));
        const S = 116 * m - 16;
        return [S < 0 ? 0 : S, 500 * (u - m), 200 * (m - d), a];
      }
      function pi(i) {
        return i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
      }
      function Zi(i) {
        return i > Ne ? Math.pow(i, 1 / 3) : i / me + te;
      }
      function Bi([i, e, n, a]) {
        let u = (i + 16) / 116, d = isNaN(e) ? u : u + e / 500, m = isNaN(n) ? u : u - n / 200;
        return u = 1 * Di(u), d = bt * Di(d), m = Ut * Di(m), [li(3.1338561 * d - 1.6168667 * u - 0.4906146 * m), li(-0.9787684 * d + 1.9161415 * u + 0.033454 * m), li(0.0719453 * d - 0.2289914 * u + 1.4052427 * m), a];
      }
      function li(i) {
        return (i = i <= 304e-5 ? 12.92 * i : 1.055 * Math.pow(i, 1 / 2.4) - 0.055) < 0 ? 0 : i > 1 ? 1 : i;
      }
      function Di(i) {
        return i > Bt ? i * i * i : me * (i - te);
      }
      function Gi(i) {
        return parseInt(i.padEnd(2, i), 16) / 255;
      }
      function hr(i, e) {
        return pr(e ? i / 100 : i, 0, 1);
      }
      function pr(i, e, n) {
        return Math.min(Math.max(e, i), n);
      }
      function Ar(i) {
        return !i.some(Number.isNaN);
      }
      const Es = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      class Ri {
        constructor(e, n, a, u = 1, d = !0) {
          this.r = e, this.g = n, this.b = a, this.a = u, d || (this.r *= u, this.g *= u, this.b *= u, u || this.overwriteGetter("rgb", [e, n, a, u]));
        }
        static parse(e) {
          if (e instanceof Ri) return e;
          if (typeof e != "string") return;
          const n = function(a) {
            if ((a = a.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
            const u = Es[a];
            if (u) {
              const [m, S, I] = u;
              return [m / 255, S / 255, I / 255, 1];
            }
            if (a.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(a)) {
              const m = a.length < 6 ? 1 : 2;
              let S = 1;
              return [Gi(a.slice(S, S += m)), Gi(a.slice(S, S += m)), Gi(a.slice(S, S += m)), Gi(a.slice(S, S + m) || "ff")];
            }
            if (a.startsWith("rgb")) {
              const m = a.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (m) {
                const [S, I, C, N, D, G, W, J, rt, dt, vt, Dt] = m, Lt = [N || " ", W || " ", dt].join("");
                if (Lt === "  " || Lt === "  /" || Lt === ",," || Lt === ",,,") {
                  const Nt = [C, G, rt].join(""), Zt = Nt === "%%%" ? 100 : Nt === "" ? 255 : 0;
                  if (Zt) {
                    const ge = [pr(+I / Zt, 0, 1), pr(+D / Zt, 0, 1), pr(+J / Zt, 0, 1), vt ? hr(+vt, Dt) : 1];
                    if (Ar(ge)) return ge;
                  }
                }
                return;
              }
            }
            const d = a.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (d) {
              const [m, S, I, C, N, D, G, W, J] = d, rt = [I || " ", N || " ", G].join("");
              if (rt === "  " || rt === "  /" || rt === ",," || rt === ",,,") {
                const dt = [+S, pr(+C, 0, 100), pr(+D, 0, 100), W ? hr(+W, J) : 1];
                if (Ar(dt)) return function([vt, Dt, Lt, Nt]) {
                  function Zt(ge) {
                    const Me = (ge + vt / 30) % 12, ri = Dt * Math.min(Lt, 1 - Lt);
                    return Lt - ri * Math.max(-1, Math.min(Me - 3, 9 - Me, 1));
                  }
                  return vt = Ke(vt), Dt /= 100, Lt /= 100, [Zt(0), Zt(8), Zt(4), Nt];
                }(dt);
              }
            }
          }(e);
          return n ? new Ri(...n, !1) : void 0;
        }
        get rgb() {
          const { r: e, g: n, b: a, a: u } = this, d = u || 1 / 0;
          return this.overwriteGetter("rgb", [e / d, n / d, a / d, u]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(e) {
            const [n, a, u, d] = yi(e), m = Math.sqrt(a * a + u * u);
            return [Math.round(1e4 * m) ? Ke(Math.atan2(u, a) * xi) : NaN, m, n, d];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", yi(this.rgb));
        }
        overwriteGetter(e, n) {
          return Object.defineProperty(this, e, { value: n }), n;
        }
        toString() {
          const [e, n, a, u] = this.rgb;
          return `rgba(${[e, n, a].map((d) => Math.round(255 * d)).join(",")},${u})`;
        }
      }
      Ri.black = new Ri(0, 0, 0, 1), Ri.white = new Ri(1, 1, 1, 1), Ri.transparent = new Ri(0, 0, 0, 0), Ri.red = new Ri(1, 0, 0, 1);
      class No {
        constructor(e, n, a) {
          this.sensitivity = e ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = a, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(e, n) {
          return this.collator.compare(e, n);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class Ks {
        constructor(e, n, a, u, d) {
          this.text = e, this.image = n, this.scale = a, this.fontStack = u, this.textColor = d;
        }
      }
      class Hr {
        constructor(e) {
          this.sections = e;
        }
        static fromString(e) {
          return new Hr([new Ks(e, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
        }
        static factory(e) {
          return e instanceof Hr ? e : Hr.fromString(e);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
        }
      }
      class ln {
        constructor(e) {
          this.values = e.slice();
        }
        static parse(e) {
          if (e instanceof ln) return e;
          if (typeof e == "number") return new ln([e, e, e, e]);
          if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
            for (const n of e) if (typeof n != "number") return;
            switch (e.length) {
              case 1:
                e = [e[0], e[0], e[0], e[0]];
                break;
              case 2:
                e = [e[0], e[1], e[0], e[1]];
                break;
              case 3:
                e = [e[0], e[1], e[2], e[1]];
            }
            return new ln(e);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Do = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class mn {
        constructor(e) {
          this.values = e.slice();
        }
        static parse(e) {
          if (e instanceof mn) return e;
          if (Array.isArray(e) && !(e.length < 1) && e.length % 2 == 0) {
            for (let n = 0; n < e.length; n += 2) {
              const a = e[n], u = e[n + 1];
              if (typeof a != "string" || !Do.has(a) || !Array.isArray(u) || u.length !== 2 || typeof u[0] != "number" || typeof u[1] != "number") return;
            }
            return new mn(e);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      class Yr {
        constructor(e) {
          this.name = e.name, this.available = e.available;
        }
        toString() {
          return this.name;
        }
        static fromString(e) {
          return e ? new Yr({ name: e, available: !1 }) : null;
        }
      }
      function Js(i, e, n, a) {
        return typeof i == "number" && i >= 0 && i <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? a === void 0 || typeof a == "number" && a >= 0 && a <= 1 ? null : `Invalid rgba value [${[i, e, n, a].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof a == "number" ? [i, e, n, a] : [i, e, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Dn(i) {
        if (i === null || typeof i == "string" || typeof i == "boolean" || typeof i == "number" || i instanceof Ri || i instanceof No || i instanceof Hr || i instanceof ln || i instanceof mn || i instanceof Yr) return !0;
        if (Array.isArray(i)) {
          for (const e of i) if (!Dn(e)) return !1;
          return !0;
        }
        if (typeof i == "object") {
          for (const e in i) if (!Dn(i[e])) return !1;
          return !0;
        }
        return !1;
      }
      function fr(i) {
        if (i === null) return cr;
        if (typeof i == "string") return si;
        if (typeof i == "boolean") return Ce;
        if (typeof i == "number") return le;
        if (i instanceof Ri) return zi;
        if (i instanceof No) return Xr;
        if (i instanceof Hr) return Vi;
        if (i instanceof ln) return Mr;
        if (i instanceof mn) return ut;
        if (i instanceof Yr) return Er;
        if (Array.isArray(i)) {
          const e = i.length;
          let n;
          for (const a of i) {
            const u = fr(a);
            if (n) {
              if (n === u) continue;
              n = Ee;
              break;
            }
            n = u;
          }
          return V(n || Ee, e);
        }
        return Sr;
      }
      function Ji(i) {
        const e = typeof i;
        return i === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(i) : i instanceof Ri || i instanceof Hr || i instanceof ln || i instanceof mn || i instanceof Yr ? i.toString() : JSON.stringify(i);
      }
      class gn {
        constructor(e, n) {
          this.type = e, this.value = n;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (!Dn(e[1])) return n.error("invalid value");
          const a = e[1];
          let u = fr(a);
          const d = n.expectedType;
          return u.kind !== "array" || u.N !== 0 || !d || d.kind !== "array" || typeof d.N == "number" && d.N !== 0 || (u = d), new gn(u, a);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      class sr {
        constructor(e) {
          this.name = "ExpressionEvaluationError", this.message = e;
        }
        toJSON() {
          return this.message;
        }
      }
      const va = { string: si, number: le, boolean: Ce, object: Sr };
      class cn {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2) return n.error("Expected at least one argument.");
          let a, u = 1;
          const d = e[0];
          if (d === "array") {
            let S, I;
            if (e.length > 2) {
              const C = e[1];
              if (typeof C != "string" || !(C in va) || C === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
              S = va[C], u++;
            } else S = Ee;
            if (e.length > 3) {
              if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
              I = e[2], u++;
            }
            a = V(S, I);
          } else {
            if (!va[d]) throw new Error(`Types doesn't contain name = ${d}`);
            a = va[d];
          }
          const m = [];
          for (; u < e.length; u++) {
            const S = n.parse(e[u], u, Ee);
            if (!S) return null;
            m.push(S);
          }
          return new cn(a, m);
        }
        evaluate(e) {
          for (let n = 0; n < this.args.length; n++) {
            const a = this.args[n].evaluate(e);
            if (!ct(this.type, fr(a))) return a;
            if (n === this.args.length - 1) throw new sr(`Expected value to be of type ${Z(this.type)}, but found ${Z(fr(a))} instead.`);
          }
          throw new Error();
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      }
      const Fo = { "to-boolean": Ce, "to-color": zi, "to-number": le, "to-string": si };
      class _r {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2) return n.error("Expected at least one argument.");
          const a = e[0];
          if (!Fo[a]) throw new Error(`Can't parse ${a} as it is not part of the known types`);
          if ((a === "to-boolean" || a === "to-string") && e.length !== 2) return n.error("Expected one argument.");
          const u = Fo[a], d = [];
          for (let m = 1; m < e.length; m++) {
            const S = n.parse(e[m], m, Ee);
            if (!S) return null;
            d.push(S);
          }
          return new _r(u, d);
        }
        evaluate(e) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(e);
            case "color": {
              let n, a;
              for (const u of this.args) {
                if (n = u.evaluate(e), a = null, n instanceof Ri) return n;
                if (typeof n == "string") {
                  const d = e.parseColor(n);
                  if (d) return d;
                } else if (Array.isArray(n) && (a = n.length < 3 || n.length > 4 ? `Invalid rbga value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : Js(n[0], n[1], n[2], n[3]), !a)) return new Ri(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
              }
              throw new sr(a || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "padding": {
              let n;
              for (const a of this.args) {
                n = a.evaluate(e);
                const u = ln.parse(n);
                if (u) return u;
              }
              throw new sr(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let n;
              for (const a of this.args) {
                n = a.evaluate(e);
                const u = mn.parse(n);
                if (u) return u;
              }
              throw new sr(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
            }
            case "number": {
              let n = null;
              for (const a of this.args) {
                if (n = a.evaluate(e), n === null) return 0;
                const u = Number(n);
                if (!isNaN(u)) return u;
              }
              throw new sr(`Could not convert ${JSON.stringify(n)} to number.`);
            }
            case "formatted":
              return Hr.fromString(Ji(this.args[0].evaluate(e)));
            case "resolvedImage":
              return Yr.fromString(Ji(this.args[0].evaluate(e)));
            default:
              return Ji(this.args[0].evaluate(e));
          }
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      }
      const Ga = ["Unknown", "Point", "LineString", "Polygon"];
      class Rr {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Ga[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(e) {
          let n = this._parseColorCache[e];
          return n || (n = this._parseColorCache[e] = Ri.parse(e)), n;
        }
      }
      class Jn {
        constructor(e, n, a = [], u, d = new Te(), m = []) {
          this.registry = e, this.path = a, this.key = a.map((S) => `[${S}]`).join(""), this.scope = d, this.errors = m, this.expectedType = u, this._isConstant = n;
        }
        parse(e, n, a, u, d = {}) {
          return n ? this.concat(n, a, u)._parse(e, d) : this._parse(e, d);
        }
        _parse(e, n) {
          function a(u, d, m) {
            return m === "assert" ? new cn(d, [u]) : m === "coerce" ? new _r(d, [u]) : u;
          }
          if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
            if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const u = e[0];
            if (typeof u != "string") return this.error(`Expression name must be a string, but found ${typeof u} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const d = this.registry[u];
            if (d) {
              let m = d.parse(e, this);
              if (!m) return null;
              if (this.expectedType) {
                const S = this.expectedType, I = m.type;
                if (S.kind !== "string" && S.kind !== "number" && S.kind !== "boolean" && S.kind !== "object" && S.kind !== "array" || I.kind !== "value") if (S.kind !== "color" && S.kind !== "formatted" && S.kind !== "resolvedImage" || I.kind !== "value" && I.kind !== "string") if (S.kind !== "padding" || I.kind !== "value" && I.kind !== "number" && I.kind !== "array") if (S.kind !== "variableAnchorOffsetCollection" || I.kind !== "value" && I.kind !== "array") {
                  if (this.checkSubtype(S, I)) return null;
                } else m = a(m, S, n.typeAnnotation || "coerce");
                else m = a(m, S, n.typeAnnotation || "coerce");
                else m = a(m, S, n.typeAnnotation || "coerce");
                else m = a(m, S, n.typeAnnotation || "assert");
              }
              if (!(m instanceof gn) && m.type.kind !== "resolvedImage" && this._isConstant(m)) {
                const S = new Rr();
                try {
                  m = new gn(m.type, m.evaluate(S));
                } catch (I) {
                  return this.error(I.message), null;
                }
              }
              return m;
            }
            return this.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
        }
        concat(e, n, a) {
          const u = typeof e == "number" ? this.path.concat(e) : this.path, d = a ? this.scope.concat(a) : this.scope;
          return new Jn(this.registry, this._isConstant, u, n || null, d, this.errors);
        }
        error(e, ...n) {
          const a = `${this.key}${n.map((u) => `[${u}]`).join("")}`;
          this.errors.push(new oi(a, e));
        }
        checkSubtype(e, n) {
          const a = ct(e, n);
          return a && this.error(a), a;
        }
      }
      class Qn {
        constructor(e, n) {
          this.type = n.type, this.bindings = [].concat(e), this.result = n;
        }
        evaluate(e) {
          return this.result.evaluate(e);
        }
        eachChild(e) {
          for (const n of this.bindings) e(n[1]);
          e(this.result);
        }
        static parse(e, n) {
          if (e.length < 4) return n.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
          const a = [];
          for (let d = 1; d < e.length - 1; d += 2) {
            const m = e[d];
            if (typeof m != "string") return n.error(`Expected string, but found ${typeof m} instead.`, d);
            if (/[^a-zA-Z0-9_]/.test(m)) return n.error("Variable names must contain only alphanumeric characters or '_'.", d);
            const S = n.parse(e[d + 1], d + 1);
            if (!S) return null;
            a.push([m, S]);
          }
          const u = n.parse(e[e.length - 1], e.length - 1, n.expectedType, a);
          return u ? new Qn(a, u) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Fi {
        constructor(e, n) {
          this.type = n.type, this.name = e, this.boundExpression = n;
        }
        static parse(e, n) {
          if (e.length !== 2 || typeof e[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
          const a = e[1];
          return n.scope.has(a) ? new Fi(a, n.scope.get(a)) : n.error(`Unknown variable "${a}". Make sure "${a}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e) {
          return this.boundExpression.evaluate(e);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class $a {
        constructor(e, n, a) {
          this.type = e, this.index = n, this.input = a;
        }
        static parse(e, n) {
          if (e.length !== 3) return n.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const a = n.parse(e[1], 1, le), u = n.parse(e[2], 2, V(n.expectedType || Ee));
          return a && u ? new $a(u.type.itemType, a, u) : null;
        }
        evaluate(e) {
          const n = this.index.evaluate(e), a = this.input.evaluate(e);
          if (n < 0) throw new sr(`Array index out of bounds: ${n} < 0.`);
          if (n >= a.length) throw new sr(`Array index out of bounds: ${n} > ${a.length - 1}.`);
          if (n !== Math.floor(n)) throw new sr(`Array index must be an integer, but found ${n} instead.`);
          return a[n];
        }
        eachChild(e) {
          e(this.index), e(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Bo {
        constructor(e, n) {
          this.type = Ce, this.needle = e, this.haystack = n;
        }
        static parse(e, n) {
          if (e.length !== 3) return n.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const a = n.parse(e[1], 1, Ee), u = n.parse(e[2], 2, Ee);
          return a && u ? Pt(a.type, [Ce, si, le, cr, Ee]) ? new Bo(a, u) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Z(a.type)} instead`) : null;
        }
        evaluate(e) {
          const n = this.needle.evaluate(e), a = this.haystack.evaluate(e);
          if (!a) return !1;
          if (!Mt(n, ["boolean", "string", "number", "null"])) throw new sr(`Expected first argument to be of type boolean, string, number or null, but found ${Z(fr(n))} instead.`);
          if (!Mt(a, ["string", "array"])) throw new sr(`Expected second argument to be of type array or string, but found ${Z(fr(a))} instead.`);
          return a.indexOf(n) >= 0;
        }
        eachChild(e) {
          e(this.needle), e(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class zs {
        constructor(e, n, a) {
          this.type = le, this.needle = e, this.haystack = n, this.fromIndex = a;
        }
        static parse(e, n) {
          if (e.length <= 2 || e.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const a = n.parse(e[1], 1, Ee), u = n.parse(e[2], 2, Ee);
          if (!a || !u) return null;
          if (!Pt(a.type, [Ce, si, le, cr, Ee])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Z(a.type)} instead`);
          if (e.length === 4) {
            const d = n.parse(e[3], 3, le);
            return d ? new zs(a, u, d) : null;
          }
          return new zs(a, u);
        }
        evaluate(e) {
          const n = this.needle.evaluate(e), a = this.haystack.evaluate(e);
          if (!Mt(n, ["boolean", "string", "number", "null"])) throw new sr(`Expected first argument to be of type boolean, string, number or null, but found ${Z(fr(n))} instead.`);
          let u;
          if (this.fromIndex && (u = this.fromIndex.evaluate(e)), Mt(a, ["string"])) {
            const d = a.indexOf(n, u);
            return d === -1 ? -1 : [...a.slice(0, d)].length;
          }
          if (Mt(a, ["array"])) return a.indexOf(n, u);
          throw new sr(`Expected second argument to be of type array or string, but found ${Z(fr(a))} instead.`);
        }
        eachChild(e) {
          e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ro {
        constructor(e, n, a, u, d, m) {
          this.inputType = e, this.type = n, this.input = a, this.cases = u, this.outputs = d, this.otherwise = m;
        }
        static parse(e, n) {
          if (e.length < 5) return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 1) return n.error("Expected an even number of arguments.");
          let a, u;
          n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
          const d = {}, m = [];
          for (let C = 2; C < e.length - 1; C += 2) {
            let N = e[C];
            const D = e[C + 1];
            Array.isArray(N) || (N = [N]);
            const G = n.concat(C);
            if (N.length === 0) return G.error("Expected at least one branch label.");
            for (const J of N) {
              if (typeof J != "number" && typeof J != "string") return G.error("Branch labels must be numbers or strings.");
              if (typeof J == "number" && Math.abs(J) > Number.MAX_SAFE_INTEGER) return G.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof J == "number" && Math.floor(J) !== J) return G.error("Numeric branch labels must be integer values.");
              if (a) {
                if (G.checkSubtype(a, fr(J))) return null;
              } else a = fr(J);
              if (d[String(J)] !== void 0) return G.error("Branch labels must be unique.");
              d[String(J)] = m.length;
            }
            const W = n.parse(D, C, u);
            if (!W) return null;
            u = u || W.type, m.push(W);
          }
          const S = n.parse(e[1], 1, Ee);
          if (!S) return null;
          const I = n.parse(e[e.length - 1], e.length - 1, u);
          return I ? S.type.kind !== "value" && n.concat(1).checkSubtype(a, S.type) ? null : new Ro(a, u, S, d, m, I) : null;
        }
        evaluate(e) {
          const n = this.input.evaluate(e);
          return (fr(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(e);
        }
        eachChild(e) {
          e(this.input), this.outputs.forEach(e), e(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class Qs {
        constructor(e, n, a) {
          this.type = e, this.branches = n, this.otherwise = a;
        }
        static parse(e, n) {
          if (e.length < 4) return n.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 0) return n.error("Expected an odd number of arguments.");
          let a;
          n.expectedType && n.expectedType.kind !== "value" && (a = n.expectedType);
          const u = [];
          for (let m = 1; m < e.length - 1; m += 2) {
            const S = n.parse(e[m], m, Ce);
            if (!S) return null;
            const I = n.parse(e[m + 1], m + 1, a);
            if (!I) return null;
            u.push([S, I]), a = a || I.type;
          }
          const d = n.parse(e[e.length - 1], e.length - 1, a);
          if (!d) return null;
          if (!a) throw new Error("Can't infer output type");
          return new Qs(a, u, d);
        }
        evaluate(e) {
          for (const [n, a] of this.branches) if (n.evaluate(e)) return a.evaluate(e);
          return this.otherwise.evaluate(e);
        }
        eachChild(e) {
          for (const [n, a] of this.branches) e(n), e(a);
          e(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([e, n]) => n.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class xa {
        constructor(e, n, a, u) {
          this.type = e, this.input = n, this.beginIndex = a, this.endIndex = u;
        }
        static parse(e, n) {
          if (e.length <= 2 || e.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const a = n.parse(e[1], 1, Ee), u = n.parse(e[2], 2, le);
          if (!a || !u) return null;
          if (!Pt(a.type, [V(Ee), si, Ee])) return n.error(`Expected first argument to be of type array or string, but found ${Z(a.type)} instead`);
          if (e.length === 4) {
            const d = n.parse(e[3], 3, le);
            return d ? new xa(a.type, a, u, d) : null;
          }
          return new xa(a.type, a, u);
        }
        evaluate(e) {
          const n = this.input.evaluate(e), a = this.beginIndex.evaluate(e);
          let u;
          if (this.endIndex && (u = this.endIndex.evaluate(e)), Mt(n, ["string"])) return [...n].slice(a, u).join("");
          if (Mt(n, ["array"])) return n.slice(a, u);
          throw new sr(`Expected first argument to be of type array or string, but found ${Z(fr(n))} instead.`);
        }
        eachChild(e) {
          e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function Za(i, e) {
        const n = i.length - 1;
        let a, u, d = 0, m = n, S = 0;
        for (; d <= m; ) if (S = Math.floor((d + m) / 2), a = i[S], u = i[S + 1], a <= e) {
          if (S === n || e < u) return S;
          d = S + 1;
        } else {
          if (!(a > e)) throw new sr("Input is not a number.");
          m = S - 1;
        }
        return 0;
      }
      class ta {
        constructor(e, n, a) {
          this.type = e, this.input = n, this.labels = [], this.outputs = [];
          for (const [u, d] of a) this.labels.push(u), this.outputs.push(d);
        }
        static parse(e, n) {
          if (e.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          const a = n.parse(e[1], 1, le);
          if (!a) return null;
          const u = [];
          let d = null;
          n.expectedType && n.expectedType.kind !== "value" && (d = n.expectedType);
          for (let m = 1; m < e.length; m += 2) {
            const S = m === 1 ? -1 / 0 : e[m], I = e[m + 1], C = m, N = m + 1;
            if (typeof S != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', C);
            if (u.length && u[u.length - 1][0] >= S) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', C);
            const D = n.parse(I, N, d);
            if (!D) return null;
            d = d || D.type, u.push([S, D]);
          }
          return new ta(d, a, u);
        }
        evaluate(e) {
          const n = this.labels, a = this.outputs;
          if (n.length === 1) return a[0].evaluate(e);
          const u = this.input.evaluate(e);
          if (u <= n[0]) return a[0].evaluate(e);
          const d = n.length;
          return u >= n[d - 1] ? a[d - 1].evaluate(e) : a[Za(n, u)].evaluate(e);
        }
        eachChild(e) {
          e(this.input);
          for (const n of this.outputs) e(n);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
      }
      function fs(i) {
        return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
      }
      var Wa = ba;
      function ba(i, e, n, a) {
        this.cx = 3 * i, this.bx = 3 * (n - i) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (a - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = i, this.p1y = e, this.p2x = n, this.p2y = a;
      }
      ba.prototype = { sampleCurveX: function(i) {
        return ((this.ax * i + this.bx) * i + this.cx) * i;
      }, sampleCurveY: function(i) {
        return ((this.ay * i + this.by) * i + this.cy) * i;
      }, sampleCurveDerivativeX: function(i) {
        return (3 * this.ax * i + 2 * this.bx) * i + this.cx;
      }, solveCurveX: function(i, e) {
        if (e === void 0 && (e = 1e-6), i < 0) return 0;
        if (i > 1) return 1;
        for (var n = i, a = 0; a < 8; a++) {
          var u = this.sampleCurveX(n) - i;
          if (Math.abs(u) < e) return n;
          var d = this.sampleCurveDerivativeX(n);
          if (Math.abs(d) < 1e-6) break;
          n -= u / d;
        }
        var m = 0, S = 1;
        for (n = i, a = 0; a < 20 && (u = this.sampleCurveX(n), !(Math.abs(u - i) < e)); a++) i > u ? m = n : S = n, n = 0.5 * (S - m) + m;
        return n;
      }, solve: function(i, e) {
        return this.sampleCurveY(this.solveCurveX(i, e));
      } };
      var cl = fs(Wa);
      function mr(i, e, n) {
        return i + n * (e - i);
      }
      function wa(i, e, n) {
        return i.map((a, u) => mr(a, e[u], n));
      }
      const Or = { number: mr, color: function(i, e, n, a = "rgb") {
        switch (a) {
          case "rgb": {
            const [u, d, m, S] = wa(i.rgb, e.rgb, n);
            return new Ri(u, d, m, S, !1);
          }
          case "hcl": {
            const [u, d, m, S] = i.hcl, [I, C, N, D] = e.hcl;
            let G, W;
            if (isNaN(u) || isNaN(I)) isNaN(u) ? isNaN(I) ? G = NaN : (G = I, m !== 1 && m !== 0 || (W = C)) : (G = u, N !== 1 && N !== 0 || (W = d));
            else {
              let Dt = I - u;
              I > u && Dt > 180 ? Dt -= 360 : I < u && u - I > 180 && (Dt += 360), G = u + n * Dt;
            }
            const [J, rt, dt, vt] = function([Dt, Lt, Nt, Zt]) {
              return Dt = isNaN(Dt) ? 0 : Dt * $e, Bi([Nt, Math.cos(Dt) * Lt, Math.sin(Dt) * Lt, Zt]);
            }([G, W ?? mr(d, C, n), mr(m, N, n), mr(S, D, n)]);
            return new Ri(J, rt, dt, vt, !1);
          }
          case "lab": {
            const [u, d, m, S] = Bi(wa(i.lab, e.lab, n));
            return new Ri(u, d, m, S, !1);
          }
        }
      }, array: wa, padding: function(i, e, n) {
        return new ln(wa(i.values, e.values, n));
      }, variableAnchorOffsetCollection: function(i, e, n) {
        const a = i.values, u = e.values;
        if (a.length !== u.length) throw new sr(`Cannot interpolate values of different length. from: ${i.toString()}, to: ${e.toString()}`);
        const d = [];
        for (let m = 0; m < a.length; m += 2) {
          if (a[m] !== u[m]) throw new sr(`Cannot interpolate values containing mismatched anchors. from[${m}]: ${a[m]}, to[${m}]: ${u[m]}`);
          d.push(a[m]);
          const [S, I] = a[m + 1], [C, N] = u[m + 1];
          d.push([mr(S, C, n), mr(I, N, n)]);
        }
        return new mn(d);
      } };
      class He {
        constructor(e, n, a, u, d) {
          this.type = e, this.operator = n, this.interpolation = a, this.input = u, this.labels = [], this.outputs = [];
          for (const [m, S] of d) this.labels.push(m), this.outputs.push(S);
        }
        static interpolationFactor(e, n, a, u) {
          let d = 0;
          if (e.name === "exponential") d = Xa(n, e.base, a, u);
          else if (e.name === "linear") d = Xa(n, 1, a, u);
          else if (e.name === "cubic-bezier") {
            const m = e.controlPoints;
            d = new cl(m[0], m[1], m[2], m[3]).solve(Xa(n, 1, a, u));
          }
          return d;
        }
        static parse(e, n) {
          let [a, u, d, ...m] = e;
          if (!Array.isArray(u) || u.length === 0) return n.error("Expected an interpolation type expression.", 1);
          if (u[0] === "linear") u = { name: "linear" };
          else if (u[0] === "exponential") {
            const C = u[1];
            if (typeof C != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
            u = { name: "exponential", base: C };
          } else {
            if (u[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(u[0])}`, 1, 0);
            {
              const C = u.slice(1);
              if (C.length !== 4 || C.some((N) => typeof N != "number" || N < 0 || N > 1)) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              u = { name: "cubic-bezier", controlPoints: C };
            }
          }
          if (e.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
          if (d = n.parse(d, 2, le), !d) return null;
          const S = [];
          let I = null;
          a === "interpolate-hcl" || a === "interpolate-lab" ? I = zi : n.expectedType && n.expectedType.kind !== "value" && (I = n.expectedType);
          for (let C = 0; C < m.length; C += 2) {
            const N = m[C], D = m[C + 1], G = C + 3, W = C + 4;
            if (typeof N != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', G);
            if (S.length && S[S.length - 1][0] >= N) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', G);
            const J = n.parse(D, W, I);
            if (!J) return null;
            I = I || J.type, S.push([N, J]);
          }
          return At(I, le) || At(I, zi) || At(I, Mr) || At(I, ut) || At(I, V(le)) ? new He(I, a, u, d, S) : n.error(`Type ${Z(I)} is not interpolatable.`);
        }
        evaluate(e) {
          const n = this.labels, a = this.outputs;
          if (n.length === 1) return a[0].evaluate(e);
          const u = this.input.evaluate(e);
          if (u <= n[0]) return a[0].evaluate(e);
          const d = n.length;
          if (u >= n[d - 1]) return a[d - 1].evaluate(e);
          const m = Za(n, u), S = He.interpolationFactor(this.interpolation, u, n[m], n[m + 1]), I = a[m].evaluate(e), C = a[m + 1].evaluate(e);
          switch (this.operator) {
            case "interpolate":
              return Or[this.type.kind](I, C, S);
            case "interpolate-hcl":
              return Or.color(I, C, S, "hcl");
            case "interpolate-lab":
              return Or.color(I, C, S, "lab");
          }
        }
        eachChild(e) {
          e(this.input);
          for (const n of this.outputs) e(n);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
      }
      function Xa(i, e, n, a) {
        const u = a - n, d = i - n;
        return u === 0 ? 0 : e === 1 ? d / u : (Math.pow(e, d) - 1) / (Math.pow(e, u) - 1);
      }
      class Ha {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2) return n.error("Expectected at least one argument.");
          let a = null;
          const u = n.expectedType;
          u && u.kind !== "value" && (a = u);
          const d = [];
          for (const S of e.slice(1)) {
            const I = n.parse(S, 1 + d.length, a, void 0, { typeAnnotation: "omit" });
            if (!I) return null;
            a = a || I.type, d.push(I);
          }
          if (!a) throw new Error("No output type");
          const m = u && d.some((S) => ct(u, S.type));
          return new Ha(m ? Ee : a, d);
        }
        evaluate(e) {
          let n, a = null, u = 0;
          for (const d of this.args) if (u++, a = d.evaluate(e), a && a instanceof Yr && !a.available && (n || (n = a.name), a = null, u === this.args.length && (a = n)), a !== null) break;
          return a;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      }
      function An(i, e) {
        return i === "==" || i === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
      }
      function Oo(i, e, n, a) {
        return a.compare(e, n) === 0;
      }
      function Ns(i, e, n) {
        const a = i !== "==" && i !== "!=";
        return class Jp {
          constructor(d, m, S) {
            this.type = Ce, this.lhs = d, this.rhs = m, this.collator = S, this.hasUntypedArgument = d.type.kind === "value" || m.type.kind === "value";
          }
          static parse(d, m) {
            if (d.length !== 3 && d.length !== 4) return m.error("Expected two or three arguments.");
            const S = d[0];
            let I = m.parse(d[1], 1, Ee);
            if (!I) return null;
            if (!An(S, I.type)) return m.concat(1).error(`"${S}" comparisons are not supported for type '${Z(I.type)}'.`);
            let C = m.parse(d[2], 2, Ee);
            if (!C) return null;
            if (!An(S, C.type)) return m.concat(2).error(`"${S}" comparisons are not supported for type '${Z(C.type)}'.`);
            if (I.type.kind !== C.type.kind && I.type.kind !== "value" && C.type.kind !== "value") return m.error(`Cannot compare types '${Z(I.type)}' and '${Z(C.type)}'.`);
            a && (I.type.kind === "value" && C.type.kind !== "value" ? I = new cn(C.type, [I]) : I.type.kind !== "value" && C.type.kind === "value" && (C = new cn(I.type, [C])));
            let N = null;
            if (d.length === 4) {
              if (I.type.kind !== "string" && C.type.kind !== "string" && I.type.kind !== "value" && C.type.kind !== "value") return m.error("Cannot use collator to compare non-string types.");
              if (N = m.parse(d[3], 3, Xr), !N) return null;
            }
            return new Jp(I, C, N);
          }
          evaluate(d) {
            const m = this.lhs.evaluate(d), S = this.rhs.evaluate(d);
            if (a && this.hasUntypedArgument) {
              const I = fr(m), C = fr(S);
              if (I.kind !== C.kind || I.kind !== "string" && I.kind !== "number") throw new sr(`Expected arguments for "${i}" to be (string, string) or (number, number), but found (${I.kind}, ${C.kind}) instead.`);
            }
            if (this.collator && !a && this.hasUntypedArgument) {
              const I = fr(m), C = fr(S);
              if (I.kind !== "string" || C.kind !== "string") return e(d, m, S);
            }
            return this.collator ? n(d, m, S, this.collator.evaluate(d)) : e(d, m, S);
          }
          eachChild(d) {
            d(this.lhs), d(this.rhs), this.collator && d(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const Ya = Ns("==", function(i, e, n) {
        return e === n;
      }, Oo), Ka = Ns("!=", function(i, e, n) {
        return e !== n;
      }, function(i, e, n, a) {
        return !Oo(0, e, n, a);
      }), hl = Ns("<", function(i, e, n) {
        return e < n;
      }, function(i, e, n, a) {
        return a.compare(e, n) < 0;
      }), El = Ns(">", function(i, e, n) {
        return e > n;
      }, function(i, e, n, a) {
        return a.compare(e, n) > 0;
      }), zl = Ns("<=", function(i, e, n) {
        return e <= n;
      }, function(i, e, n, a) {
        return a.compare(e, n) <= 0;
      }), Ja = Ns(">=", function(i, e, n) {
        return e >= n;
      }, function(i, e, n, a) {
        return a.compare(e, n) >= 0;
      });
      class ts {
        constructor(e, n, a) {
          this.type = Xr, this.locale = a, this.caseSensitive = e, this.diacriticSensitive = n;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error("Expected one argument.");
          const a = e[1];
          if (typeof a != "object" || Array.isArray(a)) return n.error("Collator options argument must be an object.");
          const u = n.parse(a["case-sensitive"] !== void 0 && a["case-sensitive"], 1, Ce);
          if (!u) return null;
          const d = n.parse(a["diacritic-sensitive"] !== void 0 && a["diacritic-sensitive"], 1, Ce);
          if (!d) return null;
          let m = null;
          return a.locale && (m = n.parse(a.locale, 1, si), !m) ? null : new ts(u, d, m);
        }
        evaluate(e) {
          return new No(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
        }
        eachChild(e) {
          e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class ms {
        constructor(e, n, a, u, d) {
          this.type = si, this.number = e, this.locale = n, this.currency = a, this.minFractionDigits = u, this.maxFractionDigits = d;
        }
        static parse(e, n) {
          if (e.length !== 3) return n.error("Expected two arguments.");
          const a = n.parse(e[1], 1, le);
          if (!a) return null;
          const u = e[2];
          if (typeof u != "object" || Array.isArray(u)) return n.error("NumberFormat options argument must be an object.");
          let d = null;
          if (u.locale && (d = n.parse(u.locale, 1, si), !d)) return null;
          let m = null;
          if (u.currency && (m = n.parse(u.currency, 1, si), !m)) return null;
          let S = null;
          if (u["min-fraction-digits"] && (S = n.parse(u["min-fraction-digits"], 1, le), !S)) return null;
          let I = null;
          return u["max-fraction-digits"] && (I = n.parse(u["max-fraction-digits"], 1, le), !I) ? null : new ms(a, d, m, S, I);
        }
        evaluate(e) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
        }
        eachChild(e) {
          e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class Qa {
        constructor(e) {
          this.type = Vi, this.sections = e;
        }
        static parse(e, n) {
          if (e.length < 2) return n.error("Expected at least one argument.");
          const a = e[1];
          if (!Array.isArray(a) && typeof a == "object") return n.error("First argument must be an image or text section.");
          const u = [];
          let d = !1;
          for (let m = 1; m <= e.length - 1; ++m) {
            const S = e[m];
            if (d && typeof S == "object" && !Array.isArray(S)) {
              d = !1;
              let I = null;
              if (S["font-scale"] && (I = n.parse(S["font-scale"], 1, le), !I)) return null;
              let C = null;
              if (S["text-font"] && (C = n.parse(S["text-font"], 1, V(si)), !C)) return null;
              let N = null;
              if (S["text-color"] && (N = n.parse(S["text-color"], 1, zi), !N)) return null;
              const D = u[u.length - 1];
              D.scale = I, D.font = C, D.textColor = N;
            } else {
              const I = n.parse(e[m], 1, Ee);
              if (!I) return null;
              const C = I.type.kind;
              if (C !== "string" && C !== "value" && C !== "null" && C !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              d = !0, u.push({ content: I, scale: null, font: null, textColor: null });
            }
          }
          return new Qa(u);
        }
        evaluate(e) {
          return new Hr(this.sections.map((n) => {
            const a = n.content.evaluate(e);
            return fr(a) === Er ? new Ks("", a, null, null, null) : new Ks(Ji(a), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null);
          }));
        }
        eachChild(e) {
          for (const n of this.sections) e(n.content), n.scale && e(n.scale), n.font && e(n.font), n.textColor && e(n.textColor);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ds {
        constructor(e) {
          this.type = Er, this.input = e;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error("Expected two arguments.");
          const a = n.parse(e[1], 1, si);
          return a ? new Ds(a) : n.error("No image name provided.");
        }
        evaluate(e) {
          const n = this.input.evaluate(e), a = Yr.fromString(n);
          return a && e.availableImages && (a.available = e.availableImages.indexOf(n) > -1), a;
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class Sa {
        constructor(e) {
          this.type = le, this.input = e;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
          const a = n.parse(e[1], 1);
          return a ? a.type.kind !== "array" && a.type.kind !== "string" && a.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${Z(a.type)} instead.`) : new Sa(a) : null;
        }
        evaluate(e) {
          const n = this.input.evaluate(e);
          if (typeof n == "string") return [...n].length;
          if (Array.isArray(n)) return n.length;
          throw new sr(`Expected value to be of type string or array, but found ${Z(fr(n))} instead.`);
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const hn = 8192;
      function ul(i, e) {
        const n = (180 + i[0]) / 360, a = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i[1] * Math.PI / 360))) / 360, u = Math.pow(2, e.z);
        return [Math.round(n * u * hn), Math.round(a * u * hn)];
      }
      function to(i, e) {
        const n = Math.pow(2, e.z);
        return [(u = (i[0] / hn + e.x) / n, 360 * u - 180), (a = (i[1] / hn + e.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90)];
        var a, u;
      }
      function gs(i, e) {
        i[0] = Math.min(i[0], e[0]), i[1] = Math.min(i[1], e[1]), i[2] = Math.max(i[2], e[0]), i[3] = Math.max(i[3], e[1]);
      }
      function es(i, e) {
        return !(i[0] <= e[0] || i[2] >= e[2] || i[1] <= e[1] || i[3] >= e[3]);
      }
      function Si(i, e, n) {
        const a = i[0] - e[0], u = i[1] - e[1], d = i[0] - n[0], m = i[1] - n[1];
        return a * m - d * u == 0 && a * d <= 0 && u * m <= 0;
      }
      function Fn(i, e, n, a) {
        return (u = [a[0] - n[0], a[1] - n[1]])[0] * (d = [e[0] - i[0], e[1] - i[1]])[1] - u[1] * d[0] != 0 && !(!dl(i, e, n, a) || !dl(n, a, i, e));
        var u, d;
      }
      function Nl(i, e, n) {
        for (const a of n) for (let u = 0; u < a.length - 1; ++u) if (Fn(i, e, a[u], a[u + 1])) return !0;
        return !1;
      }
      function Pn(i, e, n = !1) {
        let a = !1;
        for (const S of e) for (let I = 0; I < S.length - 1; I++) {
          if (Si(i, S[I], S[I + 1])) return n;
          (d = S[I])[1] > (u = i)[1] != (m = S[I + 1])[1] > u[1] && u[0] < (m[0] - d[0]) * (u[1] - d[1]) / (m[1] - d[1]) + d[0] && (a = !a);
        }
        var u, d, m;
        return a;
      }
      function is(i, e) {
        for (const n of e) if (Pn(i, n)) return !0;
        return !1;
      }
      function eo(i, e) {
        for (const n of i) if (!Pn(n, e)) return !1;
        for (let n = 0; n < i.length - 1; ++n) if (Nl(i[n], i[n + 1], e)) return !1;
        return !0;
      }
      function Aa(i, e) {
        for (const n of e) if (eo(i, n)) return !0;
        return !1;
      }
      function dl(i, e, n, a) {
        const u = a[0] - n[0], d = a[1] - n[1], m = (i[0] - n[0]) * d - u * (i[1] - n[1]), S = (e[0] - n[0]) * d - u * (e[1] - n[1]);
        return m > 0 && S < 0 || m < 0 && S > 0;
      }
      function ea(i, e, n) {
        const a = [];
        for (let u = 0; u < i.length; u++) {
          const d = [];
          for (let m = 0; m < i[u].length; m++) {
            const S = ul(i[u][m], n);
            gs(e, S), d.push(S);
          }
          a.push(d);
        }
        return a;
      }
      function pl(i, e, n) {
        const a = [];
        for (let u = 0; u < i.length; u++) {
          const d = ea(i[u], e, n);
          a.push(d);
        }
        return a;
      }
      function io(i, e, n, a) {
        if (i[0] < n[0] || i[0] > n[2]) {
          const u = 0.5 * a;
          let d = i[0] - n[0] > u ? -a : n[0] - i[0] > u ? a : 0;
          d === 0 && (d = i[0] - n[2] > u ? -a : n[2] - i[0] > u ? a : 0), i[0] += d;
        }
        gs(e, i);
      }
      function ro(i, e, n, a) {
        const u = Math.pow(2, a.z) * hn, d = [a.x * hn, a.y * hn], m = [];
        for (const S of i) for (const I of S) {
          const C = [I.x + d[0], I.y + d[1]];
          io(C, e, n, u), m.push(C);
        }
        return m;
      }
      function jo(i, e, n, a) {
        const u = Math.pow(2, a.z) * hn, d = [a.x * hn, a.y * hn], m = [];
        for (const I of i) {
          const C = [];
          for (const N of I) {
            const D = [N.x + d[0], N.y + d[1]];
            gs(e, D), C.push(D);
          }
          m.push(C);
        }
        if (e[2] - e[0] <= u / 2) {
          (S = e)[0] = S[1] = 1 / 0, S[2] = S[3] = -1 / 0;
          for (const I of m) for (const C of I) io(C, e, n, u);
        }
        var S;
        return m;
      }
      class Bn {
        constructor(e, n) {
          this.type = Ce, this.geojson = e, this.geometries = n;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (Dn(e[1])) {
            const a = e[1];
            if (a.type === "FeatureCollection") {
              const u = [];
              for (const d of a.features) {
                const { type: m, coordinates: S } = d.geometry;
                m === "Polygon" && u.push(S), m === "MultiPolygon" && u.push(...S);
              }
              if (u.length) return new Bn(a, { type: "MultiPolygon", coordinates: u });
            } else if (a.type === "Feature") {
              const u = a.geometry.type;
              if (u === "Polygon" || u === "MultiPolygon") return new Bn(a, a.geometry);
            } else if (a.type === "Polygon" || a.type === "MultiPolygon") return new Bn(a, a);
          }
          return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point") return function(n, a) {
              const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = n.canonicalID();
              if (a.type === "Polygon") {
                const S = ea(a.coordinates, d, m), I = ro(n.geometry(), u, d, m);
                if (!es(u, d)) return !1;
                for (const C of I) if (!Pn(C, S)) return !1;
              }
              if (a.type === "MultiPolygon") {
                const S = pl(a.coordinates, d, m), I = ro(n.geometry(), u, d, m);
                if (!es(u, d)) return !1;
                for (const C of I) if (!is(C, S)) return !1;
              }
              return !0;
            }(e, this.geometries);
            if (e.geometryType() === "LineString") return function(n, a) {
              const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = n.canonicalID();
              if (a.type === "Polygon") {
                const S = ea(a.coordinates, d, m), I = jo(n.geometry(), u, d, m);
                if (!es(u, d)) return !1;
                for (const C of I) if (!eo(C, S)) return !1;
              }
              if (a.type === "MultiPolygon") {
                const S = pl(a.coordinates, d, m), I = jo(n.geometry(), u, d, m);
                if (!es(u, d)) return !1;
                for (const C of I) if (!Aa(C, S)) return !1;
              }
              return !0;
            }(e, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let no = class {
        constructor(i = [], e = (n, a) => n < a ? -1 : n > a ? 1 : 0) {
          if (this.data = i, this.length = this.data.length, this.compare = e, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
        }
        push(i) {
          this.data.push(i), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const i = this.data[0], e = this.data.pop();
          return --this.length > 0 && (this.data[0] = e, this._down(0)), i;
        }
        peek() {
          return this.data[0];
        }
        _up(i) {
          const { data: e, compare: n } = this, a = e[i];
          for (; i > 0; ) {
            const u = i - 1 >> 1, d = e[u];
            if (n(a, d) >= 0) break;
            e[i] = d, i = u;
          }
          e[i] = a;
        }
        _down(i) {
          const { data: e, compare: n } = this, a = this.length >> 1, u = e[i];
          for (; i < a; ) {
            let d = 1 + (i << 1);
            const m = d + 1;
            if (m < this.length && n(e[m], e[d]) < 0 && (d = m), n(e[d], u) >= 0) break;
            e[i] = e[d], i = d;
          }
          e[i] = u;
        }
      };
      function qo(i, e, n, a, u) {
        Uo(i, e, n, a || i.length - 1, u || so);
      }
      function Uo(i, e, n, a, u) {
        for (; a > n; ) {
          if (a - n > 600) {
            var d = a - n + 1, m = e - n + 1, S = Math.log(d), I = 0.5 * Math.exp(2 * S / 3), C = 0.5 * Math.sqrt(S * I * (d - I) / d) * (m - d / 2 < 0 ? -1 : 1);
            Uo(i, e, Math.max(n, Math.floor(e - m * I / d + C)), Math.min(a, Math.floor(e + (d - m) * I / d + C)), u);
          }
          var N = i[e], D = n, G = a;
          for (Pa(i, n, e), u(i[a], N) > 0 && Pa(i, n, a); D < G; ) {
            for (Pa(i, D, G), D++, G--; u(i[D], N) < 0; ) D++;
            for (; u(i[G], N) > 0; ) G--;
          }
          u(i[n], N) === 0 ? Pa(i, n, G) : Pa(i, ++G, a), G <= e && (n = G + 1), e <= G && (a = G - 1);
        }
      }
      function Pa(i, e, n) {
        var a = i[e];
        i[e] = i[n], i[n] = a;
      }
      function so(i, e) {
        return i < e ? -1 : i > e ? 1 : 0;
      }
      function ys(i, e) {
        if (i.length <= 1) return [i];
        const n = [];
        let a, u;
        for (const d of i) {
          const m = ia(d);
          m !== 0 && (d.area = Math.abs(m), u === void 0 && (u = m < 0), u === m < 0 ? (a && n.push(a), a = [d]) : a.push(d));
        }
        if (a && n.push(a), e > 1) for (let d = 0; d < n.length; d++) n[d].length <= e || (qo(n[d], e, 1, n[d].length - 1, Vo), n[d] = n[d].slice(0, e));
        return n;
      }
      function Vo(i, e) {
        return e.area - i.area;
      }
      function ia(i) {
        let e = 0;
        for (let n, a, u = 0, d = i.length, m = d - 1; u < d; m = u++) n = i[u], a = i[m], e += (a.x - n.x) * (n.y + a.y);
        return e;
      }
      const ao = 1 / 298.257223563, T = ao * (2 - ao), H = Math.PI / 180;
      class ft {
        constructor(e) {
          const n = 6378.137 * H * 1e3, a = Math.cos(e * H), u = 1 / (1 - T * (1 - a * a)), d = Math.sqrt(u);
          this.kx = n * d * a, this.ky = n * d * u * (1 - T);
        }
        distance(e, n) {
          const a = this.wrap(e[0] - n[0]) * this.kx, u = (e[1] - n[1]) * this.ky;
          return Math.sqrt(a * a + u * u);
        }
        pointOnLine(e, n) {
          let a, u, d, m, S = 1 / 0;
          for (let I = 0; I < e.length - 1; I++) {
            let C = e[I][0], N = e[I][1], D = this.wrap(e[I + 1][0] - C) * this.kx, G = (e[I + 1][1] - N) * this.ky, W = 0;
            D === 0 && G === 0 || (W = (this.wrap(n[0] - C) * this.kx * D + (n[1] - N) * this.ky * G) / (D * D + G * G), W > 1 ? (C = e[I + 1][0], N = e[I + 1][1]) : W > 0 && (C += D / this.kx * W, N += G / this.ky * W)), D = this.wrap(n[0] - C) * this.kx, G = (n[1] - N) * this.ky;
            const J = D * D + G * G;
            J < S && (S = J, a = C, u = N, d = I, m = W);
          }
          return { point: [a, u], index: d, t: Math.max(0, Math.min(1, m)) };
        }
        wrap(e) {
          for (; e < -180; ) e += 360;
          for (; e > 180; ) e -= 360;
          return e;
        }
      }
      function Ct(i, e) {
        return e[0] - i[0];
      }
      function Ft(i) {
        return i[1] - i[0] + 1;
      }
      function Yt(i, e) {
        return i[1] >= i[0] && i[1] < e;
      }
      function ye(i, e) {
        if (i[0] > i[1]) return [null, null];
        const n = Ft(i);
        if (e) {
          if (n === 2) return [i, null];
          const u = Math.floor(n / 2);
          return [[i[0], i[0] + u], [i[0] + u, i[1]]];
        }
        if (n === 1) return [i, null];
        const a = Math.floor(n / 2) - 1;
        return [[i[0], i[0] + a], [i[0] + a + 1, i[1]]];
      }
      function Be(i, e) {
        if (!Yt(e, i.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let a = e[0]; a <= e[1]; ++a) gs(n, i[a]);
        return n;
      }
      function Je(i) {
        const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const n of i) for (const a of n) gs(e, a);
        return e;
      }
      function mi(i) {
        return i[0] !== -1 / 0 && i[1] !== -1 / 0 && i[2] !== 1 / 0 && i[3] !== 1 / 0;
      }
      function gi(i, e, n) {
        if (!mi(i) || !mi(e)) return NaN;
        let a = 0, u = 0;
        return i[2] < e[0] && (a = e[0] - i[2]), i[0] > e[2] && (a = i[0] - e[2]), i[1] > e[3] && (u = i[1] - e[3]), i[3] < e[1] && (u = e[1] - i[3]), n.distance([0, 0], [a, u]);
      }
      function ki(i, e, n) {
        const a = n.pointOnLine(e, i);
        return n.distance(i, a.point);
      }
      function Qi(i, e, n, a, u) {
        const d = Math.min(ki(i, [n, a], u), ki(e, [n, a], u)), m = Math.min(ki(n, [i, e], u), ki(a, [i, e], u));
        return Math.min(d, m);
      }
      function vr(i, e, n, a, u) {
        if (!Yt(e, i.length) || !Yt(a, n.length)) return 1 / 0;
        let d = 1 / 0;
        for (let m = e[0]; m < e[1]; ++m) {
          const S = i[m], I = i[m + 1];
          for (let C = a[0]; C < a[1]; ++C) {
            const N = n[C], D = n[C + 1];
            if (Fn(S, I, N, D)) return 0;
            d = Math.min(d, Qi(S, I, N, D, u));
          }
        }
        return d;
      }
      function Ai(i, e, n, a, u) {
        if (!Yt(e, i.length) || !Yt(a, n.length)) return NaN;
        let d = 1 / 0;
        for (let m = e[0]; m <= e[1]; ++m) for (let S = a[0]; S <= a[1]; ++S) if (d = Math.min(d, u.distance(i[m], n[S])), d === 0) return d;
        return d;
      }
      function Kr(i, e, n) {
        if (Pn(i, e, !0)) return 0;
        let a = 1 / 0;
        for (const u of e) {
          const d = u[0], m = u[u.length - 1];
          if (d !== m && (a = Math.min(a, ki(i, [m, d], n)), a === 0)) return a;
          const S = n.pointOnLine(u, i);
          if (a = Math.min(a, n.distance(i, S.point)), a === 0) return a;
        }
        return a;
      }
      function Ye(i, e, n, a) {
        if (!Yt(e, i.length)) return NaN;
        for (let d = e[0]; d <= e[1]; ++d) if (Pn(i[d], n, !0)) return 0;
        let u = 1 / 0;
        for (let d = e[0]; d < e[1]; ++d) {
          const m = i[d], S = i[d + 1];
          for (const I of n) for (let C = 0, N = I.length, D = N - 1; C < N; D = C++) {
            const G = I[D], W = I[C];
            if (Fn(m, S, G, W)) return 0;
            u = Math.min(u, Qi(m, S, G, W, a));
          }
        }
        return u;
      }
      function yn(i, e) {
        for (const n of i) for (const a of n) if (Pn(a, e, !0)) return !0;
        return !1;
      }
      function Ci(i, e, n, a = 1 / 0) {
        const u = Je(i), d = Je(e);
        if (a !== 1 / 0 && gi(u, d, n) >= a) return a;
        if (es(u, d)) {
          if (yn(i, e)) return 0;
        } else if (yn(e, i)) return 0;
        let m = 1 / 0;
        for (const S of i) for (let I = 0, C = S.length, N = C - 1; I < C; N = I++) {
          const D = S[N], G = S[I];
          for (const W of e) for (let J = 0, rt = W.length, dt = rt - 1; J < rt; dt = J++) {
            const vt = W[dt], Dt = W[J];
            if (Fn(D, G, vt, Dt)) return 0;
            m = Math.min(m, Qi(D, G, vt, Dt, n));
          }
        }
        return m;
      }
      function Mi(i, e, n, a, u, d) {
        if (!d) return;
        const m = gi(Be(a, d), u, n);
        m < e && i.push([m, d, [0, 0]]);
      }
      function _s(i, e, n, a, u, d, m) {
        if (!d || !m) return;
        const S = gi(Be(a, d), Be(u, m), n);
        S < e && i.push([S, d, m]);
      }
      function Fs(i, e, n, a, u = 1 / 0) {
        let d = Math.min(a.distance(i[0], n[0][0]), u);
        if (d === 0) return d;
        const m = new no([[0, [0, i.length - 1], [0, 0]]], Ct), S = Je(n);
        for (; m.length > 0; ) {
          const I = m.pop();
          if (I[0] >= d) continue;
          const C = I[1], N = e ? 50 : 100;
          if (Ft(C) <= N) {
            if (!Yt(C, i.length)) return NaN;
            if (e) {
              const D = Ye(i, C, n, a);
              if (isNaN(D) || D === 0) return D;
              d = Math.min(d, D);
            } else for (let D = C[0]; D <= C[1]; ++D) {
              const G = Kr(i[D], n, a);
              if (d = Math.min(d, G), d === 0) return 0;
            }
          } else {
            const D = ye(C, e);
            Mi(m, d, a, i, S, D[0]), Mi(m, d, a, i, S, D[1]);
          }
        }
        return d;
      }
      function Bs(i, e, n, a, u, d = 1 / 0) {
        let m = Math.min(d, u.distance(i[0], n[0]));
        if (m === 0) return m;
        const S = new no([[0, [0, i.length - 1], [0, n.length - 1]]], Ct);
        for (; S.length > 0; ) {
          const I = S.pop();
          if (I[0] >= m) continue;
          const C = I[1], N = I[2], D = e ? 50 : 100, G = a ? 50 : 100;
          if (Ft(C) <= D && Ft(N) <= G) {
            if (!Yt(C, i.length) && Yt(N, n.length)) return NaN;
            let W;
            if (e && a) W = vr(i, C, n, N, u), m = Math.min(m, W);
            else if (e && !a) {
              const J = i.slice(C[0], C[1] + 1);
              for (let rt = N[0]; rt <= N[1]; ++rt) if (W = ki(n[rt], J, u), m = Math.min(m, W), m === 0) return m;
            } else if (!e && a) {
              const J = n.slice(N[0], N[1] + 1);
              for (let rt = C[0]; rt <= C[1]; ++rt) if (W = ki(i[rt], J, u), m = Math.min(m, W), m === 0) return m;
            } else W = Ai(i, C, n, N, u), m = Math.min(m, W);
          } else {
            const W = ye(C, e), J = ye(N, a);
            _s(S, m, u, i, n, W[0], J[0]), _s(S, m, u, i, n, W[0], J[1]), _s(S, m, u, i, n, W[1], J[0]), _s(S, m, u, i, n, W[1], J[1]);
          }
        }
        return m;
      }
      function ra(i) {
        return i.type === "MultiPolygon" ? i.coordinates.map((e) => ({ type: "Polygon", coordinates: e })) : i.type === "MultiLineString" ? i.coordinates.map((e) => ({ type: "LineString", coordinates: e })) : i.type === "MultiPoint" ? i.coordinates.map((e) => ({ type: "Point", coordinates: e })) : [i];
      }
      class rs {
        constructor(e, n) {
          this.type = le, this.geojson = e, this.geometries = n;
        }
        static parse(e, n) {
          if (e.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (Dn(e[1])) {
            const a = e[1];
            if (a.type === "FeatureCollection") return new rs(a, a.features.map((u) => ra(u.geometry)).flat());
            if (a.type === "Feature") return new rs(a, ra(a.geometry));
            if ("type" in a && "coordinates" in a) return new rs(a, ra(a));
          }
          return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point") return function(n, a) {
              const u = n.geometry(), d = u.flat().map((I) => to([I.x, I.y], n.canonical));
              if (u.length === 0) return NaN;
              const m = new ft(d[0][1]);
              let S = 1 / 0;
              for (const I of a) {
                switch (I.type) {
                  case "Point":
                    S = Math.min(S, Bs(d, !1, [I.coordinates], !1, m, S));
                    break;
                  case "LineString":
                    S = Math.min(S, Bs(d, !1, I.coordinates, !0, m, S));
                    break;
                  case "Polygon":
                    S = Math.min(S, Fs(d, !1, I.coordinates, m, S));
                }
                if (S === 0) return S;
              }
              return S;
            }(e, this.geometries);
            if (e.geometryType() === "LineString") return function(n, a) {
              const u = n.geometry(), d = u.flat().map((I) => to([I.x, I.y], n.canonical));
              if (u.length === 0) return NaN;
              const m = new ft(d[0][1]);
              let S = 1 / 0;
              for (const I of a) {
                switch (I.type) {
                  case "Point":
                    S = Math.min(S, Bs(d, !0, [I.coordinates], !1, m, S));
                    break;
                  case "LineString":
                    S = Math.min(S, Bs(d, !0, I.coordinates, !0, m, S));
                    break;
                  case "Polygon":
                    S = Math.min(S, Fs(d, !0, I.coordinates, m, S));
                }
                if (S === 0) return S;
              }
              return S;
            }(e, this.geometries);
            if (e.geometryType() === "Polygon") return function(n, a) {
              const u = n.geometry();
              if (u.length === 0 || u[0].length === 0) return NaN;
              const d = ys(u, 0).map((I) => I.map((C) => C.map((N) => to([N.x, N.y], n.canonical)))), m = new ft(d[0][0][0][1]);
              let S = 1 / 0;
              for (const I of a) for (const C of d) {
                switch (I.type) {
                  case "Point":
                    S = Math.min(S, Fs([I.coordinates], !1, C, m, S));
                    break;
                  case "LineString":
                    S = Math.min(S, Fs(I.coordinates, !0, C, m, S));
                    break;
                  case "Polygon":
                    S = Math.min(S, Ci(C, I.coordinates, m, S));
                }
                if (S === 0) return S;
              }
              return S;
            }(e, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const vs = { "==": Ya, "!=": Ka, ">": El, "<": hl, ">=": Ja, "<=": zl, array: cn, at: $a, boolean: cn, case: Qs, coalesce: Ha, collator: ts, format: Qa, image: Ds, in: Bo, "index-of": zs, interpolate: He, "interpolate-hcl": He, "interpolate-lab": He, length: Sa, let: Qn, literal: gn, match: Ro, number: cn, "number-format": ms, object: cn, slice: xa, step: ta, string: cn, "to-boolean": _r, "to-color": _r, "to-number": _r, "to-string": _r, var: Fi, within: Bn, distance: rs };
      class jr {
        constructor(e, n, a, u) {
          this.name = e, this.type = n, this._evaluate = a, this.args = u;
        }
        evaluate(e) {
          return this._evaluate(e, this.args);
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return !1;
        }
        static parse(e, n) {
          const a = e[0], u = jr.definitions[a];
          if (!u) return n.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const d = Array.isArray(u) ? u[0] : u.type, m = Array.isArray(u) ? [[u[1], u[2]]] : u.overloads, S = m.filter(([C]) => !Array.isArray(C) || C.length === e.length - 1);
          let I = null;
          for (const [C, N] of S) {
            I = new Jn(n.registry, Rs, n.path, null, n.scope);
            const D = [];
            let G = !1;
            for (let W = 1; W < e.length; W++) {
              const J = e[W], rt = Array.isArray(C) ? C[W - 1] : C.type, dt = I.parse(J, 1 + D.length, rt);
              if (!dt) {
                G = !0;
                break;
              }
              D.push(dt);
            }
            if (!G) if (Array.isArray(C) && C.length !== D.length) I.error(`Expected ${C.length} arguments, but found ${D.length} instead.`);
            else {
              for (let W = 0; W < D.length; W++) {
                const J = Array.isArray(C) ? C[W] : C.type, rt = D[W];
                I.concat(W + 1).checkSubtype(J, rt.type);
              }
              if (I.errors.length === 0) return new jr(a, d, N, D);
            }
          }
          if (S.length === 1) n.errors.push(...I.errors);
          else {
            const C = (S.length ? S : m).map(([D]) => {
              return G = D, Array.isArray(G) ? `(${G.map(Z).join(", ")})` : `(${Z(G.type)}...)`;
              var G;
            }).join(" | "), N = [];
            for (let D = 1; D < e.length; D++) {
              const G = n.parse(e[D], 1 + N.length);
              if (!G) return null;
              N.push(Z(G.type));
            }
            n.error(`Expected arguments of type ${C}, but found (${N.join(", ")}) instead.`);
          }
          return null;
        }
        static register(e, n) {
          jr.definitions = n;
          for (const a in n) e[a] = jr;
        }
      }
      function Lr(i, [e, n, a, u]) {
        e = e.evaluate(i), n = n.evaluate(i), a = a.evaluate(i);
        const d = u ? u.evaluate(i) : 1, m = Js(e, n, a, d);
        if (m) throw new sr(m);
        return new Ri(e / 255, n / 255, a / 255, d, !1);
      }
      function na(i, e) {
        return i in e;
      }
      function sa(i, e) {
        const n = e[i];
        return n === void 0 ? null : n;
      }
      function Rn(i) {
        return { type: i };
      }
      function Rs(i) {
        if (i instanceof Fi) return Rs(i.boundExpression);
        if (i instanceof jr && i.name === "error" || i instanceof ts || i instanceof Bn || i instanceof rs) return !1;
        const e = i instanceof _r || i instanceof cn;
        let n = !0;
        return i.eachChild((a) => {
          n = e ? n && Rs(a) : n && a instanceof gn;
        }), !!n && zr(i) && Os(i, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function zr(i) {
        if (i instanceof jr && (i.name === "get" && i.args.length === 1 || i.name === "feature-state" || i.name === "has" && i.args.length === 1 || i.name === "properties" || i.name === "geometry-type" || i.name === "id" || /^filter-/.test(i.name)) || i instanceof Bn || i instanceof rs) return !1;
        let e = !0;
        return i.eachChild((n) => {
          e && !zr(n) && (e = !1);
        }), e;
      }
      function aa(i) {
        if (i instanceof jr && i.name === "feature-state") return !1;
        let e = !0;
        return i.eachChild((n) => {
          e && !aa(n) && (e = !1);
        }), e;
      }
      function Os(i, e) {
        if (i instanceof jr && e.indexOf(i.name) >= 0) return !1;
        let n = !0;
        return i.eachChild((a) => {
          n && !Os(a, e) && (n = !1);
        }), n;
      }
      function Ia(i) {
        return { result: "success", value: i };
      }
      function qr(i) {
        return { result: "error", value: i };
      }
      function ns(i) {
        return i["property-type"] === "data-driven" || i["property-type"] === "cross-faded-data-driven";
      }
      function Go(i) {
        return !!i.expression && i.expression.parameters.indexOf("zoom") > -1;
      }
      function oo(i) {
        return !!i.expression && i.expression.interpolated;
      }
      function Pi(i) {
        return i instanceof Number ? "number" : i instanceof String ? "string" : i instanceof Boolean ? "boolean" : Array.isArray(i) ? "array" : i === null ? "null" : typeof i;
      }
      function xs(i) {
        return typeof i == "object" && i !== null && !Array.isArray(i);
      }
      function _n(i) {
        return i;
      }
      function Jr(i, e) {
        const n = e.type === "color", a = i.stops && typeof i.stops[0][0] == "object", u = a || !(a || i.property !== void 0), d = i.type || (oo(e) ? "exponential" : "interval");
        if (n || e.type === "padding") {
          const N = n ? Ri.parse : ln.parse;
          (i = ei({}, i)).stops && (i.stops = i.stops.map((D) => [D[0], N(D[1])])), i.default = N(i.default ? i.default : e.default);
        }
        if (i.colorSpace && (m = i.colorSpace) !== "rgb" && m !== "hcl" && m !== "lab") throw new Error(`Unknown color space: "${i.colorSpace}"`);
        var m;
        let S, I, C;
        if (d === "exponential") S = ka;
        else if (d === "interval") S = On;
        else if (d === "categorical") {
          S = bs, I = /* @__PURE__ */ Object.create(null);
          for (const N of i.stops) I[N[0]] = N[1];
          C = typeof i.stops[0][0];
        } else {
          if (d !== "identity") throw new Error(`Unknown function type "${d}"`);
          S = ws;
        }
        if (a) {
          const N = {}, D = [];
          for (let J = 0; J < i.stops.length; J++) {
            const rt = i.stops[J], dt = rt[0].zoom;
            N[dt] === void 0 && (N[dt] = { zoom: dt, type: i.type, property: i.property, default: i.default, stops: [] }, D.push(dt)), N[dt].stops.push([rt[0].value, rt[1]]);
          }
          const G = [];
          for (const J of D) G.push([N[J].zoom, Jr(N[J], e)]);
          const W = { name: "linear" };
          return { kind: "composite", interpolationType: W, interpolationFactor: He.interpolationFactor.bind(void 0, W), zoomStops: G.map((J) => J[0]), evaluate: ({ zoom: J }, rt) => ka({ stops: G, base: i.base }, e, J).evaluate(J, rt) };
        }
        if (u) {
          const N = d === "exponential" ? { name: "exponential", base: i.base !== void 0 ? i.base : 1 } : null;
          return { kind: "camera", interpolationType: N, interpolationFactor: He.interpolationFactor.bind(void 0, N), zoomStops: i.stops.map((D) => D[0]), evaluate: ({ zoom: D }) => S(i, e, D, I, C) };
        }
        return { kind: "source", evaluate(N, D) {
          const G = D && D.properties ? D.properties[i.property] : void 0;
          return G === void 0 ? In(i.default, e.default) : S(i, e, G, I, C);
        } };
      }
      function In(i, e, n) {
        return i !== void 0 ? i : e !== void 0 ? e : n !== void 0 ? n : void 0;
      }
      function bs(i, e, n, a, u) {
        return In(typeof n === u ? a[n] : void 0, i.default, e.default);
      }
      function On(i, e, n) {
        if (Pi(n) !== "number") return In(i.default, e.default);
        const a = i.stops.length;
        if (a === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[a - 1][0]) return i.stops[a - 1][1];
        const u = Za(i.stops.map((d) => d[0]), n);
        return i.stops[u][1];
      }
      function ka(i, e, n) {
        const a = i.base !== void 0 ? i.base : 1;
        if (Pi(n) !== "number") return In(i.default, e.default);
        const u = i.stops.length;
        if (u === 1 || n <= i.stops[0][0]) return i.stops[0][1];
        if (n >= i.stops[u - 1][0]) return i.stops[u - 1][1];
        const d = Za(i.stops.map((N) => N[0]), n), m = function(N, D, G, W) {
          const J = W - G, rt = N - G;
          return J === 0 ? 0 : D === 1 ? rt / J : (Math.pow(D, rt) - 1) / (Math.pow(D, J) - 1);
        }(n, a, i.stops[d][0], i.stops[d + 1][0]), S = i.stops[d][1], I = i.stops[d + 1][1], C = Or[e.type] || _n;
        return typeof S.evaluate == "function" ? { evaluate(...N) {
          const D = S.evaluate.apply(void 0, N), G = I.evaluate.apply(void 0, N);
          if (D !== void 0 && G !== void 0) return C(D, G, m, i.colorSpace);
        } } : C(S, I, m, i.colorSpace);
      }
      function ws(i, e, n) {
        switch (e.type) {
          case "color":
            n = Ri.parse(n);
            break;
          case "formatted":
            n = Hr.fromString(n.toString());
            break;
          case "resolvedImage":
            n = Yr.fromString(n.toString());
            break;
          case "padding":
            n = ln.parse(n);
            break;
          default:
            Pi(n) === e.type || e.type === "enum" && e.values[n] || (n = void 0);
        }
        return In(n, i.default, e.default);
      }
      jr.register(vs, { error: [{ kind: "error" }, [si], (i, [e]) => {
        throw new sr(e.evaluate(i));
      }], typeof: [si, [Ee], (i, [e]) => Z(fr(e.evaluate(i)))], "to-rgba": [V(le, 4), [zi], (i, [e]) => {
        const [n, a, u, d] = e.evaluate(i).rgb;
        return [255 * n, 255 * a, 255 * u, d];
      }], rgb: [zi, [le, le, le], Lr], rgba: [zi, [le, le, le, le], Lr], has: { type: Ce, overloads: [[[si], (i, [e]) => na(e.evaluate(i), i.properties())], [[si, Sr], (i, [e, n]) => na(e.evaluate(i), n.evaluate(i))]] }, get: { type: Ee, overloads: [[[si], (i, [e]) => sa(e.evaluate(i), i.properties())], [[si, Sr], (i, [e, n]) => sa(e.evaluate(i), n.evaluate(i))]] }, "feature-state": [Ee, [si], (i, [e]) => sa(e.evaluate(i), i.featureState || {})], properties: [Sr, [], (i) => i.properties()], "geometry-type": [si, [], (i) => i.geometryType()], id: [Ee, [], (i) => i.id()], zoom: [le, [], (i) => i.globals.zoom], "heatmap-density": [le, [], (i) => i.globals.heatmapDensity || 0], "line-progress": [le, [], (i) => i.globals.lineProgress || 0], accumulated: [Ee, [], (i) => i.globals.accumulated === void 0 ? null : i.globals.accumulated], "+": [le, Rn(le), (i, e) => {
        let n = 0;
        for (const a of e) n += a.evaluate(i);
        return n;
      }], "*": [le, Rn(le), (i, e) => {
        let n = 1;
        for (const a of e) n *= a.evaluate(i);
        return n;
      }], "-": { type: le, overloads: [[[le, le], (i, [e, n]) => e.evaluate(i) - n.evaluate(i)], [[le], (i, [e]) => -e.evaluate(i)]] }, "/": [le, [le, le], (i, [e, n]) => e.evaluate(i) / n.evaluate(i)], "%": [le, [le, le], (i, [e, n]) => e.evaluate(i) % n.evaluate(i)], ln2: [le, [], () => Math.LN2], pi: [le, [], () => Math.PI], e: [le, [], () => Math.E], "^": [le, [le, le], (i, [e, n]) => Math.pow(e.evaluate(i), n.evaluate(i))], sqrt: [le, [le], (i, [e]) => Math.sqrt(e.evaluate(i))], log10: [le, [le], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN10], ln: [le, [le], (i, [e]) => Math.log(e.evaluate(i))], log2: [le, [le], (i, [e]) => Math.log(e.evaluate(i)) / Math.LN2], sin: [le, [le], (i, [e]) => Math.sin(e.evaluate(i))], cos: [le, [le], (i, [e]) => Math.cos(e.evaluate(i))], tan: [le, [le], (i, [e]) => Math.tan(e.evaluate(i))], asin: [le, [le], (i, [e]) => Math.asin(e.evaluate(i))], acos: [le, [le], (i, [e]) => Math.acos(e.evaluate(i))], atan: [le, [le], (i, [e]) => Math.atan(e.evaluate(i))], min: [le, Rn(le), (i, e) => Math.min(...e.map((n) => n.evaluate(i)))], max: [le, Rn(le), (i, e) => Math.max(...e.map((n) => n.evaluate(i)))], abs: [le, [le], (i, [e]) => Math.abs(e.evaluate(i))], round: [le, [le], (i, [e]) => {
        const n = e.evaluate(i);
        return n < 0 ? -Math.round(-n) : Math.round(n);
      }], floor: [le, [le], (i, [e]) => Math.floor(e.evaluate(i))], ceil: [le, [le], (i, [e]) => Math.ceil(e.evaluate(i))], "filter-==": [Ce, [si, Ee], (i, [e, n]) => i.properties()[e.value] === n.value], "filter-id-==": [Ce, [Ee], (i, [e]) => i.id() === e.value], "filter-type-==": [Ce, [si], (i, [e]) => i.geometryType() === e.value], "filter-<": [Ce, [si, Ee], (i, [e, n]) => {
        const a = i.properties()[e.value], u = n.value;
        return typeof a == typeof u && a < u;
      }], "filter-id-<": [Ce, [Ee], (i, [e]) => {
        const n = i.id(), a = e.value;
        return typeof n == typeof a && n < a;
      }], "filter->": [Ce, [si, Ee], (i, [e, n]) => {
        const a = i.properties()[e.value], u = n.value;
        return typeof a == typeof u && a > u;
      }], "filter-id->": [Ce, [Ee], (i, [e]) => {
        const n = i.id(), a = e.value;
        return typeof n == typeof a && n > a;
      }], "filter-<=": [Ce, [si, Ee], (i, [e, n]) => {
        const a = i.properties()[e.value], u = n.value;
        return typeof a == typeof u && a <= u;
      }], "filter-id-<=": [Ce, [Ee], (i, [e]) => {
        const n = i.id(), a = e.value;
        return typeof n == typeof a && n <= a;
      }], "filter->=": [Ce, [si, Ee], (i, [e, n]) => {
        const a = i.properties()[e.value], u = n.value;
        return typeof a == typeof u && a >= u;
      }], "filter-id->=": [Ce, [Ee], (i, [e]) => {
        const n = i.id(), a = e.value;
        return typeof n == typeof a && n >= a;
      }], "filter-has": [Ce, [Ee], (i, [e]) => e.value in i.properties()], "filter-has-id": [Ce, [], (i) => i.id() !== null && i.id() !== void 0], "filter-type-in": [Ce, [V(si)], (i, [e]) => e.value.indexOf(i.geometryType()) >= 0], "filter-id-in": [Ce, [V(Ee)], (i, [e]) => e.value.indexOf(i.id()) >= 0], "filter-in-small": [Ce, [si, V(Ee)], (i, [e, n]) => n.value.indexOf(i.properties()[e.value]) >= 0], "filter-in-large": [Ce, [si, V(Ee)], (i, [e, n]) => function(a, u, d, m) {
        for (; d <= m; ) {
          const S = d + m >> 1;
          if (u[S] === a) return !0;
          u[S] > a ? m = S - 1 : d = S + 1;
        }
        return !1;
      }(i.properties()[e.value], n.value, 0, n.value.length - 1)], all: { type: Ce, overloads: [[[Ce, Ce], (i, [e, n]) => e.evaluate(i) && n.evaluate(i)], [Rn(Ce), (i, e) => {
        for (const n of e) if (!n.evaluate(i)) return !1;
        return !0;
      }]] }, any: { type: Ce, overloads: [[[Ce, Ce], (i, [e, n]) => e.evaluate(i) || n.evaluate(i)], [Rn(Ce), (i, e) => {
        for (const n of e) if (n.evaluate(i)) return !0;
        return !1;
      }]] }, "!": [Ce, [Ce], (i, [e]) => !e.evaluate(i)], "is-supported-script": [Ce, [si], (i, [e]) => {
        const n = i.globals && i.globals.isSupportedScript;
        return !n || n(e.evaluate(i));
      }], upcase: [si, [si], (i, [e]) => e.evaluate(i).toUpperCase()], downcase: [si, [si], (i, [e]) => e.evaluate(i).toLowerCase()], concat: [si, Rn(Ee), (i, e) => e.map((n) => Ji(n.evaluate(i))).join("")], "resolved-locale": [si, [Xr], (i, [e]) => e.evaluate(i).resolvedLocale()] });
      class ar {
        constructor(e, n) {
          var a;
          this.expression = e, this._warningHistory = {}, this._evaluator = new Rr(), this._defaultValue = n ? (a = n).type === "color" && xs(a.default) ? new Ri(0, 0, 0, 0) : a.type === "color" ? Ri.parse(a.default) || null : a.type === "padding" ? ln.parse(a.default) || null : a.type === "variableAnchorOffsetCollection" ? mn.parse(a.default) || null : a.default === void 0 ? null : a.default : null, this._enumValues = n && n.type === "enum" ? n.values : null;
        }
        evaluateWithoutErrorHandling(e, n, a, u, d, m) {
          return this._evaluator.globals = e, this._evaluator.feature = n, this._evaluator.featureState = a, this._evaluator.canonical = u, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = m, this.expression.evaluate(this._evaluator);
        }
        evaluate(e, n, a, u, d, m) {
          this._evaluator.globals = e, this._evaluator.feature = n || null, this._evaluator.featureState = a || null, this._evaluator.canonical = u, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = m || null;
          try {
            const S = this.expression.evaluate(this._evaluator);
            if (S == null || typeof S == "number" && S != S) return this._defaultValue;
            if (this._enumValues && !(S in this._enumValues)) throw new sr(`Expected value to be one of ${Object.keys(this._enumValues).map((I) => JSON.stringify(I)).join(", ")}, but found ${JSON.stringify(S)} instead.`);
            return S;
          } catch (S) {
            return this._warningHistory[S.message] || (this._warningHistory[S.message] = !0, typeof console < "u" && console.warn(S.message)), this._defaultValue;
          }
        }
      }
      function oa(i) {
        return Array.isArray(i) && i.length > 0 && typeof i[0] == "string" && i[0] in vs;
      }
      function Pr(i, e) {
        const n = new Jn(vs, Rs, [], e ? function(u) {
          const d = { color: zi, string: si, number: le, enum: si, boolean: Ce, formatted: Vi, padding: Mr, resolvedImage: Er, variableAnchorOffsetCollection: ut };
          return u.type === "array" ? V(d[u.value] || Ee, u.length) : d[u.type];
        }(e) : void 0), a = n.parse(i, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return a ? Ia(new ar(a, e)) : qr(n.errors);
      }
      class Ur {
        constructor(e, n) {
          this.kind = e, this._styleExpression = n, this.isStateDependent = e !== "constant" && !aa(n.expression);
        }
        evaluateWithoutErrorHandling(e, n, a, u, d, m) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, n, a, u, d, m);
        }
        evaluate(e, n, a, u, d, m) {
          return this._styleExpression.evaluate(e, n, a, u, d, m);
        }
      }
      class ss {
        constructor(e, n, a, u) {
          this.kind = e, this.zoomStops = a, this._styleExpression = n, this.isStateDependent = e !== "camera" && !aa(n.expression), this.interpolationType = u;
        }
        evaluateWithoutErrorHandling(e, n, a, u, d, m) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, n, a, u, d, m);
        }
        evaluate(e, n, a, u, d, m) {
          return this._styleExpression.evaluate(e, n, a, u, d, m);
        }
        interpolationFactor(e, n, a) {
          return this.interpolationType ? He.interpolationFactor(this.interpolationType, e, n, a) : 0;
        }
      }
      function lo(i, e) {
        const n = Pr(i, e);
        if (n.result === "error") return n;
        const a = n.value.expression, u = zr(a);
        if (!u && !ns(e)) return qr([new oi("", "data expressions not supported")]);
        const d = Os(a, ["zoom"]);
        if (!d && !Go(e)) return qr([new oi("", "zoom expressions not supported")]);
        const m = as(a);
        return m || d ? m instanceof oi ? qr([m]) : m instanceof He && !oo(e) ? qr([new oi("", '"interpolate" expressions cannot be used with this property')]) : Ia(m ? new ss(u ? "camera" : "composite", n.value, m.labels, m instanceof He ? m.interpolation : void 0) : new Ur(u ? "constant" : "source", n.value)) : qr([new oi("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class Ss {
        constructor(e, n) {
          this._parameters = e, this._specification = n, ei(this, Jr(this._parameters, this._specification));
        }
        static deserialize(e) {
          return new Ss(e._parameters, e._specification);
        }
        static serialize(e) {
          return { _parameters: e._parameters, _specification: e._specification };
        }
      }
      function as(i) {
        let e = null;
        if (i instanceof Qn) e = as(i.result);
        else if (i instanceof Ha) {
          for (const n of i.args) if (e = as(n), e) break;
        } else (i instanceof ta || i instanceof He) && i.input instanceof jr && i.input.name === "zoom" && (e = i);
        return e instanceof oi || i.eachChild((n) => {
          const a = as(n);
          a instanceof oi ? e = a : !e && a ? e = new oi("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && a && e !== a && (e = new oi("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e;
      }
      function As(i) {
        if (i === !0 || i === !1) return !0;
        if (!Array.isArray(i) || i.length === 0) return !1;
        switch (i[0]) {
          case "has":
            return i.length >= 2 && i[1] !== "$id" && i[1] !== "$type";
          case "in":
            return i.length >= 3 && (typeof i[1] != "string" || Array.isArray(i[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return i.length !== 3 || Array.isArray(i[1]) || Array.isArray(i[2]);
          case "any":
          case "all":
            for (const e of i.slice(1)) if (!As(e) && typeof e != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const os = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function js(i) {
        if (i == null) return { filter: () => !0, needGeometry: !1 };
        As(i) || (i = ls(i));
        const e = Pr(i, os);
        if (e.result === "error") throw new Error(e.value.map((n) => `${n.key}: ${n.message}`).join(", "));
        return { filter: (n, a, u) => e.value.evaluate(n, a, {}, u), needGeometry: la(i) };
      }
      function co(i, e) {
        return i < e ? -1 : i > e ? 1 : 0;
      }
      function la(i) {
        if (!Array.isArray(i)) return !1;
        if (i[0] === "within" || i[0] === "distance") return !0;
        for (let e = 1; e < i.length; e++) if (la(i[e])) return !0;
        return !1;
      }
      function ls(i) {
        if (!i) return !0;
        const e = i[0];
        return i.length <= 1 ? e !== "any" : e === "==" ? Ta(i[1], i[2], "==") : e === "!=" ? Ii(Ta(i[1], i[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? Ta(i[1], i[2], e) : e === "any" ? (n = i.slice(1), ["any"].concat(n.map(ls))) : e === "all" ? ["all"].concat(i.slice(1).map(ls)) : e === "none" ? ["all"].concat(i.slice(1).map(ls).map(Ii)) : e === "in" ? Qr(i[1], i.slice(2)) : e === "!in" ? Ii(Qr(i[1], i.slice(2))) : e === "has" ? tn(i[1]) : e !== "!has" || Ii(tn(i[1]));
        var n;
      }
      function Ta(i, e, n) {
        switch (i) {
          case "$type":
            return [`filter-type-${n}`, e];
          case "$id":
            return [`filter-id-${n}`, e];
          default:
            return [`filter-${n}`, i, e];
        }
      }
      function Qr(i, e) {
        if (e.length === 0) return !1;
        switch (i) {
          case "$type":
            return ["filter-type-in", ["literal", e]];
          case "$id":
            return ["filter-id-in", ["literal", e]];
          default:
            return e.length > 200 && !e.some((n) => typeof n != typeof e[0]) ? ["filter-in-large", i, ["literal", e.sort(co)]] : ["filter-in-small", i, ["literal", e]];
        }
      }
      function tn(i) {
        switch (i) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", i];
        }
      }
      function Ii(i) {
        return ["!", i];
      }
      function Oi(i) {
        const e = typeof i;
        if (e === "number" || e === "boolean" || e === "string" || i == null) return JSON.stringify(i);
        if (Array.isArray(i)) {
          let u = "[";
          for (const d of i) u += `${Oi(d)},`;
          return `${u}]`;
        }
        const n = Object.keys(i).sort();
        let a = "{";
        for (let u = 0; u < n.length; u++) a += `${JSON.stringify(n[u])}:${Oi(i[n[u]])},`;
        return `${a}}`;
      }
      function gr(i) {
        let e = "";
        for (const n of ui) e += `/${Oi(i[n])}`;
        return e;
      }
      function Ir(i) {
        const e = i.value;
        return e ? [new oe(i.key, e, "constants have been deprecated as of v8")] : [];
      }
      function $i(i) {
        return i instanceof Number || i instanceof String || i instanceof Boolean ? i.valueOf() : i;
      }
      function un(i) {
        if (Array.isArray(i)) return i.map(un);
        if (i instanceof Object && !(i instanceof Number || i instanceof String || i instanceof Boolean)) {
          const e = {};
          for (const n in i) e[n] = un(i[n]);
          return e;
        }
        return $i(i);
      }
      function Nr(i) {
        const e = i.key, n = i.value, a = i.valueSpec || {}, u = i.objectElementValidators || {}, d = i.style, m = i.styleSpec, S = i.validateSpec;
        let I = [];
        const C = Pi(n);
        if (C !== "object") return [new oe(e, n, `object expected, ${C} found`)];
        for (const N in n) {
          const D = N.split(".")[0], G = a[D] || a["*"];
          let W;
          if (u[D]) W = u[D];
          else if (a[D]) W = S;
          else if (u["*"]) W = u["*"];
          else {
            if (!a["*"]) {
              I.push(new oe(e, n[N], `unknown property "${N}"`));
              continue;
            }
            W = S;
          }
          I = I.concat(W({ key: (e && `${e}.`) + N, value: n[N], valueSpec: G, style: d, styleSpec: m, object: n, objectKey: N, validateSpec: S }, n));
        }
        for (const N in a) u[N] || a[N].required && a[N].default === void 0 && n[N] === void 0 && I.push(new oe(e, n, `missing required property "${N}"`));
        return I;
      }
      function ca(i) {
        const e = i.value, n = i.valueSpec, a = i.style, u = i.styleSpec, d = i.key, m = i.arrayElementValidator || i.validateSpec;
        if (Pi(e) !== "array") return [new oe(d, e, `array expected, ${Pi(e)} found`)];
        if (n.length && e.length !== n.length) return [new oe(d, e, `array length ${n.length} expected, length ${e.length} found`)];
        if (n["min-length"] && e.length < n["min-length"]) return [new oe(d, e, `array length at least ${n["min-length"]} expected, length ${e.length} found`)];
        let S = { type: n.value, values: n.values };
        u.$version < 7 && (S.function = n.function), Pi(n.value) === "object" && (S = n.value);
        let I = [];
        for (let C = 0; C < e.length; C++) I = I.concat(m({ array: e, arrayIndex: C, value: e[C], valueSpec: S, validateSpec: i.validateSpec, style: a, styleSpec: u, key: `${d}[${C}]` }));
        return I;
      }
      function $o(i) {
        const e = i.key, n = i.value, a = i.valueSpec;
        let u = Pi(n);
        return u === "number" && n != n && (u = "NaN"), u !== "number" ? [new oe(e, n, `number expected, ${u} found`)] : "minimum" in a && n < a.minimum ? [new oe(e, n, `${n} is less than the minimum value ${a.minimum}`)] : "maximum" in a && n > a.maximum ? [new oe(e, n, `${n} is greater than the maximum value ${a.maximum}`)] : [];
      }
      function La(i) {
        const e = i.valueSpec, n = $i(i.value.type);
        let a, u, d, m = {};
        const S = n !== "categorical" && i.value.property === void 0, I = !S, C = Pi(i.value.stops) === "array" && Pi(i.value.stops[0]) === "array" && Pi(i.value.stops[0][0]) === "object", N = Nr({ key: i.key, value: i.value, valueSpec: i.styleSpec.function, validateSpec: i.validateSpec, style: i.style, styleSpec: i.styleSpec, objectElementValidators: { stops: function(W) {
          if (n === "identity") return [new oe(W.key, W.value, 'identity function may not have a "stops" property')];
          let J = [];
          const rt = W.value;
          return J = J.concat(ca({ key: W.key, value: rt, valueSpec: W.valueSpec, validateSpec: W.validateSpec, style: W.style, styleSpec: W.styleSpec, arrayElementValidator: D })), Pi(rt) === "array" && rt.length === 0 && J.push(new oe(W.key, rt, "array must have at least one stop")), J;
        }, default: function(W) {
          return W.validateSpec({ key: W.key, value: W.value, valueSpec: e, validateSpec: W.validateSpec, style: W.style, styleSpec: W.styleSpec });
        } } });
        return n === "identity" && S && N.push(new oe(i.key, i.value, 'missing required property "property"')), n === "identity" || i.value.stops || N.push(new oe(i.key, i.value, 'missing required property "stops"')), n === "exponential" && i.valueSpec.expression && !oo(i.valueSpec) && N.push(new oe(i.key, i.value, "exponential functions not supported")), i.styleSpec.$version >= 8 && (I && !ns(i.valueSpec) ? N.push(new oe(i.key, i.value, "property functions not supported")) : S && !Go(i.valueSpec) && N.push(new oe(i.key, i.value, "zoom functions not supported"))), n !== "categorical" && !C || i.value.property !== void 0 || N.push(new oe(i.key, i.value, '"property" property is required')), N;
        function D(W) {
          let J = [];
          const rt = W.value, dt = W.key;
          if (Pi(rt) !== "array") return [new oe(dt, rt, `array expected, ${Pi(rt)} found`)];
          if (rt.length !== 2) return [new oe(dt, rt, `array length 2 expected, length ${rt.length} found`)];
          if (C) {
            if (Pi(rt[0]) !== "object") return [new oe(dt, rt, `object expected, ${Pi(rt[0])} found`)];
            if (rt[0].zoom === void 0) return [new oe(dt, rt, "object stop key must have zoom")];
            if (rt[0].value === void 0) return [new oe(dt, rt, "object stop key must have value")];
            if (d && d > $i(rt[0].zoom)) return [new oe(dt, rt[0].zoom, "stop zoom values must appear in ascending order")];
            $i(rt[0].zoom) !== d && (d = $i(rt[0].zoom), u = void 0, m = {}), J = J.concat(Nr({ key: `${dt}[0]`, value: rt[0], valueSpec: { zoom: {} }, validateSpec: W.validateSpec, style: W.style, styleSpec: W.styleSpec, objectElementValidators: { zoom: $o, value: G } }));
          } else J = J.concat(G({ key: `${dt}[0]`, value: rt[0], valueSpec: {}, validateSpec: W.validateSpec, style: W.style, styleSpec: W.styleSpec }, rt));
          return oa(un(rt[1])) ? J.concat([new oe(`${dt}[1]`, rt[1], "expressions are not allowed in function stops.")]) : J.concat(W.validateSpec({ key: `${dt}[1]`, value: rt[1], valueSpec: e, validateSpec: W.validateSpec, style: W.style, styleSpec: W.styleSpec }));
        }
        function G(W, J) {
          const rt = Pi(W.value), dt = $i(W.value), vt = W.value !== null ? W.value : J;
          if (a) {
            if (rt !== a) return [new oe(W.key, vt, `${rt} stop domain type must match previous stop domain type ${a}`)];
          } else a = rt;
          if (rt !== "number" && rt !== "string" && rt !== "boolean") return [new oe(W.key, vt, "stop domain value must be a number, string, or boolean")];
          if (rt !== "number" && n !== "categorical") {
            let Dt = `number expected, ${rt} found`;
            return ns(e) && n === void 0 && (Dt += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new oe(W.key, vt, Dt)];
          }
          return n !== "categorical" || rt !== "number" || isFinite(dt) && Math.floor(dt) === dt ? n !== "categorical" && rt === "number" && u !== void 0 && dt < u ? [new oe(W.key, vt, "stop domain values must appear in ascending order")] : (u = dt, n === "categorical" && dt in m ? [new oe(W.key, vt, "stop domain values must be unique")] : (m[dt] = !0, [])) : [new oe(W.key, vt, `integer expected, found ${dt}`)];
        }
      }
      function Dr(i) {
        const e = (i.expressionContext === "property" ? lo : Pr)(un(i.value), i.valueSpec);
        if (e.result === "error") return e.value.map((a) => new oe(`${i.key}${a.key}`, i.value, a.message));
        const n = e.value.expression || e.value._styleExpression.expression;
        if (i.expressionContext === "property" && i.propertyKey === "text-font" && !n.outputDefined()) return [new oe(i.key, i.value, `Invalid data expression for "${i.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (i.expressionContext === "property" && i.propertyType === "layout" && !aa(n)) return [new oe(i.key, i.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (i.expressionContext === "filter" && !aa(n)) return [new oe(i.key, i.value, '"feature-state" data expressions are not supported with filters.')];
        if (i.expressionContext && i.expressionContext.indexOf("cluster") === 0) {
          if (!Os(n, ["zoom", "feature-state"])) return [new oe(i.key, i.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (i.expressionContext === "cluster-initial" && !zr(n)) return [new oe(i.key, i.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function kr(i) {
        const e = i.key, n = i.value, a = i.valueSpec, u = [];
        return Array.isArray(a.values) ? a.values.indexOf($i(n)) === -1 && u.push(new oe(e, n, `expected one of [${a.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(a.values).indexOf($i(n)) === -1 && u.push(new oe(e, n, `expected one of [${Object.keys(a.values).join(", ")}], ${JSON.stringify(n)} found`)), u;
      }
      function ho(i) {
        return As(un(i.value)) ? Dr(ei({}, i, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Ca(i);
      }
      function Ca(i) {
        const e = i.value, n = i.key;
        if (Pi(e) !== "array") return [new oe(n, e, `array expected, ${Pi(e)} found`)];
        const a = i.styleSpec;
        let u, d = [];
        if (e.length < 1) return [new oe(n, e, "filter array must have at least 1 element")];
        switch (d = d.concat(kr({ key: `${n}[0]`, value: e[0], valueSpec: a.filter_operator, style: i.style, styleSpec: i.styleSpec })), $i(e[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e.length >= 2 && $i(e[1]) === "$type" && d.push(new oe(n, e, `"$type" cannot be use with operator "${e[0]}"`));
          case "==":
          case "!=":
            e.length !== 3 && d.push(new oe(n, e, `filter array for operator "${e[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e.length >= 2 && (u = Pi(e[1]), u !== "string" && d.push(new oe(`${n}[1]`, e[1], `string expected, ${u} found`)));
            for (let m = 2; m < e.length; m++) u = Pi(e[m]), $i(e[1]) === "$type" ? d = d.concat(kr({ key: `${n}[${m}]`, value: e[m], valueSpec: a.geometry_type, style: i.style, styleSpec: i.styleSpec })) : u !== "string" && u !== "number" && u !== "boolean" && d.push(new oe(`${n}[${m}]`, e[m], `string, number, or boolean expected, ${u} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let m = 1; m < e.length; m++) d = d.concat(Ca({ key: `${n}[${m}]`, value: e[m], style: i.style, styleSpec: i.styleSpec }));
            break;
          case "has":
          case "!has":
            u = Pi(e[1]), e.length !== 2 ? d.push(new oe(n, e, `filter array for "${e[0]}" operator must have 2 elements`)) : u !== "string" && d.push(new oe(`${n}[1]`, e[1], `string expected, ${u} found`));
        }
        return d;
      }
      function fl(i, e) {
        const n = i.key, a = i.validateSpec, u = i.style, d = i.styleSpec, m = i.value, S = i.objectKey, I = d[`${e}_${i.layerType}`];
        if (!I) return [];
        const C = S.match(/^(.*)-transition$/);
        if (e === "paint" && C && I[C[1]] && I[C[1]].transition) return a({ key: n, value: m, valueSpec: d.transition, style: u, styleSpec: d });
        const N = i.valueSpec || I[S];
        if (!N) return [new oe(n, m, `unknown property "${S}"`)];
        let D;
        if (Pi(m) === "string" && ns(N) && !N.tokens && (D = /^{([^}]+)}$/.exec(m))) return [new oe(n, m, `"${S}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(D[1])} }\`.`)];
        const G = [];
        return i.layerType === "symbol" && (S === "text-field" && u && !u.glyphs && G.push(new oe(n, m, 'use of "text-field" requires a style "glyphs" property')), S === "text-font" && xs(un(m)) && $i(m.type) === "identity" && G.push(new oe(n, m, '"text-font" does not support identity functions'))), G.concat(a({ key: i.key, value: m, valueSpec: N, style: u, styleSpec: d, expressionContext: "property", propertyType: e, propertyKey: S }));
      }
      function Ma(i) {
        return fl(i, "paint");
      }
      function uo(i) {
        return fl(i, "layout");
      }
      function Zo(i) {
        let e = [];
        const n = i.value, a = i.key, u = i.style, d = i.styleSpec;
        n.type || n.ref || e.push(new oe(a, n, 'either "type" or "ref" is required'));
        let m = $i(n.type);
        const S = $i(n.ref);
        if (n.id) {
          const I = $i(n.id);
          for (let C = 0; C < i.arrayIndex; C++) {
            const N = u.layers[C];
            $i(N.id) === I && e.push(new oe(a, n.id, `duplicate layer id "${n.id}", previously used at line ${N.id.__line__}`));
          }
        }
        if ("ref" in n) {
          let I;
          ["type", "source", "source-layer", "filter", "layout"].forEach((C) => {
            C in n && e.push(new oe(a, n[C], `"${C}" is prohibited for ref layers`));
          }), u.layers.forEach((C) => {
            $i(C.id) === S && (I = C);
          }), I ? I.ref ? e.push(new oe(a, n.ref, "ref cannot reference another ref layer")) : m = $i(I.type) : e.push(new oe(a, n.ref, `ref layer "${S}" not found`));
        } else if (m !== "background") if (n.source) {
          const I = u.sources && u.sources[n.source], C = I && $i(I.type);
          I ? C === "vector" && m === "raster" ? e.push(new oe(a, n.source, `layer "${n.id}" requires a raster source`)) : C !== "raster-dem" && m === "hillshade" ? e.push(new oe(a, n.source, `layer "${n.id}" requires a raster-dem source`)) : C === "raster" && m !== "raster" ? e.push(new oe(a, n.source, `layer "${n.id}" requires a vector source`)) : C !== "vector" || n["source-layer"] ? C === "raster-dem" && m !== "hillshade" ? e.push(new oe(a, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : m !== "line" || !n.paint || !n.paint["line-gradient"] || C === "geojson" && I.lineMetrics || e.push(new oe(a, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new oe(a, n, `layer "${n.id}" must specify a "source-layer"`)) : e.push(new oe(a, n.source, `source "${n.source}" not found`));
        } else e.push(new oe(a, n, 'missing required property "source"'));
        return e = e.concat(Nr({ key: a, value: n, valueSpec: d.layer, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, objectElementValidators: { "*": () => [], type: () => i.validateSpec({ key: `${a}.type`, value: n.type, valueSpec: d.layer.type, style: i.style, styleSpec: i.styleSpec, validateSpec: i.validateSpec, object: n, objectKey: "type" }), filter: ho, layout: (I) => Nr({ layer: n, key: I.key, value: I.value, style: I.style, styleSpec: I.styleSpec, validateSpec: I.validateSpec, objectElementValidators: { "*": (C) => uo(ei({ layerType: m }, C)) } }), paint: (I) => Nr({ layer: n, key: I.key, value: I.value, style: I.style, styleSpec: I.styleSpec, validateSpec: I.validateSpec, objectElementValidators: { "*": (C) => Ma(ei({ layerType: m }, C)) } }) } })), e;
      }
      function ha(i) {
        const e = i.value, n = i.key, a = Pi(e);
        return a !== "string" ? [new oe(n, e, `string expected, ${a} found`)] : [];
      }
      const po = { promoteId: function({ key: i, value: e }) {
        if (Pi(e) === "string") return ha({ key: i, value: e });
        {
          const n = [];
          for (const a in e) n.push(...ha({ key: `${i}.${a}`, value: e[a] }));
          return n;
        }
      } };
      function Ea(i) {
        const e = i.value, n = i.key, a = i.styleSpec, u = i.style, d = i.validateSpec;
        if (!e.type) return [new oe(n, e, '"type" is required')];
        const m = $i(e.type);
        let S;
        switch (m) {
          case "vector":
          case "raster":
            return S = Nr({ key: n, value: e, valueSpec: a[`source_${m.replace("-", "_")}`], style: i.style, styleSpec: a, objectElementValidators: po, validateSpec: d }), S;
          case "raster-dem":
            return S = function(I) {
              var C;
              const N = (C = I.sourceName) !== null && C !== void 0 ? C : "", D = I.value, G = I.styleSpec, W = G.source_raster_dem, J = I.style;
              let rt = [];
              const dt = Pi(D);
              if (D === void 0) return rt;
              if (dt !== "object") return rt.push(new oe("source_raster_dem", D, `object expected, ${dt} found`)), rt;
              const vt = $i(D.encoding) === "custom", Dt = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Lt = I.value.encoding ? `"${I.value.encoding}"` : "Default";
              for (const Nt in D) !vt && Dt.includes(Nt) ? rt.push(new oe(Nt, D[Nt], `In "${N}": "${Nt}" is only valid when "encoding" is set to "custom". ${Lt} encoding found`)) : W[Nt] ? rt = rt.concat(I.validateSpec({ key: Nt, value: D[Nt], valueSpec: W[Nt], validateSpec: I.validateSpec, style: J, styleSpec: G })) : rt.push(new oe(Nt, D[Nt], `unknown property "${Nt}"`));
              return rt;
            }({ sourceName: n, value: e, style: i.style, styleSpec: a, validateSpec: d }), S;
          case "geojson":
            if (S = Nr({ key: n, value: e, valueSpec: a.source_geojson, style: u, styleSpec: a, validateSpec: d, objectElementValidators: po }), e.cluster) for (const I in e.clusterProperties) {
              const [C, N] = e.clusterProperties[I], D = typeof C == "string" ? [C, ["accumulated"], ["get", I]] : C;
              S.push(...Dr({ key: `${n}.${I}.map`, value: N, validateSpec: d, expressionContext: "cluster-map" })), S.push(...Dr({ key: `${n}.${I}.reduce`, value: D, validateSpec: d, expressionContext: "cluster-reduce" }));
            }
            return S;
          case "video":
            return Nr({ key: n, value: e, valueSpec: a.source_video, style: u, validateSpec: d, styleSpec: a });
          case "image":
            return Nr({ key: n, value: e, valueSpec: a.source_image, style: u, validateSpec: d, styleSpec: a });
          case "canvas":
            return [new oe(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return kr({ key: `${n}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: u, validateSpec: d, styleSpec: a });
        }
      }
      function fo(i) {
        const e = i.value, n = i.styleSpec, a = n.light, u = i.style;
        let d = [];
        const m = Pi(e);
        if (e === void 0) return d;
        if (m !== "object") return d = d.concat([new oe("light", e, `object expected, ${m} found`)]), d;
        for (const S in e) {
          const I = S.match(/^(.*)-transition$/);
          d = d.concat(I && a[I[1]] && a[I[1]].transition ? i.validateSpec({ key: S, value: e[S], valueSpec: n.transition, validateSpec: i.validateSpec, style: u, styleSpec: n }) : a[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: a[S], validateSpec: i.validateSpec, style: u, styleSpec: n }) : [new oe(S, e[S], `unknown property "${S}"`)]);
        }
        return d;
      }
      function Wo(i) {
        const e = i.value, n = i.styleSpec, a = n.sky, u = i.style, d = Pi(e);
        if (e === void 0) return [];
        if (d !== "object") return [new oe("sky", e, `object expected, ${d} found`)];
        let m = [];
        for (const S in e) m = m.concat(a[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: a[S], style: u, styleSpec: n }) : [new oe(S, e[S], `unknown property "${S}"`)]);
        return m;
      }
      function Dl(i) {
        const e = i.value, n = i.styleSpec, a = n.terrain, u = i.style;
        let d = [];
        const m = Pi(e);
        if (e === void 0) return d;
        if (m !== "object") return d = d.concat([new oe("terrain", e, `object expected, ${m} found`)]), d;
        for (const S in e) d = d.concat(a[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: a[S], validateSpec: i.validateSpec, style: u, styleSpec: n }) : [new oe(S, e[S], `unknown property "${S}"`)]);
        return d;
      }
      function Fl(i) {
        let e = [];
        const n = i.value, a = i.key;
        if (Array.isArray(n)) {
          const u = [], d = [];
          for (const m in n) n[m].id && u.includes(n[m].id) && e.push(new oe(a, n, `all the sprites' ids must be unique, but ${n[m].id} is duplicated`)), u.push(n[m].id), n[m].url && d.includes(n[m].url) && e.push(new oe(a, n, `all the sprites' URLs must be unique, but ${n[m].url} is duplicated`)), d.push(n[m].url), e = e.concat(Nr({ key: `${a}[${m}]`, value: n[m], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: i.validateSpec }));
          return e;
        }
        return ha({ key: a, value: n });
      }
      const Xo = { "*": () => [], array: ca, boolean: function(i) {
        const e = i.value, n = i.key, a = Pi(e);
        return a !== "boolean" ? [new oe(n, e, `boolean expected, ${a} found`)] : [];
      }, number: $o, color: function(i) {
        const e = i.key, n = i.value, a = Pi(n);
        return a !== "string" ? [new oe(e, n, `color expected, ${a} found`)] : Ri.parse(String(n)) ? [] : [new oe(e, n, `color expected, "${n}" found`)];
      }, constants: Ir, enum: kr, filter: ho, function: La, layer: Zo, object: Nr, source: Ea, light: fo, sky: Wo, terrain: Dl, projection: function(i) {
        const e = i.value, n = i.styleSpec, a = n.projection, u = i.style, d = Pi(e);
        if (e === void 0) return [];
        if (d !== "object") return [new oe("projection", e, `object expected, ${d} found`)];
        let m = [];
        for (const S in e) m = m.concat(a[S] ? i.validateSpec({ key: S, value: e[S], valueSpec: a[S], style: u, styleSpec: n }) : [new oe(S, e[S], `unknown property "${S}"`)]);
        return m;
      }, string: ha, formatted: function(i) {
        return ha(i).length === 0 ? [] : Dr(i);
      }, resolvedImage: function(i) {
        return ha(i).length === 0 ? [] : Dr(i);
      }, padding: function(i) {
        const e = i.key, n = i.value;
        if (Pi(n) === "array") {
          if (n.length < 1 || n.length > 4) return [new oe(e, n, `padding requires 1 to 4 values; ${n.length} values found`)];
          const a = { type: "number" };
          let u = [];
          for (let d = 0; d < n.length; d++) u = u.concat(i.validateSpec({ key: `${e}[${d}]`, value: n[d], validateSpec: i.validateSpec, valueSpec: a }));
          return u;
        }
        return $o({ key: e, value: n, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(i) {
        const e = i.key, n = i.value, a = Pi(n), u = i.styleSpec;
        if (a !== "array" || n.length < 1 || n.length % 2 != 0) return [new oe(e, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let d = [];
        for (let m = 0; m < n.length; m += 2) d = d.concat(kr({ key: `${e}[${m}]`, value: n[m], valueSpec: u.layout_symbol["text-anchor"] })), d = d.concat(ca({ key: `${e}[${m + 1}]`, value: n[m + 1], valueSpec: { length: 2, value: "number" }, validateSpec: i.validateSpec, style: i.style, styleSpec: u }));
        return d;
      }, sprite: Fl };
      function mo(i) {
        const e = i.value, n = i.valueSpec, a = i.styleSpec;
        return i.validateSpec = mo, n.expression && xs($i(e)) ? La(i) : n.expression && oa(un(e)) ? Dr(i) : n.type && Xo[n.type] ? Xo[n.type](i) : Nr(ei({}, i, { valueSpec: n.type ? a[n.type] : n }));
      }
      function nc(i) {
        const e = i.value, n = i.key, a = ha(i);
        return a.length || (e.indexOf("{fontstack}") === -1 && a.push(new oe(n, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && a.push(new oe(n, e, '"glyphs" url must include a "{range}" token'))), a;
      }
      function jn(i, e = Y) {
        let n = [];
        return n = n.concat(mo({ key: "", value: i, valueSpec: e.$root, styleSpec: e, style: i, validateSpec: mo, objectElementValidators: { glyphs: nc, "*": () => [] } })), i.constants && (n = n.concat(Ir({ key: "constants", value: i.constants, style: i, styleSpec: e, validateSpec: mo }))), Bl(n);
      }
      function Ps(i) {
        return function(e) {
          return i({ ...e, validateSpec: mo });
        };
      }
      function Bl(i) {
        return [].concat(i).sort((e, n) => e.line - n.line);
      }
      function kn(i) {
        return function(...e) {
          return Bl(i.apply(this, e));
        };
      }
      jn.source = kn(Ps(Ea)), jn.sprite = kn(Ps(Fl)), jn.glyphs = kn(Ps(nc)), jn.light = kn(Ps(fo)), jn.sky = kn(Ps(Wo)), jn.terrain = kn(Ps(Dl)), jn.layer = kn(Ps(Zo)), jn.filter = kn(Ps(ho)), jn.paintProperty = kn(Ps(Ma)), jn.layoutProperty = kn(Ps(uo));
      const qs = jn, Ho = qs.light, Dc = qs.sky, sc = qs.paintProperty, Rl = qs.layoutProperty;
      function Ol(i, e) {
        let n = !1;
        if (e && e.length) for (const a of e) i.fire(new ti(new Error(a.message))), n = !0;
        return n;
      }
      class go {
        constructor(e, n, a) {
          const u = this.cells = [];
          if (e instanceof ArrayBuffer) {
            this.arrayBuffer = e;
            const m = new Int32Array(this.arrayBuffer);
            e = m[0], this.d = (n = m[1]) + 2 * (a = m[2]);
            for (let I = 0; I < this.d * this.d; I++) {
              const C = m[3 + I], N = m[3 + I + 1];
              u.push(C === N ? null : m.subarray(C, N));
            }
            const S = m[3 + u.length + 1];
            this.keys = m.subarray(m[3 + u.length], S), this.bboxes = m.subarray(S), this.insert = this._insertReadonly;
          } else {
            this.d = n + 2 * a;
            for (let m = 0; m < this.d * this.d; m++) u.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = n, this.extent = e, this.padding = a, this.scale = n / e, this.uid = 0;
          const d = a / n * e;
          this.min = -d, this.max = e + d;
        }
        insert(e, n, a, u, d) {
          this._forEachCell(n, a, u, d, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(n), this.bboxes.push(a), this.bboxes.push(u), this.bboxes.push(d);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(e, n, a, u, d, m) {
          this.cells[d].push(m);
        }
        query(e, n, a, u, d) {
          const m = this.min, S = this.max;
          if (e <= m && n <= m && S <= a && S <= u && !d) return Array.prototype.slice.call(this.keys);
          {
            const I = [];
            return this._forEachCell(e, n, a, u, this._queryCell, I, {}, d), I;
          }
        }
        _queryCell(e, n, a, u, d, m, S, I) {
          const C = this.cells[d];
          if (C !== null) {
            const N = this.keys, D = this.bboxes;
            for (let G = 0; G < C.length; G++) {
              const W = C[G];
              if (S[W] === void 0) {
                const J = 4 * W;
                (I ? I(D[J + 0], D[J + 1], D[J + 2], D[J + 3]) : e <= D[J + 2] && n <= D[J + 3] && a >= D[J + 0] && u >= D[J + 1]) ? (S[W] = !0, m.push(N[W])) : S[W] = !1;
              }
            }
          }
        }
        _forEachCell(e, n, a, u, d, m, S, I) {
          const C = this._convertToCellCoord(e), N = this._convertToCellCoord(n), D = this._convertToCellCoord(a), G = this._convertToCellCoord(u);
          for (let W = C; W <= D; W++) for (let J = N; J <= G; J++) {
            const rt = this.d * J + W;
            if ((!I || I(this._convertFromCellCoord(W), this._convertFromCellCoord(J), this._convertFromCellCoord(W + 1), this._convertFromCellCoord(J + 1))) && d.call(this, e, n, a, u, rt, m, S, I)) return;
          }
        }
        _convertFromCellCoord(e) {
          return (e - this.padding) / this.scale;
        }
        _convertToCellCoord(e) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const e = this.cells, n = 3 + this.cells.length + 1 + 1;
          let a = 0;
          for (let m = 0; m < this.cells.length; m++) a += this.cells[m].length;
          const u = new Int32Array(n + a + this.keys.length + this.bboxes.length);
          u[0] = this.extent, u[1] = this.n, u[2] = this.padding;
          let d = n;
          for (let m = 0; m < e.length; m++) {
            const S = e[m];
            u[3 + m] = d, u.set(S, d), d += S.length;
          }
          return u[3 + e.length] = d, u.set(this.keys, d), d += this.keys.length, u[3 + e.length + 1] = d, u.set(this.bboxes, d), d += this.bboxes.length, u.buffer;
        }
        static serialize(e, n) {
          const a = e.toArrayBuffer();
          return n && n.push(a), { buffer: a };
        }
        static deserialize(e) {
          return new go(e.buffer);
        }
      }
      const qn = {};
      function De(i, e, n = {}) {
        if (qn[i]) throw new Error(`${i} is already registered.`);
        Object.defineProperty(e, "_classRegistryKey", { value: i, writeable: !1 }), qn[i] = { klass: e, omit: n.omit || [], shallow: n.shallow || [] };
      }
      De("Object", Object), De("TransferableGridIndex", go), De("Color", Ri), De("Error", Error), De("AJAXError", Rt), De("ResolvedImage", Yr), De("StylePropertyFunction", Ss), De("StyleExpression", ar, { omit: ["_evaluator"] }), De("ZoomDependentExpression", ss), De("ZoomConstantExpression", Ur), De("CompoundExpression", jr, { omit: ["_evaluate"] });
      for (const i in vs) vs[i]._classRegistryKey || De(`Expression_${i}`, vs[i]);
      function cs(i) {
        return i && typeof ArrayBuffer < "u" && (i instanceof ArrayBuffer || i.constructor && i.constructor.name === "ArrayBuffer");
      }
      function Tn(i) {
        return i.$name || i.constructor._classRegistryKey;
      }
      function Is(i) {
        return !function(e) {
          if (e === null || typeof e != "object") return !1;
          const n = Tn(e);
          return !(!n || n === "Object");
        }(i) && (i == null || typeof i == "boolean" || typeof i == "number" || typeof i == "string" || i instanceof Boolean || i instanceof Number || i instanceof String || i instanceof Date || i instanceof RegExp || i instanceof Blob || i instanceof Error || cs(i) || Ht(i) || ArrayBuffer.isView(i) || i instanceof ImageData);
      }
      function yo(i, e) {
        if (Is(i)) return (cs(i) || Ht(i)) && e && e.push(i), ArrayBuffer.isView(i) && e && e.push(i.buffer), i instanceof ImageData && e && e.push(i.data.buffer), i;
        if (Array.isArray(i)) {
          const d = [];
          for (const m of i) d.push(yo(m, e));
          return d;
        }
        if (typeof i != "object") throw new Error("can't serialize object of type " + typeof i);
        const n = Tn(i);
        if (!n) throw new Error(`can't serialize object of unregistered class ${i.constructor.name}`);
        if (!qn[n]) throw new Error(`${n} is not registered.`);
        const { klass: a } = qn[n], u = a.serialize ? a.serialize(i, e) : {};
        if (a.serialize) {
          if (e && u === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const d in i) {
            if (!i.hasOwnProperty(d) || qn[n].omit.indexOf(d) >= 0) continue;
            const m = i[d];
            u[d] = qn[n].shallow.indexOf(d) >= 0 ? m : yo(m, e);
          }
          i instanceof Error && (u.message = i.message);
        }
        if (u.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return n !== "Object" && (u.$name = n), u;
      }
      function za(i) {
        if (Is(i)) return i;
        if (Array.isArray(i)) return i.map(za);
        if (typeof i != "object") throw new Error("can't deserialize object of type " + typeof i);
        const e = Tn(i) || "Object";
        if (!qn[e]) throw new Error(`can't deserialize unregistered class ${e}`);
        const { klass: n } = qn[e];
        if (!n) throw new Error(`can't deserialize unregistered class ${e}`);
        if (n.deserialize) return n.deserialize(i);
        const a = Object.create(n.prototype);
        for (const u of Object.keys(i)) {
          if (u === "$name") continue;
          const d = i[u];
          a[u] = qn[e].shallow.indexOf(u) >= 0 ? d : za(d);
        }
        return a;
      }
      class ks {
        constructor() {
          this.first = !0;
        }
        update(e, n) {
          const a = Math.floor(e);
          return this.first ? (this.first = !1, this.lastIntegerZoom = a, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = a, !0) : (this.lastFloorZoom > a ? (this.lastIntegerZoom = a + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < a && (this.lastIntegerZoom = a, this.lastIntegerZoomTime = n), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = a, !0));
        }
      }
      const fi = { "Latin-1 Supplement": (i) => i >= 128 && i <= 255, "Hangul Jamo": (i) => i >= 4352 && i <= 4607, Khmer: (i) => i >= 6016 && i <= 6143, "General Punctuation": (i) => i >= 8192 && i <= 8303, "Letterlike Symbols": (i) => i >= 8448 && i <= 8527, "Number Forms": (i) => i >= 8528 && i <= 8591, "Miscellaneous Technical": (i) => i >= 8960 && i <= 9215, "Control Pictures": (i) => i >= 9216 && i <= 9279, "Optical Character Recognition": (i) => i >= 9280 && i <= 9311, "Enclosed Alphanumerics": (i) => i >= 9312 && i <= 9471, "Geometric Shapes": (i) => i >= 9632 && i <= 9727, "Miscellaneous Symbols": (i) => i >= 9728 && i <= 9983, "Miscellaneous Symbols and Arrows": (i) => i >= 11008 && i <= 11263, "Ideographic Description Characters": (i) => i >= 12272 && i <= 12287, "CJK Symbols and Punctuation": (i) => i >= 12288 && i <= 12351, Katakana: (i) => i >= 12448 && i <= 12543, Kanbun: (i) => i >= 12688 && i <= 12703, "CJK Strokes": (i) => i >= 12736 && i <= 12783, "Enclosed CJK Letters and Months": (i) => i >= 12800 && i <= 13055, "CJK Compatibility": (i) => i >= 13056 && i <= 13311, "Yijing Hexagram Symbols": (i) => i >= 19904 && i <= 19967, "Private Use Area": (i) => i >= 57344 && i <= 63743, "Vertical Forms": (i) => i >= 65040 && i <= 65055, "CJK Compatibility Forms": (i) => i >= 65072 && i <= 65103, "Small Form Variants": (i) => i >= 65104 && i <= 65135, "Halfwidth and Fullwidth Forms": (i) => i >= 65280 && i <= 65519 };
      function jl(i) {
        for (const e of i) if (Ul(e.charCodeAt(0))) return !0;
        return !1;
      }
      function Fc(i) {
        for (const e of i) if (!Na(e.charCodeAt(0))) return !1;
        return !0;
      }
      function ml(i) {
        const e = i.map((n) => {
          try {
            return new RegExp(`\\p{sc=${n}}`, "u").source;
          } catch {
            return null;
          }
        }).filter((n) => n);
        return new RegExp(e.join("|"), "u");
      }
      const ac = ml(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function Na(i) {
        return !ac.test(String.fromCodePoint(i));
      }
      const ql = ml(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function Ul(i) {
        return !(i !== 746 && i !== 747 && (i < 4352 || !(fi["CJK Compatibility Forms"](i) && !(i >= 65097 && i <= 65103) || fi["CJK Compatibility"](i) || fi["CJK Strokes"](i) || !(!fi["CJK Symbols and Punctuation"](i) || i >= 12296 && i <= 12305 || i >= 12308 && i <= 12319 || i === 12336) || fi["Enclosed CJK Letters and Months"](i) || fi["Ideographic Description Characters"](i) || fi.Kanbun(i) || fi.Katakana(i) && i !== 12540 || !(!fi["Halfwidth and Fullwidth Forms"](i) || i === 65288 || i === 65289 || i === 65293 || i >= 65306 && i <= 65310 || i === 65339 || i === 65341 || i === 65343 || i >= 65371 && i <= 65503 || i === 65507 || i >= 65512 && i <= 65519) || !(!fi["Small Form Variants"](i) || i >= 65112 && i <= 65118 || i >= 65123 && i <= 65126) || fi["Vertical Forms"](i) || fi["Yijing Hexagram Symbols"](i) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(i)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(i)) || ql.test(String.fromCodePoint(i)))));
      }
      function Yo(i) {
        return !(Ul(i) || function(e) {
          return !!(fi["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || fi["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || fi["Letterlike Symbols"](e) || fi["Number Forms"](e) || fi["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || fi["Control Pictures"](e) && e !== 9251 || fi["Optical Character Recognition"](e) || fi["Enclosed Alphanumerics"](e) || fi["Geometric Shapes"](e) || fi["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || fi["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || fi["CJK Symbols and Punctuation"](e) || fi.Katakana(e) || fi["Private Use Area"](e) || fi["CJK Compatibility Forms"](e) || fi["Small Form Variants"](e) || fi["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533);
        }(i));
      }
      const gl = ml(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function Da(i) {
        return gl.test(String.fromCodePoint(i));
      }
      function Vl(i, e) {
        return !(!e && Da(i) || i >= 2304 && i <= 3583 || i >= 3840 && i <= 4255 || fi.Khmer(i));
      }
      function oc(i) {
        for (const e of i) if (Da(e.charCodeAt(0))) return !0;
        return !1;
      }
      const Ln = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(i) {
          this.pluginStatus = i.pluginStatus, this.pluginURL = i.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(i) {
          this.applyArabicShaping = i.applyArabicShaping, this.processBidirectionalText = i.processBidirectionalText, this.processStyledBidirectionalText = i.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      }();
      class Xi {
        constructor(e, n) {
          this.zoom = e, n ? (this.now = n.now, this.fadeDuration = n.fadeDuration, this.zoomHistory = n.zoomHistory, this.transition = n.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ks(), this.transition = {});
        }
        isSupportedScript(e) {
          return function(n, a) {
            for (const u of n) if (!Vl(u.charCodeAt(0), a)) return !1;
            return !0;
          }(e, Ln.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const e = this.zoom, n = e - Math.floor(e), a = this.crossFadingFactor();
          return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * a } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - a) * n };
        }
      }
      class _o {
        constructor(e, n) {
          this.property = e, this.value = n, this.expression = function(a, u) {
            if (xs(a)) return new Ss(a, u);
            if (oa(a)) {
              const d = lo(a, u);
              if (d.result === "error") throw new Error(d.value.map((m) => `${m.key}: ${m.message}`).join(", "));
              return d.value;
            }
            {
              let d = a;
              return u.type === "color" && typeof a == "string" ? d = Ri.parse(a) : u.type !== "padding" || typeof a != "number" && !Array.isArray(a) ? u.type === "variableAnchorOffsetCollection" && Array.isArray(a) && (d = mn.parse(a)) : d = ln.parse(a), { kind: "constant", evaluate: () => d };
            }
          }(n === void 0 ? e.specification.default : n, e.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(e, n, a) {
          return this.property.possiblyEvaluate(this, e, n, a);
        }
      }
      class yl {
        constructor(e) {
          this.property = e, this.value = new _o(e, void 0);
        }
        transitioned(e, n) {
          return new lc(this.property, this.value, n, Ot({}, e.transition, this.transition), e.now);
        }
        untransitioned() {
          return new lc(this.property, this.value, null, {}, 0);
        }
      }
      class _l {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues);
        }
        getValue(e) {
          return at(this._values[e].value.value);
        }
        setValue(e, n) {
          Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new yl(this._values[e].property)), this._values[e].value = new _o(this._values[e].property, n === null ? void 0 : at(n));
        }
        getTransition(e) {
          return at(this._values[e].transition);
        }
        setTransition(e, n) {
          Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new yl(this._values[e].property)), this._values[e].transition = at(n) || void 0;
        }
        serialize() {
          const e = {};
          for (const n of Object.keys(this._values)) {
            const a = this.getValue(n);
            a !== void 0 && (e[n] = a);
            const u = this.getTransition(n);
            u !== void 0 && (e[`${n}-transition`] = u);
          }
          return e;
        }
        transitioned(e, n) {
          const a = new Ko(this._properties);
          for (const u of Object.keys(this._values)) a._values[u] = this._values[u].transitioned(e, n._values[u]);
          return a;
        }
        untransitioned() {
          const e = new Ko(this._properties);
          for (const n of Object.keys(this._values)) e._values[n] = this._values[n].untransitioned();
          return e;
        }
      }
      class lc {
        constructor(e, n, a, u, d) {
          this.property = e, this.value = n, this.begin = d + u.delay || 0, this.end = this.begin + u.duration || 0, e.specification.transition && (u.delay || u.duration) && (this.prior = a);
        }
        possiblyEvaluate(e, n, a) {
          const u = e.now || 0, d = this.value.possiblyEvaluate(e, n, a), m = this.prior;
          if (m) {
            if (u > this.end) return this.prior = null, d;
            if (this.value.isDataDriven()) return this.prior = null, d;
            if (u < this.begin) return m.possiblyEvaluate(e, n, a);
            {
              const S = (u - this.begin) / (this.end - this.begin);
              return this.property.interpolate(m.possiblyEvaluate(e, n, a), d, function(I) {
                if (I <= 0) return 0;
                if (I >= 1) return 1;
                const C = I * I, N = C * I;
                return 4 * (I < 0.5 ? N : 3 * (I - C) + N - 0.75);
              }(S));
            }
          }
          return d;
        }
      }
      class Ko {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(e, n, a) {
          const u = new ua(this._properties);
          for (const d of Object.keys(this._values)) u._values[d] = this._values[d].possiblyEvaluate(e, n, a);
          return u;
        }
        hasTransition() {
          for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
          return !1;
        }
      }
      class Jo {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPropertyValues);
        }
        hasValue(e) {
          return this._values[e].value !== void 0;
        }
        getValue(e) {
          return at(this._values[e].value);
        }
        setValue(e, n) {
          this._values[e] = new _o(this._values[e].property, n === null ? void 0 : at(n));
        }
        serialize() {
          const e = {};
          for (const n of Object.keys(this._values)) {
            const a = this.getValue(n);
            a !== void 0 && (e[n] = a);
          }
          return e;
        }
        possiblyEvaluate(e, n, a) {
          const u = new ua(this._properties);
          for (const d of Object.keys(this._values)) u._values[d] = this._values[d].possiblyEvaluate(e, n, a);
          return u;
        }
      }
      class hs {
        constructor(e, n, a) {
          this.property = e, this.value = n, this.parameters = a;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(e) {
          return this.value.kind === "constant" ? this.value.value : e;
        }
        evaluate(e, n, a, u) {
          return this.property.evaluate(this.value, this.parameters, e, n, a, u);
        }
      }
      class ua {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
        }
        get(e) {
          return this._values[e];
        }
      }
      class je {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n) {
          if (e.isDataDriven()) throw new Error("Value should not be data driven");
          return e.expression.evaluate(n);
        }
        interpolate(e, n, a) {
          const u = Or[this.specification.type];
          return u ? u(e, n, a) : e;
        }
      }
      class Qe {
        constructor(e, n) {
          this.specification = e, this.overrides = n;
        }
        possiblyEvaluate(e, n, a, u) {
          return new hs(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(n, null, {}, a, u) } : e.expression, n);
        }
        interpolate(e, n, a) {
          if (e.value.kind !== "constant" || n.value.kind !== "constant") return e;
          if (e.value.value === void 0 || n.value.value === void 0) return new hs(this, { kind: "constant", value: void 0 }, e.parameters);
          const u = Or[this.specification.type];
          if (u) {
            const d = u(e.value.value, n.value.value, a);
            return new hs(this, { kind: "constant", value: d }, e.parameters);
          }
          return e;
        }
        evaluate(e, n, a, u, d, m) {
          return e.kind === "constant" ? e.value : e.evaluate(n, a, u, d, m);
        }
      }
      class Qo extends Qe {
        possiblyEvaluate(e, n, a, u) {
          if (e.value === void 0) return new hs(this, { kind: "constant", value: void 0 }, n);
          if (e.expression.kind === "constant") {
            const d = e.expression.evaluate(n, null, {}, a, u), m = e.property.specification.type === "resolvedImage" && typeof d != "string" ? d.name : d, S = this._calculate(m, m, m, n);
            return new hs(this, { kind: "constant", value: S }, n);
          }
          if (e.expression.kind === "camera") {
            const d = this._calculate(e.expression.evaluate({ zoom: n.zoom - 1 }), e.expression.evaluate({ zoom: n.zoom }), e.expression.evaluate({ zoom: n.zoom + 1 }), n);
            return new hs(this, { kind: "constant", value: d }, n);
          }
          return new hs(this, e.expression, n);
        }
        evaluate(e, n, a, u, d, m) {
          if (e.kind === "source") {
            const S = e.evaluate(n, a, u, d, m);
            return this._calculate(S, S, S, n);
          }
          return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(n.zoom) - 1 }, a, u), e.evaluate({ zoom: Math.floor(n.zoom) }, a, u), e.evaluate({ zoom: Math.floor(n.zoom) + 1 }, a, u), n) : e.value;
        }
        _calculate(e, n, a, u) {
          return u.zoom > u.zoomHistory.lastIntegerZoom ? { from: e, to: n } : { from: a, to: n };
        }
        interpolate(e) {
          return e;
        }
      }
      class p {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n, a, u) {
          if (e.value !== void 0) {
            if (e.expression.kind === "constant") {
              const d = e.expression.evaluate(n, null, {}, a, u);
              return this._calculate(d, d, d, n);
            }
            return this._calculate(e.expression.evaluate(new Xi(Math.floor(n.zoom - 1), n)), e.expression.evaluate(new Xi(Math.floor(n.zoom), n)), e.expression.evaluate(new Xi(Math.floor(n.zoom + 1), n)), n);
          }
        }
        _calculate(e, n, a, u) {
          return u.zoom > u.zoomHistory.lastIntegerZoom ? { from: e, to: n } : { from: a, to: n };
        }
        interpolate(e) {
          return e;
        }
      }
      class w {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n, a, u) {
          return !!e.expression.evaluate(n, null, {}, a, u);
        }
        interpolate() {
          return !1;
        }
      }
      class o {
        constructor(e) {
          this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const n in e) {
            const a = e[n];
            a.specification.overridable && this.overridableProperties.push(n);
            const u = this.defaultPropertyValues[n] = new _o(a, void 0), d = this.defaultTransitionablePropertyValues[n] = new yl(a);
            this.defaultTransitioningPropertyValues[n] = d.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = u.possiblyEvaluate({});
          }
        }
      }
      De("DataDrivenProperty", Qe), De("DataConstantProperty", je), De("CrossFadedDataDrivenProperty", Qo), De("CrossFadedProperty", p), De("ColorRampProperty", w);
      const t = "-transition";
      class r extends Qt {
        constructor(e, n) {
          if (super(), this.id = e.id, this.type = e.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, e.type !== "custom" && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), n.layout && (this._unevaluatedLayout = new Jo(n.layout)), n.paint)) {
            this._transitionablePaint = new _l(n.paint);
            for (const a in e.paint) this.setPaintProperty(a, e.paint[a], { validate: !1 });
            for (const a in e.layout) this.setLayoutProperty(a, e.layout[a], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ua(n.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(e) {
          return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
        }
        setLayoutProperty(e, n, a = {}) {
          n != null && this._validate(Rl, `layers.${this.id}.layout.${e}`, e, n, a) || (e !== "visibility" ? this._unevaluatedLayout.setValue(e, n) : this.visibility = n);
        }
        getPaintProperty(e) {
          return e.endsWith(t) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
        }
        setPaintProperty(e, n, a = {}) {
          if (n != null && this._validate(sc, `layers.${this.id}.paint.${e}`, e, n, a)) return !1;
          if (e.endsWith(t)) return this._transitionablePaint.setTransition(e.slice(0, -11), n || void 0), !1;
          {
            const u = this._transitionablePaint._values[e], d = u.property.specification["property-type"] === "cross-faded-data-driven", m = u.value.isDataDriven(), S = u.value;
            this._transitionablePaint.setValue(e, n), this._handleSpecialPaintPropertyUpdate(e);
            const I = this._transitionablePaint._values[e].value;
            return I.isDataDriven() || m || d || this._handleOverridablePaintPropertyUpdate(e, S, I);
          }
        }
        _handleSpecialPaintPropertyUpdate(e) {
        }
        _handleOverridablePaintPropertyUpdate(e, n, a) {
          return !1;
        }
        isHidden(e) {
          return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(e) {
          this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(e, n) {
          e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, n);
        }
        serialize() {
          const e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), ae(e, (n, a) => !(n === void 0 || a === "layout" && !Object.keys(n).length || a === "paint" && !Object.keys(n).length));
        }
        _validate(e, n, a, u, d = {}) {
          return (!d || d.validate !== !1) && Ol(this, e.call(qs, { key: n, layerType: this.type, objectKey: a, value: u, styleSpec: Y, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const e in this.paint._values) {
            const n = this.paint.get(e);
            if (n instanceof hs && ns(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0;
          }
          return !1;
        }
      }
      const s = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class l {
        constructor(e, n) {
          this._structArray = e, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class h {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(e, n) {
          return e._trim(), n && (e.isTransferred = !0, n.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
        }
        static deserialize(e) {
          const n = Object.create(this.prototype);
          return n.arrayBuffer = e.arrayBuffer, n.length = e.length, n.capacity = e.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(e) {
          this.reserve(e), this.length = e;
        }
        reserve(e) {
          if (e > this.capacity) {
            this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const n = this.uint8;
            this._refreshViews(), n && this.uint8.set(n);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function g(i, e = 1) {
        let n = 0, a = 0;
        return { members: i.map((u) => {
          const d = s[u.type].BYTES_PER_ELEMENT, m = n = _(n, Math.max(e, d)), S = u.components || 1;
          return a = Math.max(a, d), n += d * S, { name: u.name, type: u.type, components: S, offset: m };
        }), size: _(n, Math.max(a, e)), alignment: e };
      }
      function _(i, e) {
        return Math.ceil(i / e) * e;
      }
      class A extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, e, n);
        }
        emplace(e, n, a) {
          const u = 2 * e;
          return this.int16[u + 0] = n, this.int16[u + 1] = a, e;
        }
      }
      A.prototype.bytesPerElement = 4, De("StructArrayLayout2i4", A);
      class L extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, a);
        }
        emplace(e, n, a, u) {
          const d = 3 * e;
          return this.int16[d + 0] = n, this.int16[d + 1] = a, this.int16[d + 2] = u, e;
        }
      }
      L.prototype.bytesPerElement = 6, De("StructArrayLayout3i6", L);
      class E extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, e, n, a, u);
        }
        emplace(e, n, a, u, d) {
          const m = 4 * e;
          return this.int16[m + 0] = n, this.int16[m + 1] = a, this.int16[m + 2] = u, this.int16[m + 3] = d, e;
        }
      }
      E.prototype.bytesPerElement = 8, De("StructArrayLayout4i8", E);
      class M extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d, m) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, a, u, d, m);
        }
        emplace(e, n, a, u, d, m, S) {
          const I = 6 * e;
          return this.int16[I + 0] = n, this.int16[I + 1] = a, this.int16[I + 2] = u, this.int16[I + 3] = d, this.int16[I + 4] = m, this.int16[I + 5] = S, e;
        }
      }
      M.prototype.bytesPerElement = 12, De("StructArrayLayout2i4i12", M);
      class R extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d, m) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, a, u, d, m);
        }
        emplace(e, n, a, u, d, m, S) {
          const I = 4 * e, C = 8 * e;
          return this.int16[I + 0] = n, this.int16[I + 1] = a, this.uint8[C + 4] = u, this.uint8[C + 5] = d, this.uint8[C + 6] = m, this.uint8[C + 7] = S, e;
        }
      }
      R.prototype.bytesPerElement = 8, De("StructArrayLayout2i4ub8", R);
      class q extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, e, n);
        }
        emplace(e, n, a) {
          const u = 2 * e;
          return this.float32[u + 0] = n, this.float32[u + 1] = a, e;
        }
      }
      q.prototype.bytesPerElement = 8, De("StructArrayLayout2f8", q);
      class B extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d, m, S, I, C, N) {
          const D = this.length;
          return this.resize(D + 1), this.emplace(D, e, n, a, u, d, m, S, I, C, N);
        }
        emplace(e, n, a, u, d, m, S, I, C, N, D) {
          const G = 10 * e;
          return this.uint16[G + 0] = n, this.uint16[G + 1] = a, this.uint16[G + 2] = u, this.uint16[G + 3] = d, this.uint16[G + 4] = m, this.uint16[G + 5] = S, this.uint16[G + 6] = I, this.uint16[G + 7] = C, this.uint16[G + 8] = N, this.uint16[G + 9] = D, e;
        }
      }
      B.prototype.bytesPerElement = 20, De("StructArrayLayout10ui20", B);
      class $ extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d, m, S, I, C, N, D, G) {
          const W = this.length;
          return this.resize(W + 1), this.emplace(W, e, n, a, u, d, m, S, I, C, N, D, G);
        }
        emplace(e, n, a, u, d, m, S, I, C, N, D, G, W) {
          const J = 12 * e;
          return this.int16[J + 0] = n, this.int16[J + 1] = a, this.int16[J + 2] = u, this.int16[J + 3] = d, this.uint16[J + 4] = m, this.uint16[J + 5] = S, this.uint16[J + 6] = I, this.uint16[J + 7] = C, this.int16[J + 8] = N, this.int16[J + 9] = D, this.int16[J + 10] = G, this.int16[J + 11] = W, e;
        }
      }
      $.prototype.bytesPerElement = 24, De("StructArrayLayout4i4ui4i24", $);
      class Q extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, a);
        }
        emplace(e, n, a, u) {
          const d = 3 * e;
          return this.float32[d + 0] = n, this.float32[d + 1] = a, this.float32[d + 2] = u, e;
        }
      }
      Q.prototype.bytesPerElement = 12, De("StructArrayLayout3f12", Q);
      class tt extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint32[1 * e + 0] = n, e;
        }
      }
      tt.prototype.bytesPerElement = 4, De("StructArrayLayout1ul4", tt);
      class nt extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d, m, S, I, C) {
          const N = this.length;
          return this.resize(N + 1), this.emplace(N, e, n, a, u, d, m, S, I, C);
        }
        emplace(e, n, a, u, d, m, S, I, C, N) {
          const D = 10 * e, G = 5 * e;
          return this.int16[D + 0] = n, this.int16[D + 1] = a, this.int16[D + 2] = u, this.int16[D + 3] = d, this.int16[D + 4] = m, this.int16[D + 5] = S, this.uint32[G + 3] = I, this.uint16[D + 8] = C, this.uint16[D + 9] = N, e;
        }
      }
      nt.prototype.bytesPerElement = 20, De("StructArrayLayout6i1ul2ui20", nt);
      class it extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d, m) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, a, u, d, m);
        }
        emplace(e, n, a, u, d, m, S) {
          const I = 6 * e;
          return this.int16[I + 0] = n, this.int16[I + 1] = a, this.int16[I + 2] = u, this.int16[I + 3] = d, this.int16[I + 4] = m, this.int16[I + 5] = S, e;
        }
      }
      it.prototype.bytesPerElement = 12, De("StructArrayLayout2i2i2i12", it);
      class ht extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d) {
          const m = this.length;
          return this.resize(m + 1), this.emplace(m, e, n, a, u, d);
        }
        emplace(e, n, a, u, d, m) {
          const S = 4 * e, I = 8 * e;
          return this.float32[S + 0] = n, this.float32[S + 1] = a, this.float32[S + 2] = u, this.int16[I + 6] = d, this.int16[I + 7] = m, e;
        }
      }
      ht.prototype.bytesPerElement = 16, De("StructArrayLayout2f1f2i16", ht);
      class wt extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d, m) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, a, u, d, m);
        }
        emplace(e, n, a, u, d, m, S) {
          const I = 16 * e, C = 4 * e, N = 8 * e;
          return this.uint8[I + 0] = n, this.uint8[I + 1] = a, this.float32[C + 1] = u, this.float32[C + 2] = d, this.int16[N + 6] = m, this.int16[N + 7] = S, e;
        }
      }
      wt.prototype.bytesPerElement = 16, De("StructArrayLayout2ub2f2i16", wt);
      class _t extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, a);
        }
        emplace(e, n, a, u) {
          const d = 3 * e;
          return this.uint16[d + 0] = n, this.uint16[d + 1] = a, this.uint16[d + 2] = u, e;
        }
      }
      _t.prototype.bytesPerElement = 6, De("StructArrayLayout3ui6", _t);
      class Vt extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d, m, S, I, C, N, D, G, W, J, rt, dt, vt) {
          const Dt = this.length;
          return this.resize(Dt + 1), this.emplace(Dt, e, n, a, u, d, m, S, I, C, N, D, G, W, J, rt, dt, vt);
        }
        emplace(e, n, a, u, d, m, S, I, C, N, D, G, W, J, rt, dt, vt, Dt) {
          const Lt = 24 * e, Nt = 12 * e, Zt = 48 * e;
          return this.int16[Lt + 0] = n, this.int16[Lt + 1] = a, this.uint16[Lt + 2] = u, this.uint16[Lt + 3] = d, this.uint32[Nt + 2] = m, this.uint32[Nt + 3] = S, this.uint32[Nt + 4] = I, this.uint16[Lt + 10] = C, this.uint16[Lt + 11] = N, this.uint16[Lt + 12] = D, this.float32[Nt + 7] = G, this.float32[Nt + 8] = W, this.uint8[Zt + 36] = J, this.uint8[Zt + 37] = rt, this.uint8[Zt + 38] = dt, this.uint32[Nt + 10] = vt, this.int16[Lt + 22] = Dt, e;
        }
      }
      Vt.prototype.bytesPerElement = 48, De("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Vt);
      class re extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u, d, m, S, I, C, N, D, G, W, J, rt, dt, vt, Dt, Lt, Nt, Zt, ge, Me, ri, Le, Ae, Ve, Re) {
          const Fe = this.length;
          return this.resize(Fe + 1), this.emplace(Fe, e, n, a, u, d, m, S, I, C, N, D, G, W, J, rt, dt, vt, Dt, Lt, Nt, Zt, ge, Me, ri, Le, Ae, Ve, Re);
        }
        emplace(e, n, a, u, d, m, S, I, C, N, D, G, W, J, rt, dt, vt, Dt, Lt, Nt, Zt, ge, Me, ri, Le, Ae, Ve, Re, Fe) {
          const ne = 32 * e, We = 16 * e;
          return this.int16[ne + 0] = n, this.int16[ne + 1] = a, this.int16[ne + 2] = u, this.int16[ne + 3] = d, this.int16[ne + 4] = m, this.int16[ne + 5] = S, this.int16[ne + 6] = I, this.int16[ne + 7] = C, this.uint16[ne + 8] = N, this.uint16[ne + 9] = D, this.uint16[ne + 10] = G, this.uint16[ne + 11] = W, this.uint16[ne + 12] = J, this.uint16[ne + 13] = rt, this.uint16[ne + 14] = dt, this.uint16[ne + 15] = vt, this.uint16[ne + 16] = Dt, this.uint16[ne + 17] = Lt, this.uint16[ne + 18] = Nt, this.uint16[ne + 19] = Zt, this.uint16[ne + 20] = ge, this.uint16[ne + 21] = Me, this.uint16[ne + 22] = ri, this.uint32[We + 12] = Le, this.float32[We + 13] = Ae, this.float32[We + 14] = Ve, this.uint16[ne + 30] = Re, this.uint16[ne + 31] = Fe, e;
        }
      }
      re.prototype.bytesPerElement = 64, De("StructArrayLayout8i15ui1ul2f2ui64", re);
      class ce extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.float32[1 * e + 0] = n, e;
        }
      }
      ce.prototype.bytesPerElement = 4, De("StructArrayLayout1f4", ce);
      class de extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, a);
        }
        emplace(e, n, a, u) {
          const d = 3 * e;
          return this.uint16[6 * e + 0] = n, this.float32[d + 1] = a, this.float32[d + 2] = u, e;
        }
      }
      de.prototype.bytesPerElement = 12, De("StructArrayLayout1ui2f12", de);
      class ue extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, a);
        }
        emplace(e, n, a, u) {
          const d = 4 * e;
          return this.uint32[2 * e + 0] = n, this.uint16[d + 2] = a, this.uint16[d + 3] = u, e;
        }
      }
      ue.prototype.bytesPerElement = 8, De("StructArrayLayout1ul2ui8", ue);
      class he extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, e, n);
        }
        emplace(e, n, a) {
          const u = 2 * e;
          return this.uint16[u + 0] = n, this.uint16[u + 1] = a, e;
        }
      }
      he.prototype.bytesPerElement = 4, De("StructArrayLayout2ui4", he);
      class fe extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint16[1 * e + 0] = n, e;
        }
      }
      fe.prototype.bytesPerElement = 2, De("StructArrayLayout1ui2", fe);
      class Oe extends h {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, a, u) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, e, n, a, u);
        }
        emplace(e, n, a, u, d) {
          const m = 4 * e;
          return this.float32[m + 0] = n, this.float32[m + 1] = a, this.float32[m + 2] = u, this.float32[m + 3] = d, e;
        }
      }
      Oe.prototype.bytesPerElement = 16, De("StructArrayLayout4f16", Oe);
      class ve extends l {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new O(this.anchorPointX, this.anchorPointY);
        }
      }
      ve.prototype.size = 20;
      class xe extends nt {
        get(e) {
          return new ve(this, e);
        }
      }
      De("CollisionBoxArray", xe);
      class Ue extends l {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(e) {
          this._structArray.uint8[this._pos1 + 37] = e;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(e) {
          this._structArray.uint8[this._pos1 + 38] = e;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 10] = e;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Ue.prototype.size = 48;
      class ni extends Vt {
        get(e) {
          return new Ue(this, e);
        }
      }
      De("PlacedSymbolArray", ni);
      class ii extends l {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 12] = e;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      ii.prototype.size = 64;
      class ci extends re {
        get(e) {
          return new ii(this, e);
        }
      }
      De("SymbolInstanceArray", ci);
      class bi extends ce {
        getoffsetX(e) {
          return this.float32[1 * e + 0];
        }
      }
      De("GlyphOffsetArray", bi);
      class ji extends L {
        getx(e) {
          return this.int16[3 * e + 0];
        }
        gety(e) {
          return this.int16[3 * e + 1];
        }
        gettileUnitDistanceFromAnchor(e) {
          return this.int16[3 * e + 2];
        }
      }
      De("SymbolLineVertexArray", ji);
      class tr extends l {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      tr.prototype.size = 12;
      class Ni extends de {
        get(e) {
          return new tr(this, e);
        }
      }
      De("TextAnchorOffsetArray", Ni);
      class ur extends l {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      ur.prototype.size = 8;
      class qi extends ue {
        get(e) {
          return new ur(this, e);
        }
      }
      De("FeatureIndexArray", qi);
      class or extends A {
      }
      class xr extends A {
      }
      class dn extends A {
      }
      class Cn extends M {
      }
      class er extends R {
      }
      class da extends q {
      }
      class Mn extends B {
      }
      class tl extends $ {
      }
      class vo extends Q {
      }
      class en extends tt {
      }
      class pn extends it {
      }
      class Fr extends wt {
      }
      class rn extends _t {
      }
      class yr extends he {
      }
      const Vr = g([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: nn } = Vr;
      class Li {
        constructor(e = []) {
          this.segments = e;
        }
        prepareSegment(e, n, a, u) {
          let d = this.segments[this.segments.length - 1];
          return e > Li.MAX_VERTEX_ARRAY_LENGTH && It(`Max vertices per segment is ${Li.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!d || d.vertexLength + e > Li.MAX_VERTEX_ARRAY_LENGTH || d.sortKey !== u) && (d = { vertexOffset: n.length, primitiveOffset: a.length, vertexLength: 0, primitiveLength: 0 }, u !== void 0 && (d.sortKey = u), this.segments.push(d)), d;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const e of this.segments) for (const n in e.vaos) e.vaos[n].destroy();
        }
        static simpleSegment(e, n, a, u) {
          return new Li([{ vertexOffset: e, primitiveOffset: n, vertexLength: a, primitiveLength: u, vaos: {}, sortKey: 0 }]);
        }
      }
      function Ts(i, e) {
        return 256 * (i = Kt(Math.floor(i), 0, 255)) + Kt(Math.floor(e), 0, 255);
      }
      Li.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, De("SegmentVector", Li);
      const pa = g([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var Us = { exports: {} }, xo = { exports: {} };
      xo.exports = function(i, e) {
        var n, a, u, d, m, S, I, C;
        for (a = i.length - (n = 3 & i.length), u = e, m = 3432918353, S = 461845907, C = 0; C < a; ) I = 255 & i.charCodeAt(C) | (255 & i.charCodeAt(++C)) << 8 | (255 & i.charCodeAt(++C)) << 16 | (255 & i.charCodeAt(++C)) << 24, ++C, u = 27492 + (65535 & (d = 5 * (65535 & (u = (u ^= I = (65535 & (I = (I = (65535 & I) * m + (((I >>> 16) * m & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295) << 13 | u >>> 19)) + ((5 * (u >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (d >>> 16) & 65535) << 16);
        switch (I = 0, n) {
          case 3:
            I ^= (255 & i.charCodeAt(C + 2)) << 16;
          case 2:
            I ^= (255 & i.charCodeAt(C + 1)) << 8;
          case 1:
            u ^= I = (65535 & (I = (I = (65535 & (I ^= 255 & i.charCodeAt(C))) * m + (((I >>> 16) * m & 65535) << 16) & 4294967295) << 15 | I >>> 17)) * S + (((I >>> 16) * S & 65535) << 16) & 4294967295;
        }
        return u ^= i.length, u = 2246822507 * (65535 & (u ^= u >>> 16)) + ((2246822507 * (u >>> 16) & 65535) << 16) & 4294967295, u = 3266489909 * (65535 & (u ^= u >>> 13)) + ((3266489909 * (u >>> 16) & 65535) << 16) & 4294967295, (u ^= u >>> 16) >>> 0;
      };
      var Bc = xo.exports, cc = { exports: {} };
      cc.exports = function(i, e) {
        for (var n, a = i.length, u = e ^ a, d = 0; a >= 4; ) n = 1540483477 * (65535 & (n = 255 & i.charCodeAt(d) | (255 & i.charCodeAt(++d)) << 8 | (255 & i.charCodeAt(++d)) << 16 | (255 & i.charCodeAt(++d)) << 24)) + ((1540483477 * (n >>> 16) & 65535) << 16), u = 1540483477 * (65535 & u) + ((1540483477 * (u >>> 16) & 65535) << 16) ^ (n = 1540483477 * (65535 & (n ^= n >>> 24)) + ((1540483477 * (n >>> 16) & 65535) << 16)), a -= 4, ++d;
        switch (a) {
          case 3:
            u ^= (255 & i.charCodeAt(d + 2)) << 16;
          case 2:
            u ^= (255 & i.charCodeAt(d + 1)) << 8;
          case 1:
            u = 1540483477 * (65535 & (u ^= 255 & i.charCodeAt(d))) + ((1540483477 * (u >>> 16) & 65535) << 16);
        }
        return u = 1540483477 * (65535 & (u ^= u >>> 13)) + ((1540483477 * (u >>> 16) & 65535) << 16), (u ^= u >>> 15) >>> 0;
      };
      var Ls = Bc, Vs = cc.exports;
      Us.exports = Ls, Us.exports.murmur3 = Ls, Us.exports.murmur2 = Vs;
      var vl = z(Us.exports);
      class el {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(e, n, a, u) {
          this.ids.push(xl(e)), this.positions.push(n, a, u);
        }
        getPositions(e) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const n = xl(e);
          let a = 0, u = this.ids.length - 1;
          for (; a < u; ) {
            const m = a + u >> 1;
            this.ids[m] >= n ? u = m : a = m + 1;
          }
          const d = [];
          for (; this.ids[a] === n; ) d.push({ index: this.positions[3 * a], start: this.positions[3 * a + 1], end: this.positions[3 * a + 2] }), a++;
          return d;
        }
        static serialize(e, n) {
          const a = new Float64Array(e.ids), u = new Uint32Array(e.positions);
          return il(a, u, 0, a.length - 1), n && n.push(a.buffer, u.buffer), { ids: a, positions: u };
        }
        static deserialize(e) {
          const n = new el();
          return n.ids = e.ids, n.positions = e.positions, n.indexed = !0, n;
        }
      }
      function xl(i) {
        const e = +i;
        return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : vl(String(i));
      }
      function il(i, e, n, a) {
        for (; n < a; ) {
          const u = i[n + a >> 1];
          let d = n - 1, m = a + 1;
          for (; ; ) {
            do
              d++;
            while (i[d] < u);
            do
              m--;
            while (i[m] > u);
            if (d >= m) break;
            Gs(i, d, m), Gs(e, 3 * d, 3 * m), Gs(e, 3 * d + 1, 3 * m + 1), Gs(e, 3 * d + 2, 3 * m + 2);
          }
          m - n < a - m ? (il(i, e, n, m), n = m + 1) : (il(i, e, m + 1, a), a = m);
        }
      }
      function Gs(i, e, n) {
        const a = i[e];
        i[e] = i[n], i[n] = a;
      }
      De("FeaturePositionMap", el);
      class bo {
        constructor(e, n) {
          this.gl = e.gl, this.location = n;
        }
      }
      class Gl extends bo {
        constructor(e, n) {
          super(e, n), this.current = 0;
        }
        set(e) {
          this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
        }
      }
      class $l extends bo {
        constructor(e, n) {
          super(e, n), this.current = [0, 0, 0, 0];
        }
        set(e) {
          e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
        }
      }
      class hc extends bo {
        constructor(e, n) {
          super(e, n), this.current = Ri.transparent;
        }
        set(e) {
          e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
        }
      }
      const Zl = new Float32Array(16);
      function uc(i) {
        return [Ts(255 * i.r, 255 * i.g), Ts(255 * i.b, 255 * i.a)];
      }
      class Wl {
        constructor(e, n, a) {
          this.value = e, this.uniformNames = n.map((u) => `u_${u}`), this.type = a;
        }
        setUniform(e, n, a) {
          e.set(a.constantOr(this.value));
        }
        getBinding(e, n, a) {
          return this.type === "color" ? new hc(e, n) : new Gl(e, n);
        }
      }
      class Fa {
        constructor(e, n) {
          this.uniformNames = n.map((a) => `u_${a}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(e, n) {
          this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = e.tlbr;
        }
        setUniform(e, n, a, u) {
          const d = u === "u_pattern_to" ? this.patternTo : u === "u_pattern_from" ? this.patternFrom : u === "u_pixel_ratio_to" ? this.pixelRatioTo : u === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          d && e.set(d);
        }
        getBinding(e, n, a) {
          return a.substr(0, 9) === "u_pattern" ? new $l(e, n) : new Gl(e, n);
        }
      }
      class fa {
        constructor(e, n, a, u) {
          this.expression = e, this.type = a, this.maxValue = 0, this.paintVertexAttributes = n.map((d) => ({ name: `a_${d}`, type: "Float32", components: a === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new u();
        }
        populatePaintArray(e, n, a, u, d) {
          const m = this.paintVertexArray.length, S = this.expression.evaluate(new Xi(0), n, {}, u, [], d);
          this.paintVertexArray.resize(e), this._setPaintValue(m, e, S);
        }
        updatePaintArray(e, n, a, u) {
          const d = this.expression.evaluate({ zoom: 0 }, a, u);
          this._setPaintValue(e, n, d);
        }
        _setPaintValue(e, n, a) {
          if (this.type === "color") {
            const u = uc(a);
            for (let d = e; d < n; d++) this.paintVertexArray.emplace(d, u[0], u[1]);
          } else {
            for (let u = e; u < n; u++) this.paintVertexArray.emplace(u, a);
            this.maxValue = Math.max(this.maxValue, Math.abs(a));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class us {
        constructor(e, n, a, u, d, m) {
          this.expression = e, this.uniformNames = n.map((S) => `u_${S}_t`), this.type = a, this.useIntegerZoom = u, this.zoom = d, this.maxValue = 0, this.paintVertexAttributes = n.map((S) => ({ name: `a_${S}`, type: "Float32", components: a === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new m();
        }
        populatePaintArray(e, n, a, u, d) {
          const m = this.expression.evaluate(new Xi(this.zoom), n, {}, u, [], d), S = this.expression.evaluate(new Xi(this.zoom + 1), n, {}, u, [], d), I = this.paintVertexArray.length;
          this.paintVertexArray.resize(e), this._setPaintValue(I, e, m, S);
        }
        updatePaintArray(e, n, a, u) {
          const d = this.expression.evaluate({ zoom: this.zoom }, a, u), m = this.expression.evaluate({ zoom: this.zoom + 1 }, a, u);
          this._setPaintValue(e, n, d, m);
        }
        _setPaintValue(e, n, a, u) {
          if (this.type === "color") {
            const d = uc(a), m = uc(u);
            for (let S = e; S < n; S++) this.paintVertexArray.emplace(S, d[0], d[1], m[0], m[1]);
          } else {
            for (let d = e; d < n; d++) this.paintVertexArray.emplace(d, a, u);
            this.maxValue = Math.max(this.maxValue, Math.abs(a), Math.abs(u));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(e, n) {
          const a = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, u = Kt(this.expression.interpolationFactor(a, this.zoom, this.zoom + 1), 0, 1);
          e.set(u);
        }
        getBinding(e, n, a) {
          return new Gl(e, n);
        }
      }
      class En {
        constructor(e, n, a, u, d, m) {
          this.expression = e, this.type = n, this.useIntegerZoom = a, this.zoom = u, this.layerId = m, this.zoomInPaintVertexArray = new d(), this.zoomOutPaintVertexArray = new d();
        }
        populatePaintArray(e, n, a) {
          const u = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(u, e, n.patterns && n.patterns[this.layerId], a);
        }
        updatePaintArray(e, n, a, u, d) {
          this._setPaintValues(e, n, a.patterns && a.patterns[this.layerId], d);
        }
        _setPaintValues(e, n, a, u) {
          if (!u || !a) return;
          const { min: d, mid: m, max: S } = a, I = u[d], C = u[m], N = u[S];
          if (I && C && N) for (let D = e; D < n; D++) this.zoomInPaintVertexArray.emplace(D, C.tl[0], C.tl[1], C.br[0], C.br[1], I.tl[0], I.tl[1], I.br[0], I.br[1], C.pixelRatio, I.pixelRatio), this.zoomOutPaintVertexArray.emplace(D, C.tl[0], C.tl[1], C.br[0], C.br[1], N.tl[0], N.tl[1], N.br[0], N.br[1], C.pixelRatio, N.pixelRatio);
        }
        upload(e) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, pa.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, pa.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class Rc {
        constructor(e, n, a) {
          this.binders = {}, this._buffers = [];
          const u = [];
          for (const d in e.paint._values) {
            if (!a(d)) continue;
            const m = e.paint.get(d);
            if (!(m instanceof hs && ns(m.property.specification))) continue;
            const S = Xh(d, e.type), I = m.value, C = m.property.specification.type, N = m.property.useIntegerZoom, D = m.property.specification["property-type"], G = D === "cross-faded" || D === "cross-faded-data-driven";
            if (I.kind === "constant") this.binders[d] = G ? new Fa(I.value, S) : new Wl(I.value, S, C), u.push(`/u_${d}`);
            else if (I.kind === "source" || G) {
              const W = Oc(d, C, "source");
              this.binders[d] = G ? new En(I, C, N, n, W, e.id) : new fa(I, S, C, W), u.push(`/a_${d}`);
            } else {
              const W = Oc(d, C, "composite");
              this.binders[d] = new us(I, S, C, N, n, W), u.push(`/z_${d}`);
            }
          }
          this.cacheKey = u.sort().join("");
        }
        getMaxValue(e) {
          const n = this.binders[e];
          return n instanceof fa || n instanceof us ? n.maxValue : 0;
        }
        populatePaintArrays(e, n, a, u, d) {
          for (const m in this.binders) {
            const S = this.binders[m];
            (S instanceof fa || S instanceof us || S instanceof En) && S.populatePaintArray(e, n, a, u, d);
          }
        }
        setConstantPatternPositions(e, n) {
          for (const a in this.binders) {
            const u = this.binders[a];
            u instanceof Fa && u.setConstantPatternPositions(e, n);
          }
        }
        updatePaintArrays(e, n, a, u, d) {
          let m = !1;
          for (const S in e) {
            const I = n.getPositions(S);
            for (const C of I) {
              const N = a.feature(C.index);
              for (const D in this.binders) {
                const G = this.binders[D];
                if ((G instanceof fa || G instanceof us || G instanceof En) && G.expression.isStateDependent === !0) {
                  const W = u.paint.get(D);
                  G.expression = W.value, G.updatePaintArray(C.start, C.end, N, e[S], d), m = !0;
                }
              }
            }
          }
          return m;
        }
        defines() {
          const e = [];
          for (const n in this.binders) {
            const a = this.binders[n];
            (a instanceof Wl || a instanceof Fa) && e.push(...a.uniformNames.map((u) => `#define HAS_UNIFORM_${u}`));
          }
          return e;
        }
        getBinderAttributes() {
          const e = [];
          for (const n in this.binders) {
            const a = this.binders[n];
            if (a instanceof fa || a instanceof us) for (let u = 0; u < a.paintVertexAttributes.length; u++) e.push(a.paintVertexAttributes[u].name);
            else if (a instanceof En) for (let u = 0; u < pa.members.length; u++) e.push(pa.members[u].name);
          }
          return e;
        }
        getBinderUniforms() {
          const e = [];
          for (const n in this.binders) {
            const a = this.binders[n];
            if (a instanceof Wl || a instanceof Fa || a instanceof us) for (const u of a.uniformNames) e.push(u);
          }
          return e;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(e, n) {
          const a = [];
          for (const u in this.binders) {
            const d = this.binders[u];
            if (d instanceof Wl || d instanceof Fa || d instanceof us) {
              for (const m of d.uniformNames) if (n[m]) {
                const S = d.getBinding(e, n[m], m);
                a.push({ name: m, property: u, binding: S });
              }
            }
          }
          return a;
        }
        setUniforms(e, n, a, u) {
          for (const { name: d, property: m, binding: S } of n) this.binders[m].setUniform(S, u, a.get(m), d);
        }
        updatePaintBuffers(e) {
          this._buffers = [];
          for (const n in this.binders) {
            const a = this.binders[n];
            if (e && a instanceof En) {
              const u = e.fromScale === 2 ? a.zoomInPaintVertexBuffer : a.zoomOutPaintVertexBuffer;
              u && this._buffers.push(u);
            } else (a instanceof fa || a instanceof us) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer);
          }
        }
        upload(e) {
          for (const n in this.binders) {
            const a = this.binders[n];
            (a instanceof fa || a instanceof us || a instanceof En) && a.upload(e);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const e in this.binders) {
            const n = this.binders[e];
            (n instanceof fa || n instanceof us || n instanceof En) && n.destroy();
          }
        }
      }
      class wo {
        constructor(e, n, a = () => !0) {
          this.programConfigurations = {};
          for (const u of e) this.programConfigurations[u.id] = new Rc(u, n, a);
          this.needsUpload = !1, this._featureMap = new el(), this._bufferOffset = 0;
        }
        populatePaintArrays(e, n, a, u, d, m) {
          for (const S in this.programConfigurations) this.programConfigurations[S].populatePaintArrays(e, n, u, d, m);
          n.id !== void 0 && this._featureMap.add(n.id, a, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0;
        }
        updatePaintArrays(e, n, a, u) {
          for (const d of a) this.needsUpload = this.programConfigurations[d.id].updatePaintArrays(e, this._featureMap, n, d, u) || this.needsUpload;
        }
        get(e) {
          return this.programConfigurations[e];
        }
        upload(e) {
          if (this.needsUpload) {
            for (const n in this.programConfigurations) this.programConfigurations[n].upload(e);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
        }
      }
      function Xh(i, e) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[i] || [i.replace(`${e}-`, "").replace(/-/g, "_")];
      }
      function Oc(i, e, n) {
        const a = { color: { source: q, composite: Oe }, number: { source: ce, composite: q } }, u = function(d) {
          return { "line-pattern": { source: Mn, composite: Mn }, "fill-pattern": { source: Mn, composite: Mn }, "fill-extrusion-pattern": { source: Mn, composite: Mn } }[d];
        }(i);
        return u && u[n] || a[e][n];
      }
      De("ConstantBinder", Wl), De("CrossFadedConstantBinder", Fa), De("SourceExpressionBinder", fa), De("CrossFadedCompositeBinder", En), De("CompositeExpressionBinder", us), De("ProgramConfiguration", Rc, { omit: ["_buffers"] }), De("ProgramConfigurationSet", wo);
      const ir = 8192, jc = Math.pow(2, 14) - 1, qc = -jc - 1;
      function rl(i) {
        const e = ir / i.extent, n = i.loadGeometry();
        for (let a = 0; a < n.length; a++) {
          const u = n[a];
          for (let d = 0; d < u.length; d++) {
            const m = u[d], S = Math.round(m.x * e), I = Math.round(m.y * e);
            m.x = Kt(S, qc, jc), m.y = Kt(I, qc, jc), (S < m.x || S > m.x + 1 || I < m.y || I > m.y + 1) && It("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return n;
      }
      function So(i, e) {
        return { type: i.type, id: i.id, properties: i.properties, geometry: e ? rl(i) : [] };
      }
      function dc(i, e, n, a, u) {
        i.emplaceBack(2 * e + (a + 1) / 2, 2 * n + (u + 1) / 2);
      }
      class nl {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new xr(), this.indexArray = new rn(), this.segments = new Li(), this.programConfigurations = new wo(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(e, n, a) {
          const u = this.layers[0], d = [];
          let m = null, S = !1;
          u.type === "circle" && (m = u.layout.get("circle-sort-key"), S = !m.isConstant());
          for (const { feature: I, id: C, index: N, sourceLayerIndex: D } of e) {
            const G = this.layers[0]._featureFilter.needGeometry, W = So(I, G);
            if (!this.layers[0]._featureFilter.filter(new Xi(this.zoom), W, a)) continue;
            const J = S ? m.evaluate(W, {}, a) : void 0, rt = { id: C, properties: I.properties, type: I.type, sourceLayerIndex: D, index: N, geometry: G ? W.geometry : rl(I), patterns: {}, sortKey: J };
            d.push(rt);
          }
          S && d.sort((I, C) => I.sortKey - C.sortKey);
          for (const I of d) {
            const { geometry: C, index: N, sourceLayerIndex: D } = I, G = e[N].feature;
            this.addFeature(I, C, N, a), n.featureIndex.insert(G, C, N, D, this.index);
          }
        }
        update(e, n, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, n, this.stateDependentLayers, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, nn), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(e, n, a, u) {
          for (const d of n) for (const m of d) {
            const S = m.x, I = m.y;
            if (S < 0 || S >= ir || I < 0 || I >= ir) continue;
            const C = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), N = C.vertexLength;
            dc(this.layoutVertexArray, S, I, -1, -1), dc(this.layoutVertexArray, S, I, 1, -1), dc(this.layoutVertexArray, S, I, 1, 1), dc(this.layoutVertexArray, S, I, -1, 1), this.indexArray.emplaceBack(N, N + 1, N + 2), this.indexArray.emplaceBack(N, N + 3, N + 2), C.vertexLength += 4, C.primitiveLength += 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, {}, u);
        }
      }
      function pc(i, e) {
        for (let n = 0; n < i.length; n++) if (Po(e, i[n])) return !0;
        for (let n = 0; n < e.length; n++) if (Po(i, e[n])) return !0;
        return !!ga(i, e);
      }
      function fc(i, e, n) {
        return !!Po(i, e) || !!Xl(e, i, n);
      }
      function ma(i, e) {
        if (i.length === 1) return fh(e, i[0]);
        for (let n = 0; n < e.length; n++) {
          const a = e[n];
          for (let u = 0; u < a.length; u++) if (Po(i, a[u])) return !0;
        }
        for (let n = 0; n < i.length; n++) if (fh(e, i[n])) return !0;
        for (let n = 0; n < e.length; n++) if (ga(i, e[n])) return !0;
        return !1;
      }
      function Ao(i, e, n) {
        if (i.length > 1) {
          if (ga(i, e)) return !0;
          for (let a = 0; a < e.length; a++) if (Xl(e[a], i, n)) return !0;
        }
        for (let a = 0; a < i.length; a++) if (Xl(i[a], e, n)) return !0;
        return !1;
      }
      function ga(i, e) {
        if (i.length === 0 || e.length === 0) return !1;
        for (let n = 0; n < i.length - 1; n++) {
          const a = i[n], u = i[n + 1];
          for (let d = 0; d < e.length - 1; d++) if (mc(a, u, e[d], e[d + 1])) return !0;
        }
        return !1;
      }
      function mc(i, e, n, a) {
        return St(i, n, a) !== St(e, n, a) && St(i, e, n) !== St(i, e, a);
      }
      function Xl(i, e, n) {
        const a = n * n;
        if (e.length === 1) return i.distSqr(e[0]) < a;
        for (let u = 1; u < e.length; u++) if (Uc(i, e[u - 1], e[u]) < a) return !0;
        return !1;
      }
      function Uc(i, e, n) {
        const a = e.distSqr(n);
        if (a === 0) return i.distSqr(e);
        const u = ((i.x - e.x) * (n.x - e.x) + (i.y - e.y) * (n.y - e.y)) / a;
        return i.distSqr(u < 0 ? e : u > 1 ? n : n.sub(e)._mult(u)._add(e));
      }
      function fh(i, e) {
        let n, a, u, d = !1;
        for (let m = 0; m < i.length; m++) {
          n = i[m];
          for (let S = 0, I = n.length - 1; S < n.length; I = S++) a = n[S], u = n[I], a.y > e.y != u.y > e.y && e.x < (u.x - a.x) * (e.y - a.y) / (u.y - a.y) + a.x && (d = !d);
        }
        return d;
      }
      function Po(i, e) {
        let n = !1;
        for (let a = 0, u = i.length - 1; a < i.length; u = a++) {
          const d = i[a], m = i[u];
          d.y > e.y != m.y > e.y && e.x < (m.x - d.x) * (e.y - d.y) / (m.y - d.y) + d.x && (n = !n);
        }
        return n;
      }
      function Vc(i, e, n) {
        const a = n[0], u = n[2];
        if (i.x < a.x && e.x < a.x || i.x > u.x && e.x > u.x || i.y < a.y && e.y < a.y || i.y > u.y && e.y > u.y) return !1;
        const d = St(i, e, n[0]);
        return d !== St(i, e, n[1]) || d !== St(i, e, n[2]) || d !== St(i, e, n[3]);
      }
      function Gc(i, e, n) {
        const a = e.paint.get(i).value;
        return a.kind === "constant" ? a.value : n.programConfigurations.get(e.id).getMaxValue(i);
      }
      function mh(i) {
        return Math.sqrt(i[0] * i[0] + i[1] * i[1]);
      }
      function gh(i, e, n, a, u) {
        if (!e[0] && !e[1]) return i;
        const d = O.convert(e)._mult(u);
        n === "viewport" && d._rotate(-a);
        const m = [];
        for (let S = 0; S < i.length; S++) m.push(i[S].sub(d));
        return m;
      }
      let ed, id;
      De("CircleBucket", nl, { omit: ["layers"] });
      var Sf = { get paint() {
        return id = id || new o({ "circle-radius": new Qe(Y.paint_circle["circle-radius"]), "circle-color": new Qe(Y.paint_circle["circle-color"]), "circle-blur": new Qe(Y.paint_circle["circle-blur"]), "circle-opacity": new Qe(Y.paint_circle["circle-opacity"]), "circle-translate": new je(Y.paint_circle["circle-translate"]), "circle-translate-anchor": new je(Y.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new je(Y.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new je(Y.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Qe(Y.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Qe(Y.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Qe(Y.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return ed = ed || new o({ "circle-sort-key": new Qe(Y.layout_circle["circle-sort-key"]) });
      } }, Un = 1e-6, gc = typeof Float32Array < "u" ? Float32Array : Array;
      function Hh(i) {
        return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }
      function rd(i, e, n) {
        var a = e[0], u = e[1], d = e[2], m = e[3], S = e[4], I = e[5], C = e[6], N = e[7], D = e[8], G = e[9], W = e[10], J = e[11], rt = e[12], dt = e[13], vt = e[14], Dt = e[15], Lt = n[0], Nt = n[1], Zt = n[2], ge = n[3];
        return i[0] = Lt * a + Nt * S + Zt * D + ge * rt, i[1] = Lt * u + Nt * I + Zt * G + ge * dt, i[2] = Lt * d + Nt * C + Zt * W + ge * vt, i[3] = Lt * m + Nt * N + Zt * J + ge * Dt, i[4] = (Lt = n[4]) * a + (Nt = n[5]) * S + (Zt = n[6]) * D + (ge = n[7]) * rt, i[5] = Lt * u + Nt * I + Zt * G + ge * dt, i[6] = Lt * d + Nt * C + Zt * W + ge * vt, i[7] = Lt * m + Nt * N + Zt * J + ge * Dt, i[8] = (Lt = n[8]) * a + (Nt = n[9]) * S + (Zt = n[10]) * D + (ge = n[11]) * rt, i[9] = Lt * u + Nt * I + Zt * G + ge * dt, i[10] = Lt * d + Nt * C + Zt * W + ge * vt, i[11] = Lt * m + Nt * N + Zt * J + ge * Dt, i[12] = (Lt = n[12]) * a + (Nt = n[13]) * S + (Zt = n[14]) * D + (ge = n[15]) * rt, i[13] = Lt * u + Nt * I + Zt * G + ge * dt, i[14] = Lt * d + Nt * C + Zt * W + ge * vt, i[15] = Lt * m + Nt * N + Zt * J + ge * Dt, i;
      }
      Math.hypot || (Math.hypot = function() {
        for (var i = 0, e = arguments.length; e--; ) i += arguments[e] * arguments[e];
        return Math.sqrt(i);
      });
      var $c, Af = rd;
      function yh(i, e, n) {
        var a = e[0], u = e[1], d = e[2], m = e[3];
        return i[0] = n[0] * a + n[4] * u + n[8] * d + n[12] * m, i[1] = n[1] * a + n[5] * u + n[9] * d + n[13] * m, i[2] = n[2] * a + n[6] * u + n[10] * d + n[14] * m, i[3] = n[3] * a + n[7] * u + n[11] * d + n[15] * m, i;
      }
      $c = new gc(4), gc != Float32Array && ($c[0] = 0, $c[1] = 0, $c[2] = 0, $c[3] = 0);
      class Pf extends r {
        constructor(e) {
          super(e, Sf);
        }
        createBucket(e) {
          return new nl(e);
        }
        queryRadius(e) {
          const n = e;
          return Gc("circle-radius", this, n) + Gc("circle-stroke-width", this, n) + mh(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(e, n, a, u, d, m, S, I) {
          const C = gh(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), m.angle, S), N = this.paint.get("circle-radius").evaluate(n, a) + this.paint.get("circle-stroke-width").evaluate(n, a), D = this.paint.get("circle-pitch-alignment") === "map", G = D ? C : function(J, rt) {
            return J.map((dt) => nd(dt, rt));
          }(C, I), W = D ? N * S : N;
          for (const J of u) for (const rt of J) {
            const dt = D ? rt : nd(rt, I);
            let vt = W;
            const Dt = yh([], [rt.x, rt.y, 0, 1], I);
            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? vt *= Dt[3] / m.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (vt *= m.cameraToCenterDistance / Dt[3]), fc(G, dt, vt)) return !0;
          }
          return !1;
        }
      }
      function nd(i, e) {
        const n = yh([], [i.x, i.y, 0, 1], e);
        return new O(n[0] / n[3], n[1] / n[3]);
      }
      class sd extends nl {
      }
      let ad;
      De("HeatmapBucket", sd, { omit: ["layers"] });
      var If = { get paint() {
        return ad = ad || new o({ "heatmap-radius": new Qe(Y.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Qe(Y.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new je(Y.paint_heatmap["heatmap-intensity"]), "heatmap-color": new w(Y.paint_heatmap["heatmap-color"]), "heatmap-opacity": new je(Y.paint_heatmap["heatmap-opacity"]) });
      } };
      function Yh(i, { width: e, height: n }, a, u) {
        if (u) {
          if (u instanceof Uint8ClampedArray) u = new Uint8Array(u.buffer);
          else if (u.length !== e * n * a) throw new RangeError(`mismatched image size. expected: ${u.length} but got: ${e * n * a}`);
        } else u = new Uint8Array(e * n * a);
        return i.width = e, i.height = n, i.data = u, i;
      }
      function od(i, { width: e, height: n }, a) {
        if (e === i.width && n === i.height) return;
        const u = Yh({}, { width: e, height: n }, a);
        Kh(i, u, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(i.width, e), height: Math.min(i.height, n) }, a), i.width = e, i.height = n, i.data = u.data;
      }
      function Kh(i, e, n, a, u, d) {
        if (u.width === 0 || u.height === 0) return e;
        if (u.width > i.width || u.height > i.height || n.x > i.width - u.width || n.y > i.height - u.height) throw new RangeError("out of range source coordinates for image copy");
        if (u.width > e.width || u.height > e.height || a.x > e.width - u.width || a.y > e.height - u.height) throw new RangeError("out of range destination coordinates for image copy");
        const m = i.data, S = e.data;
        if (m === S) throw new Error("srcData equals dstData, so image is already copied");
        for (let I = 0; I < u.height; I++) {
          const C = ((n.y + I) * i.width + n.x) * d, N = ((a.y + I) * e.width + a.x) * d;
          for (let D = 0; D < u.width * d; D++) S[N + D] = m[C + D];
        }
        return e;
      }
      class Zc {
        constructor(e, n) {
          Yh(this, e, 1, n);
        }
        resize(e) {
          od(this, e, 1);
        }
        clone() {
          return new Zc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, n, a, u, d) {
          Kh(e, n, a, u, d, 1);
        }
      }
      class $s {
        constructor(e, n) {
          Yh(this, e, 4, n);
        }
        resize(e) {
          od(this, e, 4);
        }
        replace(e, n) {
          n ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
        }
        clone() {
          return new $s({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, n, a, u, d) {
          Kh(e, n, a, u, d, 4);
        }
      }
      function ld(i) {
        const e = {}, n = i.resolution || 256, a = i.clips ? i.clips.length : 1, u = i.image || new $s({ width: n, height: a });
        if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
        const d = (m, S, I) => {
          e[i.evaluationKey] = I;
          const C = i.expression.evaluate(e);
          u.data[m + S + 0] = Math.floor(255 * C.r / C.a), u.data[m + S + 1] = Math.floor(255 * C.g / C.a), u.data[m + S + 2] = Math.floor(255 * C.b / C.a), u.data[m + S + 3] = Math.floor(255 * C.a);
        };
        if (i.clips) for (let m = 0, S = 0; m < a; ++m, S += 4 * n) for (let I = 0, C = 0; I < n; I++, C += 4) {
          const N = I / (n - 1), { start: D, end: G } = i.clips[m];
          d(S, C, D * (1 - N) + G * N);
        }
        else for (let m = 0, S = 0; m < n; m++, S += 4) d(0, S, m / (n - 1));
        return u;
      }
      De("AlphaImage", Zc), De("RGBAImage", $s);
      const Jh = "big-fb";
      class kf extends r {
        createBucket(e) {
          return new sd(e);
        }
        constructor(e) {
          super(e, If), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(e) {
          e === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = ld({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(Jh) && this.heatmapFbos.delete(Jh);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let cd;
      var Tf = { get paint() {
        return cd = cd || new o({ "hillshade-illumination-direction": new je(Y.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new je(Y.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new je(Y.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new je(Y.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new je(Y.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new je(Y.paint_hillshade["hillshade-accent-color"]) });
      } };
      class Lf extends r {
        constructor(e) {
          super(e, Tf);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const Cf = g([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Mf } = Cf;
      function hd(i, e, n = 2) {
        const a = e && e.length, u = a ? e[0] * n : i.length;
        let d = ud(i, 0, u, n, !0);
        const m = [];
        if (!d || d.next === d.prev) return m;
        let S, I, C;
        if (a && (d = function(N, D, G, W) {
          const J = [];
          for (let rt = 0, dt = D.length; rt < dt; rt++) {
            const vt = ud(N, D[rt] * W, rt < dt - 1 ? D[rt + 1] * W : N.length, W, !1);
            vt === vt.next && (vt.steiner = !0), J.push(Of(vt));
          }
          J.sort(Ff);
          for (let rt = 0; rt < J.length; rt++) G = Bf(J[rt], G);
          return G;
        }(i, e, d, n)), i.length > 80 * n) {
          S = 1 / 0, I = 1 / 0;
          let N = -1 / 0, D = -1 / 0;
          for (let G = n; G < u; G += n) {
            const W = i[G], J = i[G + 1];
            W < S && (S = W), J < I && (I = J), W > N && (N = W), J > D && (D = J);
          }
          C = Math.max(N - S, D - I), C = C !== 0 ? 32767 / C : 0;
        }
        return Wc(d, m, n, S, I, C, 0), m;
      }
      function ud(i, e, n, a, u) {
        let d;
        if (u === function(m, S, I, C) {
          let N = 0;
          for (let D = S, G = I - C; D < I; D += C) N += (m[G] - m[D]) * (m[D + 1] + m[G + 1]), G = D;
          return N;
        }(i, e, n, a) > 0) for (let m = e; m < n; m += a) d = fd(m / a | 0, i[m], i[m + 1], d);
        else for (let m = n - a; m >= e; m -= a) d = fd(m / a | 0, i[m], i[m + 1], d);
        return d && _h(d, d.next) && (Hc(d), d = d.next), d;
      }
      function Hl(i, e) {
        if (!i) return i;
        e || (e = i);
        let n, a = i;
        do
          if (n = !1, a.steiner || !_h(a, a.next) && Cr(a.prev, a, a.next) !== 0) a = a.next;
          else {
            if (Hc(a), a = e = a.prev, a === a.next) break;
            n = !0;
          }
        while (n || a !== e);
        return e;
      }
      function Wc(i, e, n, a, u, d, m) {
        if (!i) return;
        !m && d && function(I, C, N, D) {
          let G = I;
          do
            G.z === 0 && (G.z = Qh(G.x, G.y, C, N, D)), G.prevZ = G.prev, G.nextZ = G.next, G = G.next;
          while (G !== I);
          G.prevZ.nextZ = null, G.prevZ = null, function(W) {
            let J, rt = 1;
            do {
              let dt, vt = W;
              W = null;
              let Dt = null;
              for (J = 0; vt; ) {
                J++;
                let Lt = vt, Nt = 0;
                for (let ge = 0; ge < rt && (Nt++, Lt = Lt.nextZ, Lt); ge++) ;
                let Zt = rt;
                for (; Nt > 0 || Zt > 0 && Lt; ) Nt !== 0 && (Zt === 0 || !Lt || vt.z <= Lt.z) ? (dt = vt, vt = vt.nextZ, Nt--) : (dt = Lt, Lt = Lt.nextZ, Zt--), Dt ? Dt.nextZ = dt : W = dt, dt.prevZ = Dt, Dt = dt;
                vt = Lt;
              }
              Dt.nextZ = null, rt *= 2;
            } while (J > 1);
          }(G);
        }(i, a, u, d);
        let S = i;
        for (; i.prev !== i.next; ) {
          const I = i.prev, C = i.next;
          if (d ? zf(i, a, u, d) : Ef(i)) e.push(I.i, i.i, C.i), Hc(i), i = C.next, S = C.next;
          else if ((i = C) === S) {
            m ? m === 1 ? Wc(i = Nf(Hl(i), e), e, n, a, u, d, 2) : m === 2 && Df(i, e, n, a, u, d) : Wc(Hl(i), e, n, a, u, d, 1);
            break;
          }
        }
      }
      function Ef(i) {
        const e = i.prev, n = i, a = i.next;
        if (Cr(e, n, a) >= 0) return !1;
        const u = e.x, d = n.x, m = a.x, S = e.y, I = n.y, C = a.y, N = u < d ? u < m ? u : m : d < m ? d : m, D = S < I ? S < C ? S : C : I < C ? I : C, G = u > d ? u > m ? u : m : d > m ? d : m, W = S > I ? S > C ? S : C : I > C ? I : C;
        let J = a.next;
        for (; J !== e; ) {
          if (J.x >= N && J.x <= G && J.y >= D && J.y <= W && yc(u, S, d, I, m, C, J.x, J.y) && Cr(J.prev, J, J.next) >= 0) return !1;
          J = J.next;
        }
        return !0;
      }
      function zf(i, e, n, a) {
        const u = i.prev, d = i, m = i.next;
        if (Cr(u, d, m) >= 0) return !1;
        const S = u.x, I = d.x, C = m.x, N = u.y, D = d.y, G = m.y, W = S < I ? S < C ? S : C : I < C ? I : C, J = N < D ? N < G ? N : G : D < G ? D : G, rt = S > I ? S > C ? S : C : I > C ? I : C, dt = N > D ? N > G ? N : G : D > G ? D : G, vt = Qh(W, J, e, n, a), Dt = Qh(rt, dt, e, n, a);
        let Lt = i.prevZ, Nt = i.nextZ;
        for (; Lt && Lt.z >= vt && Nt && Nt.z <= Dt; ) {
          if (Lt.x >= W && Lt.x <= rt && Lt.y >= J && Lt.y <= dt && Lt !== u && Lt !== m && yc(S, N, I, D, C, G, Lt.x, Lt.y) && Cr(Lt.prev, Lt, Lt.next) >= 0 || (Lt = Lt.prevZ, Nt.x >= W && Nt.x <= rt && Nt.y >= J && Nt.y <= dt && Nt !== u && Nt !== m && yc(S, N, I, D, C, G, Nt.x, Nt.y) && Cr(Nt.prev, Nt, Nt.next) >= 0)) return !1;
          Nt = Nt.nextZ;
        }
        for (; Lt && Lt.z >= vt; ) {
          if (Lt.x >= W && Lt.x <= rt && Lt.y >= J && Lt.y <= dt && Lt !== u && Lt !== m && yc(S, N, I, D, C, G, Lt.x, Lt.y) && Cr(Lt.prev, Lt, Lt.next) >= 0) return !1;
          Lt = Lt.prevZ;
        }
        for (; Nt && Nt.z <= Dt; ) {
          if (Nt.x >= W && Nt.x <= rt && Nt.y >= J && Nt.y <= dt && Nt !== u && Nt !== m && yc(S, N, I, D, C, G, Nt.x, Nt.y) && Cr(Nt.prev, Nt, Nt.next) >= 0) return !1;
          Nt = Nt.nextZ;
        }
        return !0;
      }
      function Nf(i, e) {
        let n = i;
        do {
          const a = n.prev, u = n.next.next;
          !_h(a, u) && dd(a, n, n.next, u) && Xc(a, u) && Xc(u, a) && (e.push(a.i, n.i, u.i), Hc(n), Hc(n.next), n = i = u), n = n.next;
        } while (n !== i);
        return Hl(n);
      }
      function Df(i, e, n, a, u, d) {
        let m = i;
        do {
          let S = m.next.next;
          for (; S !== m.prev; ) {
            if (m.i !== S.i && jf(m, S)) {
              let I = pd(m, S);
              return m = Hl(m, m.next), I = Hl(I, I.next), Wc(m, e, n, a, u, d, 0), void Wc(I, e, n, a, u, d, 0);
            }
            S = S.next;
          }
          m = m.next;
        } while (m !== i);
      }
      function Ff(i, e) {
        return i.x - e.x;
      }
      function Bf(i, e) {
        const n = function(u, d) {
          let m = d;
          const S = u.x, I = u.y;
          let C, N = -1 / 0;
          do {
            if (I <= m.y && I >= m.next.y && m.next.y !== m.y) {
              const rt = m.x + (I - m.y) * (m.next.x - m.x) / (m.next.y - m.y);
              if (rt <= S && rt > N && (N = rt, C = m.x < m.next.x ? m : m.next, rt === S)) return C;
            }
            m = m.next;
          } while (m !== d);
          if (!C) return null;
          const D = C, G = C.x, W = C.y;
          let J = 1 / 0;
          m = C;
          do {
            if (S >= m.x && m.x >= G && S !== m.x && yc(I < W ? S : N, I, G, W, I < W ? N : S, I, m.x, m.y)) {
              const rt = Math.abs(I - m.y) / (S - m.x);
              Xc(m, u) && (rt < J || rt === J && (m.x > C.x || m.x === C.x && Rf(C, m))) && (C = m, J = rt);
            }
            m = m.next;
          } while (m !== D);
          return C;
        }(i, e);
        if (!n) return e;
        const a = pd(n, i);
        return Hl(a, a.next), Hl(n, n.next);
      }
      function Rf(i, e) {
        return Cr(i.prev, i, e.prev) < 0 && Cr(e.next, i, i.next) < 0;
      }
      function Qh(i, e, n, a, u) {
        return (i = 1431655765 & ((i = 858993459 & ((i = 252645135 & ((i = 16711935 & ((i = (i - n) * u | 0) | i << 8)) | i << 4)) | i << 2)) | i << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - a) * u | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
      }
      function Of(i) {
        let e = i, n = i;
        do
          (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
        while (e !== i);
        return n;
      }
      function yc(i, e, n, a, u, d, m, S) {
        return (u - m) * (e - S) >= (i - m) * (d - S) && (i - m) * (a - S) >= (n - m) * (e - S) && (n - m) * (d - S) >= (u - m) * (a - S);
      }
      function jf(i, e) {
        return i.next.i !== e.i && i.prev.i !== e.i && !function(n, a) {
          let u = n;
          do {
            if (u.i !== n.i && u.next.i !== n.i && u.i !== a.i && u.next.i !== a.i && dd(u, u.next, n, a)) return !0;
            u = u.next;
          } while (u !== n);
          return !1;
        }(i, e) && (Xc(i, e) && Xc(e, i) && function(n, a) {
          let u = n, d = !1;
          const m = (n.x + a.x) / 2, S = (n.y + a.y) / 2;
          do
            u.y > S != u.next.y > S && u.next.y !== u.y && m < (u.next.x - u.x) * (S - u.y) / (u.next.y - u.y) + u.x && (d = !d), u = u.next;
          while (u !== n);
          return d;
        }(i, e) && (Cr(i.prev, i, e.prev) || Cr(i, e.prev, e)) || _h(i, e) && Cr(i.prev, i, i.next) > 0 && Cr(e.prev, e, e.next) > 0);
      }
      function Cr(i, e, n) {
        return (e.y - i.y) * (n.x - e.x) - (e.x - i.x) * (n.y - e.y);
      }
      function _h(i, e) {
        return i.x === e.x && i.y === e.y;
      }
      function dd(i, e, n, a) {
        const u = xh(Cr(i, e, n)), d = xh(Cr(i, e, a)), m = xh(Cr(n, a, i)), S = xh(Cr(n, a, e));
        return u !== d && m !== S || !(u !== 0 || !vh(i, n, e)) || !(d !== 0 || !vh(i, a, e)) || !(m !== 0 || !vh(n, i, a)) || !(S !== 0 || !vh(n, e, a));
      }
      function vh(i, e, n) {
        return e.x <= Math.max(i.x, n.x) && e.x >= Math.min(i.x, n.x) && e.y <= Math.max(i.y, n.y) && e.y >= Math.min(i.y, n.y);
      }
      function xh(i) {
        return i > 0 ? 1 : i < 0 ? -1 : 0;
      }
      function Xc(i, e) {
        return Cr(i.prev, i, i.next) < 0 ? Cr(i, e, i.next) >= 0 && Cr(i, i.prev, e) >= 0 : Cr(i, e, i.prev) < 0 || Cr(i, i.next, e) < 0;
      }
      function pd(i, e) {
        const n = tu(i.i, i.x, i.y), a = tu(e.i, e.x, e.y), u = i.next, d = e.prev;
        return i.next = e, e.prev = i, n.next = u, u.prev = n, a.next = n, n.prev = a, d.next = a, a.prev = d, a;
      }
      function fd(i, e, n, a) {
        const u = tu(i, e, n);
        return a ? (u.next = a.next, u.prev = a, a.next.prev = u, a.next = u) : (u.prev = u, u.next = u), u;
      }
      function Hc(i) {
        i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
      }
      function tu(i, e, n) {
        return { i, x: e, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      function eu(i, e, n) {
        const a = n.patternDependencies;
        let u = !1;
        for (const d of e) {
          const m = d.paint.get(`${i}-pattern`);
          m.isConstant() || (u = !0);
          const S = m.constantOr(null);
          S && (u = !0, a[S.to] = !0, a[S.from] = !0);
        }
        return u;
      }
      function iu(i, e, n, a, u) {
        const d = u.patternDependencies;
        for (const m of e) {
          const S = m.paint.get(`${i}-pattern`).value;
          if (S.kind !== "constant") {
            let I = S.evaluate({ zoom: a - 1 }, n, {}, u.availableImages), C = S.evaluate({ zoom: a }, n, {}, u.availableImages), N = S.evaluate({ zoom: a + 1 }, n, {}, u.availableImages);
            I = I && I.name ? I.name : I, C = C && C.name ? C.name : C, N = N && N.name ? N.name : N, d[I] = !0, d[C] = !0, d[N] = !0, n.patterns[m.id] = { min: I, mid: C, max: N };
          }
        }
        return n;
      }
      class ru {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new dn(), this.indexArray = new rn(), this.indexArray2 = new yr(), this.programConfigurations = new wo(e.layers, e.zoom), this.segments = new Li(), this.segments2 = new Li(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(e, n, a) {
          this.hasPattern = eu("fill", this.layers, n);
          const u = this.layers[0].layout.get("fill-sort-key"), d = !u.isConstant(), m = [];
          for (const { feature: S, id: I, index: C, sourceLayerIndex: N } of e) {
            const D = this.layers[0]._featureFilter.needGeometry, G = So(S, D);
            if (!this.layers[0]._featureFilter.filter(new Xi(this.zoom), G, a)) continue;
            const W = d ? u.evaluate(G, {}, a, n.availableImages) : void 0, J = { id: I, properties: S.properties, type: S.type, sourceLayerIndex: N, index: C, geometry: D ? G.geometry : rl(S), patterns: {}, sortKey: W };
            m.push(J);
          }
          d && m.sort((S, I) => S.sortKey - I.sortKey);
          for (const S of m) {
            const { geometry: I, index: C, sourceLayerIndex: N } = S;
            if (this.hasPattern) {
              const D = iu("fill", this.layers, S, this.zoom, n);
              this.patternFeatures.push(D);
            } else this.addFeature(S, I, C, a, {});
            n.featureIndex.insert(e[C].feature, I, C, N, this.index);
          }
        }
        update(e, n, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, n, this.stateDependentLayers, a);
        }
        addFeatures(e, n, a) {
          for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, n, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Mf), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(e, n, a, u, d) {
          for (const m of ys(n, 500)) {
            let S = 0;
            for (const W of m) S += W.length;
            const I = this.segments.prepareSegment(S, this.layoutVertexArray, this.indexArray), C = I.vertexLength, N = [], D = [];
            for (const W of m) {
              if (W.length === 0) continue;
              W !== m[0] && D.push(N.length / 2);
              const J = this.segments2.prepareSegment(W.length, this.layoutVertexArray, this.indexArray2), rt = J.vertexLength;
              this.layoutVertexArray.emplaceBack(W[0].x, W[0].y), this.indexArray2.emplaceBack(rt + W.length - 1, rt), N.push(W[0].x), N.push(W[0].y);
              for (let dt = 1; dt < W.length; dt++) this.layoutVertexArray.emplaceBack(W[dt].x, W[dt].y), this.indexArray2.emplaceBack(rt + dt - 1, rt + dt), N.push(W[dt].x), N.push(W[dt].y);
              J.vertexLength += W.length, J.primitiveLength += W.length;
            }
            const G = hd(N, D);
            for (let W = 0; W < G.length; W += 3) this.indexArray.emplaceBack(C + G[W], C + G[W + 1], C + G[W + 2]);
            I.vertexLength += S, I.primitiveLength += G.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, d, u);
        }
      }
      let md, gd;
      De("FillBucket", ru, { omit: ["layers", "patternFeatures"] });
      var qf = { get paint() {
        return gd = gd || new o({ "fill-antialias": new je(Y.paint_fill["fill-antialias"]), "fill-opacity": new Qe(Y.paint_fill["fill-opacity"]), "fill-color": new Qe(Y.paint_fill["fill-color"]), "fill-outline-color": new Qe(Y.paint_fill["fill-outline-color"]), "fill-translate": new je(Y.paint_fill["fill-translate"]), "fill-translate-anchor": new je(Y.paint_fill["fill-translate-anchor"]), "fill-pattern": new Qo(Y.paint_fill["fill-pattern"]) });
      }, get layout() {
        return md = md || new o({ "fill-sort-key": new Qe(Y.layout_fill["fill-sort-key"]) });
      } };
      class Uf extends r {
        constructor(e) {
          super(e, qf);
        }
        recalculate(e, n) {
          super.recalculate(e, n);
          const a = this.paint._values["fill-outline-color"];
          a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(e) {
          return new ru(e);
        }
        queryRadius() {
          return mh(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(e, n, a, u, d, m, S) {
          return ma(gh(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), m.angle, S), u);
        }
        isTileClipped() {
          return !0;
        }
      }
      const Vf = g([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Gf = g([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: $f } = Vf;
      var bl = {}, Zf = U, yd = _c;
      function _c(i, e, n, a, u) {
        this.properties = {}, this.extent = n, this.type = 0, this._pbf = i, this._geometry = -1, this._keys = a, this._values = u, i.readFields(Wf, this, e);
      }
      function Wf(i, e, n) {
        i == 1 ? e.id = n.readVarint() : i == 2 ? function(a, u) {
          for (var d = a.readVarint() + a.pos; a.pos < d; ) {
            var m = u._keys[a.readVarint()], S = u._values[a.readVarint()];
            u.properties[m] = S;
          }
        }(n, e) : i == 3 ? e.type = n.readVarint() : i == 4 && (e._geometry = n.pos);
      }
      function Xf(i) {
        for (var e, n, a = 0, u = 0, d = i.length, m = d - 1; u < d; m = u++) a += ((n = i[m]).x - (e = i[u]).x) * (e.y + n.y);
        return a;
      }
      _c.types = ["Unknown", "Point", "LineString", "Polygon"], _c.prototype.loadGeometry = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var e, n = i.readVarint() + i.pos, a = 1, u = 0, d = 0, m = 0, S = []; i.pos < n; ) {
          if (u <= 0) {
            var I = i.readVarint();
            a = 7 & I, u = I >> 3;
          }
          if (u--, a === 1 || a === 2) d += i.readSVarint(), m += i.readSVarint(), a === 1 && (e && S.push(e), e = []), e.push(new Zf(d, m));
          else {
            if (a !== 7) throw new Error("unknown command " + a);
            e && e.push(e[0].clone());
          }
        }
        return e && S.push(e), S;
      }, _c.prototype.bbox = function() {
        var i = this._pbf;
        i.pos = this._geometry;
        for (var e = i.readVarint() + i.pos, n = 1, a = 0, u = 0, d = 0, m = 1 / 0, S = -1 / 0, I = 1 / 0, C = -1 / 0; i.pos < e; ) {
          if (a <= 0) {
            var N = i.readVarint();
            n = 7 & N, a = N >> 3;
          }
          if (a--, n === 1 || n === 2) (u += i.readSVarint()) < m && (m = u), u > S && (S = u), (d += i.readSVarint()) < I && (I = d), d > C && (C = d);
          else if (n !== 7) throw new Error("unknown command " + n);
        }
        return [m, I, S, C];
      }, _c.prototype.toGeoJSON = function(i, e, n) {
        var a, u, d = this.extent * Math.pow(2, n), m = this.extent * i, S = this.extent * e, I = this.loadGeometry(), C = _c.types[this.type];
        function N(W) {
          for (var J = 0; J < W.length; J++) {
            var rt = W[J];
            W[J] = [360 * (rt.x + m) / d - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (rt.y + S) / d) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var D = [];
            for (a = 0; a < I.length; a++) D[a] = I[a][0];
            N(I = D);
            break;
          case 2:
            for (a = 0; a < I.length; a++) N(I[a]);
            break;
          case 3:
            for (I = function(W) {
              var J = W.length;
              if (J <= 1) return [W];
              for (var rt, dt, vt = [], Dt = 0; Dt < J; Dt++) {
                var Lt = Xf(W[Dt]);
                Lt !== 0 && (dt === void 0 && (dt = Lt < 0), dt === Lt < 0 ? (rt && vt.push(rt), rt = [W[Dt]]) : rt.push(W[Dt]));
              }
              return rt && vt.push(rt), vt;
            }(I), a = 0; a < I.length; a++) for (u = 0; u < I[a].length; u++) N(I[a][u]);
        }
        I.length === 1 ? I = I[0] : C = "Multi" + C;
        var G = { type: "Feature", geometry: { type: C, coordinates: I }, properties: this.properties };
        return "id" in this && (G.id = this.id), G;
      };
      var Hf = yd, _d = vd;
      function vd(i, e) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = i, this._keys = [], this._values = [], this._features = [], i.readFields(Yf, this, e), this.length = this._features.length;
      }
      function Yf(i, e, n) {
        i === 15 ? e.version = n.readVarint() : i === 1 ? e.name = n.readString() : i === 5 ? e.extent = n.readVarint() : i === 2 ? e._features.push(n.pos) : i === 3 ? e._keys.push(n.readString()) : i === 4 && e._values.push(function(a) {
          for (var u = null, d = a.readVarint() + a.pos; a.pos < d; ) {
            var m = a.readVarint() >> 3;
            u = m === 1 ? a.readString() : m === 2 ? a.readFloat() : m === 3 ? a.readDouble() : m === 4 ? a.readVarint64() : m === 5 ? a.readVarint() : m === 6 ? a.readSVarint() : m === 7 ? a.readBoolean() : null;
          }
          return u;
        }(n));
      }
      vd.prototype.feature = function(i) {
        if (i < 0 || i >= this._features.length) throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[i];
        var e = this._pbf.readVarint() + this._pbf.pos;
        return new Hf(this._pbf, e, this.extent, this._keys, this._values);
      };
      var Kf = _d;
      function Jf(i, e, n) {
        if (i === 3) {
          var a = new Kf(n, n.readVarint() + n.pos);
          a.length && (e[a.name] = a);
        }
      }
      bl.VectorTile = function(i, e) {
        this.layers = i.readFields(Jf, {}, e);
      }, bl.VectorTileFeature = yd, bl.VectorTileLayer = _d;
      const Qf = bl.VectorTileFeature.types, nu = Math.pow(2, 13);
      function Yc(i, e, n, a, u, d, m, S) {
        i.emplaceBack(e, n, 2 * Math.floor(a * nu) + m, u * nu * 2, d * nu * 2, Math.round(S));
      }
      class su {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.id), this.index = e.index, this.hasPattern = !1, this.layoutVertexArray = new Cn(), this.centroidVertexArray = new or(), this.indexArray = new rn(), this.programConfigurations = new wo(e.layers, e.zoom), this.segments = new Li(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(e, n, a) {
          this.features = [], this.hasPattern = eu("fill-extrusion", this.layers, n);
          for (const { feature: u, id: d, index: m, sourceLayerIndex: S } of e) {
            const I = this.layers[0]._featureFilter.needGeometry, C = So(u, I);
            if (!this.layers[0]._featureFilter.filter(new Xi(this.zoom), C, a)) continue;
            const N = { id: d, sourceLayerIndex: S, index: m, geometry: I ? C.geometry : rl(u), properties: u.properties, type: u.type, patterns: {} };
            this.hasPattern ? this.features.push(iu("fill-extrusion", this.layers, N, this.zoom, n)) : this.addFeature(N, N.geometry, m, a, {}), n.featureIndex.insert(u, N.geometry, m, S, this.index, !0);
          }
        }
        addFeatures(e, n, a) {
          for (const u of this.features) {
            const { geometry: d } = u;
            this.addFeature(u, d, u.index, n, a);
          }
        }
        update(e, n, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, n, this.stateDependentLayers, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, $f), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Gf.members, !0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(e, n, a, u, d) {
          for (const m of ys(n, 500)) {
            const S = { x: 0, y: 0, vertexCount: 0 };
            let I = 0;
            for (const J of m) I += J.length;
            let C = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const J of m) {
              if (J.length === 0 || em(J)) continue;
              let rt = 0;
              for (let dt = 0; dt < J.length; dt++) {
                const vt = J[dt];
                if (dt >= 1) {
                  const Dt = J[dt - 1];
                  if (!tm(vt, Dt)) {
                    C.vertexLength + 4 > Li.MAX_VERTEX_ARRAY_LENGTH && (C = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const Lt = vt.sub(Dt)._perp()._unit(), Nt = Dt.dist(vt);
                    rt + Nt > 32768 && (rt = 0), Yc(this.layoutVertexArray, vt.x, vt.y, Lt.x, Lt.y, 0, 0, rt), Yc(this.layoutVertexArray, vt.x, vt.y, Lt.x, Lt.y, 0, 1, rt), S.x += 2 * vt.x, S.y += 2 * vt.y, S.vertexCount += 2, rt += Nt, Yc(this.layoutVertexArray, Dt.x, Dt.y, Lt.x, Lt.y, 0, 0, rt), Yc(this.layoutVertexArray, Dt.x, Dt.y, Lt.x, Lt.y, 0, 1, rt), S.x += 2 * Dt.x, S.y += 2 * Dt.y, S.vertexCount += 2;
                    const Zt = C.vertexLength;
                    this.indexArray.emplaceBack(Zt, Zt + 2, Zt + 1), this.indexArray.emplaceBack(Zt + 1, Zt + 2, Zt + 3), C.vertexLength += 4, C.primitiveLength += 2;
                  }
                }
              }
            }
            if (C.vertexLength + I > Li.MAX_VERTEX_ARRAY_LENGTH && (C = this.segments.prepareSegment(I, this.layoutVertexArray, this.indexArray)), Qf[e.type] !== "Polygon") continue;
            const N = [], D = [], G = C.vertexLength;
            for (const J of m) if (J.length !== 0) {
              J !== m[0] && D.push(N.length / 2);
              for (let rt = 0; rt < J.length; rt++) {
                const dt = J[rt];
                Yc(this.layoutVertexArray, dt.x, dt.y, 0, 0, 1, 1, 0), S.x += dt.x, S.y += dt.y, S.vertexCount += 1, N.push(dt.x), N.push(dt.y);
              }
            }
            const W = hd(N, D);
            for (let J = 0; J < W.length; J += 3) this.indexArray.emplaceBack(G + W[J], G + W[J + 2], G + W[J + 1]);
            C.primitiveLength += W.length / 3, C.vertexLength += I;
            for (let J = 0; J < S.vertexCount; J++) {
              const rt = Math.floor(S.x / S.vertexCount), dt = Math.floor(S.y / S.vertexCount);
              this.centroidVertexArray.emplaceBack(rt, dt);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, d, u);
        }
      }
      function tm(i, e) {
        return i.x === e.x && (i.x < 0 || i.x > ir) || i.y === e.y && (i.y < 0 || i.y > ir);
      }
      function em(i) {
        return i.every((e) => e.x < 0) || i.every((e) => e.x > ir) || i.every((e) => e.y < 0) || i.every((e) => e.y > ir);
      }
      let xd;
      De("FillExtrusionBucket", su, { omit: ["layers", "features"] });
      var im = { get paint() {
        return xd = xd || new o({ "fill-extrusion-opacity": new je(Y["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Qe(Y["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new je(Y["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new je(Y["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Qo(Y["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Qe(Y["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Qe(Y["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new je(Y["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class rm extends r {
        constructor(e) {
          super(e, im);
        }
        createBucket(e) {
          return new su(e);
        }
        queryRadius() {
          return mh(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(e, n, a, u, d, m, S, I) {
          const C = gh(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), m.angle, S), N = this.paint.get("fill-extrusion-height").evaluate(n, a), D = this.paint.get("fill-extrusion-base").evaluate(n, a), G = function(J, rt, dt, vt) {
            const Dt = [];
            for (const Lt of J) {
              const Nt = [Lt.x, Lt.y, 0, 1];
              yh(Nt, Nt, rt), Dt.push(new O(Nt[0] / Nt[3], Nt[1] / Nt[3]));
            }
            return Dt;
          }(C, I), W = function(J, rt, dt, vt) {
            const Dt = [], Lt = [], Nt = vt[8] * rt, Zt = vt[9] * rt, ge = vt[10] * rt, Me = vt[11] * rt, ri = vt[8] * dt, Le = vt[9] * dt, Ae = vt[10] * dt, Ve = vt[11] * dt;
            for (const Re of J) {
              const Fe = [], ne = [];
              for (const We of Re) {
                const qe = We.x, hi = We.y, Ki = vt[0] * qe + vt[4] * hi + vt[12], Yi = vt[1] * qe + vt[5] * hi + vt[13], sn = vt[2] * qe + vt[6] * hi + vt[14], ya = vt[3] * qe + vt[7] * hi + vt[15], xn = sn + ge, an = ya + Me, Vn = Ki + ri, Gn = Yi + Le, $n = sn + Ae, Tr = ya + Ve, on = new O((Ki + Nt) / an, (Yi + Zt) / an);
                on.z = xn / an, Fe.push(on);
                const zn = new O(Vn / Tr, Gn / Tr);
                zn.z = $n / Tr, ne.push(zn);
              }
              Dt.push(Fe), Lt.push(ne);
            }
            return [Dt, Lt];
          }(u, D, N, I);
          return function(J, rt, dt) {
            let vt = 1 / 0;
            ma(dt, rt) && (vt = bd(dt, rt[0]));
            for (let Dt = 0; Dt < rt.length; Dt++) {
              const Lt = rt[Dt], Nt = J[Dt];
              for (let Zt = 0; Zt < Lt.length - 1; Zt++) {
                const ge = Lt[Zt], Me = [ge, Lt[Zt + 1], Nt[Zt + 1], Nt[Zt], ge];
                pc(dt, Me) && (vt = Math.min(vt, bd(dt, Me)));
              }
            }
            return vt !== 1 / 0 && vt;
          }(W[0], W[1], G);
        }
      }
      function Kc(i, e) {
        return i.x * e.x + i.y * e.y;
      }
      function bd(i, e) {
        if (i.length === 1) {
          let n = 0;
          const a = e[n++];
          let u;
          for (; !u || a.equals(u); ) if (u = e[n++], !u) return 1 / 0;
          for (; n < e.length; n++) {
            const d = e[n], m = i[0], S = u.sub(a), I = d.sub(a), C = m.sub(a), N = Kc(S, S), D = Kc(S, I), G = Kc(I, I), W = Kc(C, S), J = Kc(C, I), rt = N * G - D * D, dt = (G * W - D * J) / rt, vt = (N * J - D * W) / rt, Dt = a.z * (1 - dt - vt) + u.z * dt + d.z * vt;
            if (isFinite(Dt)) return Dt;
          }
          return 1 / 0;
        }
        {
          let n = 1 / 0;
          for (const a of e) n = Math.min(n, a.z);
          return n;
        }
      }
      const nm = g([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: sm } = nm, am = g([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: om } = am, lm = bl.VectorTileFeature.types, cm = Math.cos(Math.PI / 180 * 37.5), wd = Math.pow(2, 14) / 0.5;
      class au {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.id), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n) => {
            this.gradients[n.id] = {};
          }), this.layoutVertexArray = new er(), this.layoutVertexArray2 = new da(), this.indexArray = new rn(), this.programConfigurations = new wo(e.layers, e.zoom), this.segments = new Li(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        populate(e, n, a) {
          this.hasPattern = eu("line", this.layers, n);
          const u = this.layers[0].layout.get("line-sort-key"), d = !u.isConstant(), m = [];
          for (const { feature: S, id: I, index: C, sourceLayerIndex: N } of e) {
            const D = this.layers[0]._featureFilter.needGeometry, G = So(S, D);
            if (!this.layers[0]._featureFilter.filter(new Xi(this.zoom), G, a)) continue;
            const W = d ? u.evaluate(G, {}, a) : void 0, J = { id: I, properties: S.properties, type: S.type, sourceLayerIndex: N, index: C, geometry: D ? G.geometry : rl(S), patterns: {}, sortKey: W };
            m.push(J);
          }
          d && m.sort((S, I) => S.sortKey - I.sortKey);
          for (const S of m) {
            const { geometry: I, index: C, sourceLayerIndex: N } = S;
            if (this.hasPattern) {
              const D = iu("line", this.layers, S, this.zoom, n);
              this.patternFeatures.push(D);
            } else this.addFeature(S, I, C, a, {});
            n.featureIndex.insert(e[C].feature, I, C, N, this.index);
          }
        }
        update(e, n, a) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, n, this.stateDependentLayers, a);
        }
        addFeatures(e, n, a) {
          for (const u of this.patternFeatures) this.addFeature(u, u.geometry, u.index, n, a);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, om)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, sm), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(e) {
          if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
        }
        addFeature(e, n, a, u, d) {
          const m = this.layers[0].layout, S = m.get("line-join").evaluate(e, {}), I = m.get("line-cap"), C = m.get("line-miter-limit"), N = m.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(e);
          for (const D of n) this.addLine(D, e, S, I, C, N);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, a, d, u);
        }
        addLine(e, n, a, u, d, m) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let vt = 0; vt < e.length - 1; vt++) this.totalDistance += e[vt].dist(e[vt + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const S = lm[n.type] === "Polygon";
          let I = e.length;
          for (; I >= 2 && e[I - 1].equals(e[I - 2]); ) I--;
          let C = 0;
          for (; C < I - 1 && e[C].equals(e[C + 1]); ) C++;
          if (I < (S ? 3 : 2)) return;
          a === "bevel" && (d = 1.05);
          const N = this.overscaling <= 16 ? 15 * ir / (512 * this.overscaling) : 0, D = this.segments.prepareSegment(10 * I, this.layoutVertexArray, this.indexArray);
          let G, W, J, rt, dt;
          this.e1 = this.e2 = -1, S && (G = e[I - 2], dt = e[C].sub(G)._unit()._perp());
          for (let vt = C; vt < I; vt++) {
            if (J = vt === I - 1 ? S ? e[C + 1] : void 0 : e[vt + 1], J && e[vt].equals(J)) continue;
            dt && (rt = dt), G && (W = G), G = e[vt], dt = J ? J.sub(G)._unit()._perp() : rt, rt = rt || dt;
            let Dt = rt.add(dt);
            Dt.x === 0 && Dt.y === 0 || Dt._unit();
            const Lt = rt.x * dt.x + rt.y * dt.y, Nt = Dt.x * dt.x + Dt.y * dt.y, Zt = Nt !== 0 ? 1 / Nt : 1 / 0, ge = 2 * Math.sqrt(2 - 2 * Nt), Me = Nt < cm && W && J, ri = rt.x * dt.y - rt.y * dt.x > 0;
            if (Me && vt > C) {
              const Ve = G.dist(W);
              if (Ve > 2 * N) {
                const Re = G.sub(G.sub(W)._mult(N / Ve)._round());
                this.updateDistance(W, Re), this.addCurrentVertex(Re, rt, 0, 0, D), W = Re;
              }
            }
            const Le = W && J;
            let Ae = Le ? a : S ? "butt" : u;
            if (Le && Ae === "round" && (Zt < m ? Ae = "miter" : Zt <= 2 && (Ae = "fakeround")), Ae === "miter" && Zt > d && (Ae = "bevel"), Ae === "bevel" && (Zt > 2 && (Ae = "flipbevel"), Zt < d && (Ae = "miter")), W && this.updateDistance(W, G), Ae === "miter") Dt._mult(Zt), this.addCurrentVertex(G, Dt, 0, 0, D);
            else if (Ae === "flipbevel") {
              if (Zt > 100) Dt = dt.mult(-1);
              else {
                const Ve = Zt * rt.add(dt).mag() / rt.sub(dt).mag();
                Dt._perp()._mult(Ve * (ri ? -1 : 1));
              }
              this.addCurrentVertex(G, Dt, 0, 0, D), this.addCurrentVertex(G, Dt.mult(-1), 0, 0, D);
            } else if (Ae === "bevel" || Ae === "fakeround") {
              const Ve = -Math.sqrt(Zt * Zt - 1), Re = ri ? Ve : 0, Fe = ri ? 0 : Ve;
              if (W && this.addCurrentVertex(G, rt, Re, Fe, D), Ae === "fakeround") {
                const ne = Math.round(180 * ge / Math.PI / 20);
                for (let We = 1; We < ne; We++) {
                  let qe = We / ne;
                  if (qe !== 0.5) {
                    const Ki = qe - 0.5;
                    qe += qe * Ki * (qe - 1) * ((1.0904 + Lt * (Lt * (3.55645 - 1.43519 * Lt) - 3.2452)) * Ki * Ki + (0.848013 + Lt * (0.215638 * Lt - 1.06021)));
                  }
                  const hi = dt.sub(rt)._mult(qe)._add(rt)._unit()._mult(ri ? -1 : 1);
                  this.addHalfVertex(G, hi.x, hi.y, !1, ri, 0, D);
                }
              }
              J && this.addCurrentVertex(G, dt, -Re, -Fe, D);
            } else if (Ae === "butt") this.addCurrentVertex(G, Dt, 0, 0, D);
            else if (Ae === "square") {
              const Ve = W ? 1 : -1;
              this.addCurrentVertex(G, Dt, Ve, Ve, D);
            } else Ae === "round" && (W && (this.addCurrentVertex(G, rt, 0, 0, D), this.addCurrentVertex(G, rt, 1, 1, D, !0)), J && (this.addCurrentVertex(G, dt, -1, -1, D, !0), this.addCurrentVertex(G, dt, 0, 0, D)));
            if (Me && vt < I - 1) {
              const Ve = G.dist(J);
              if (Ve > 2 * N) {
                const Re = G.add(J.sub(G)._mult(N / Ve)._round());
                this.updateDistance(G, Re), this.addCurrentVertex(Re, dt, 0, 0, D), G = Re;
              }
            }
          }
        }
        addCurrentVertex(e, n, a, u, d, m = !1) {
          const S = n.y * u - n.x, I = -n.y - n.x * u;
          this.addHalfVertex(e, n.x + n.y * a, n.y - n.x * a, m, !1, a, d), this.addHalfVertex(e, S, I, m, !0, -u, d), this.distance > wd / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, n, a, u, d, m));
        }
        addHalfVertex({ x: e, y: n }, a, u, d, m, S, I) {
          const C = 0.5 * (this.lineClips ? this.scaledDistance * (wd - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((e << 1) + (d ? 1 : 0), (n << 1) + (m ? 1 : 0), Math.round(63 * a) + 128, Math.round(63 * u) + 128, 1 + (S === 0 ? 0 : S < 0 ? -1 : 1) | (63 & C) << 2, C >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const N = I.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, N), I.primitiveLength++), m ? this.e2 = N : this.e1 = N;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(e, n) {
          this.distance += e.dist(n), this.updateScaledDistance();
        }
      }
      let Sd, Ad;
      De("LineBucket", au, { omit: ["layers", "patternFeatures"] });
      var Pd = { get paint() {
        return Ad = Ad || new o({ "line-opacity": new Qe(Y.paint_line["line-opacity"]), "line-color": new Qe(Y.paint_line["line-color"]), "line-translate": new je(Y.paint_line["line-translate"]), "line-translate-anchor": new je(Y.paint_line["line-translate-anchor"]), "line-width": new Qe(Y.paint_line["line-width"]), "line-gap-width": new Qe(Y.paint_line["line-gap-width"]), "line-offset": new Qe(Y.paint_line["line-offset"]), "line-blur": new Qe(Y.paint_line["line-blur"]), "line-dasharray": new p(Y.paint_line["line-dasharray"]), "line-pattern": new Qo(Y.paint_line["line-pattern"]), "line-gradient": new w(Y.paint_line["line-gradient"]) });
      }, get layout() {
        return Sd = Sd || new o({ "line-cap": new je(Y.layout_line["line-cap"]), "line-join": new Qe(Y.layout_line["line-join"]), "line-miter-limit": new je(Y.layout_line["line-miter-limit"]), "line-round-limit": new je(Y.layout_line["line-round-limit"]), "line-sort-key": new Qe(Y.layout_line["line-sort-key"]) });
      } };
      class hm extends Qe {
        possiblyEvaluate(e, n) {
          return n = new Xi(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(e, n);
        }
        evaluate(e, n, a, u) {
          return n = Ot({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(e, n, a, u);
        }
      }
      let bh;
      class um extends r {
        constructor(e) {
          super(e, Pd), this.gradientVersion = 0, bh || (bh = new hm(Pd.paint.properties["line-width"].specification), bh.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(e) {
          if (e === "line-gradient") {
            const n = this.gradientExpression();
            this.stepInterpolant = !!function(a) {
              return a._styleExpression !== void 0;
            }(n) && n._styleExpression.expression instanceof ta, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(e, n) {
          super.recalculate(e, n), this.paint._values["line-floorwidth"] = bh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
        }
        createBucket(e) {
          return new au(e);
        }
        queryRadius(e) {
          const n = e, a = Id(Gc("line-width", this, n), Gc("line-gap-width", this, n)), u = Gc("line-offset", this, n);
          return a / 2 + Math.abs(u) + mh(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(e, n, a, u, d, m, S) {
          const I = gh(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), m.angle, S), C = S / 2 * Id(this.paint.get("line-width").evaluate(n, a), this.paint.get("line-gap-width").evaluate(n, a)), N = this.paint.get("line-offset").evaluate(n, a);
          return N && (u = function(D, G) {
            const W = [];
            for (let J = 0; J < D.length; J++) {
              const rt = D[J], dt = [];
              for (let vt = 0; vt < rt.length; vt++) {
                const Dt = rt[vt - 1], Lt = rt[vt], Nt = rt[vt + 1], Zt = vt === 0 ? new O(0, 0) : Lt.sub(Dt)._unit()._perp(), ge = vt === rt.length - 1 ? new O(0, 0) : Nt.sub(Lt)._unit()._perp(), Me = Zt._add(ge)._unit(), ri = Me.x * ge.x + Me.y * ge.y;
                ri !== 0 && Me._mult(1 / ri), dt.push(Me._mult(G)._add(Lt));
              }
              W.push(dt);
            }
            return W;
          }(u, N * S)), function(D, G, W) {
            for (let J = 0; J < G.length; J++) {
              const rt = G[J];
              if (D.length >= 3) {
                for (let dt = 0; dt < rt.length; dt++) if (Po(D, rt[dt])) return !0;
              }
              if (Ao(D, rt, W)) return !0;
            }
            return !1;
          }(I, u, C);
        }
        isTileClipped() {
          return !0;
        }
      }
      function Id(i, e) {
        return e > 0 ? e + 2 * i : i;
      }
      const dm = g([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), pm = g([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      g([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const fm = g([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      g([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const kd = g([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), mm = g([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function gm(i, e, n) {
        return i.sections.forEach((a) => {
          a.text = function(u, d, m) {
            const S = d.layout.get("text-transform").evaluate(m, {});
            return S === "uppercase" ? u = u.toLocaleUpperCase() : S === "lowercase" && (u = u.toLocaleLowerCase()), Ln.applyArabicShaping && (u = Ln.applyArabicShaping(u)), u;
          }(a.text, e, n);
        }), i;
      }
      g([{ name: "triangle", components: 3, type: "Uint16" }]), g([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), g([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), g([{ type: "Float32", name: "offsetX" }]), g([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), g([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const Jc = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      var Gr = 24, Td = Hi, Ld = function(i, e, n, a, u) {
        var d, m, S = 8 * u - a - 1, I = (1 << S) - 1, C = I >> 1, N = -7, D = u - 1, G = -1, W = i[e + D];
        for (D += G, d = W & (1 << -N) - 1, W >>= -N, N += S; N > 0; d = 256 * d + i[e + D], D += G, N -= 8) ;
        for (m = d & (1 << -N) - 1, d >>= -N, N += a; N > 0; m = 256 * m + i[e + D], D += G, N -= 8) ;
        if (d === 0) d = 1 - C;
        else {
          if (d === I) return m ? NaN : 1 / 0 * (W ? -1 : 1);
          m += Math.pow(2, a), d -= C;
        }
        return (W ? -1 : 1) * m * Math.pow(2, d - a);
      }, Cd = function(i, e, n, a, u, d) {
        var m, S, I, C = 8 * d - u - 1, N = (1 << C) - 1, D = N >> 1, G = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, W = 0, J = 1, rt = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (S = isNaN(e) ? 1 : 0, m = N) : (m = Math.floor(Math.log(e) / Math.LN2), e * (I = Math.pow(2, -m)) < 1 && (m--, I *= 2), (e += m + D >= 1 ? G / I : G * Math.pow(2, 1 - D)) * I >= 2 && (m++, I /= 2), m + D >= N ? (S = 0, m = N) : m + D >= 1 ? (S = (e * I - 1) * Math.pow(2, u), m += D) : (S = e * Math.pow(2, D - 1) * Math.pow(2, u), m = 0)); u >= 8; i[n + W] = 255 & S, W += J, S /= 256, u -= 8) ;
        for (m = m << u | S, C += u; C > 0; i[n + W] = 255 & m, W += J, m /= 256, C -= 8) ;
        i[n + W - J] |= 128 * rt;
      };
      function Hi(i) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(i) ? i : new Uint8Array(i || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Hi.Varint = 0, Hi.Fixed64 = 1, Hi.Bytes = 2, Hi.Fixed32 = 5;
      var ou = 4294967296, Md = 1 / ou, Ed = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
      function sl(i) {
        return i.type === Hi.Bytes ? i.readVarint() + i.pos : i.pos + 1;
      }
      function vc(i, e, n) {
        return n ? 4294967296 * e + (i >>> 0) : 4294967296 * (e >>> 0) + (i >>> 0);
      }
      function zd(i, e, n) {
        var a = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
        n.realloc(a);
        for (var u = n.pos - 1; u >= i; u--) n.buf[u + a] = n.buf[u];
      }
      function ym(i, e) {
        for (var n = 0; n < i.length; n++) e.writeVarint(i[n]);
      }
      function _m(i, e) {
        for (var n = 0; n < i.length; n++) e.writeSVarint(i[n]);
      }
      function vm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeFloat(i[n]);
      }
      function xm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeDouble(i[n]);
      }
      function bm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeBoolean(i[n]);
      }
      function wm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeFixed32(i[n]);
      }
      function Sm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeSFixed32(i[n]);
      }
      function Am(i, e) {
        for (var n = 0; n < i.length; n++) e.writeFixed64(i[n]);
      }
      function Pm(i, e) {
        for (var n = 0; n < i.length; n++) e.writeSFixed64(i[n]);
      }
      function wh(i, e) {
        return (i[e] | i[e + 1] << 8 | i[e + 2] << 16) + 16777216 * i[e + 3];
      }
      function xc(i, e, n) {
        i[n] = e, i[n + 1] = e >>> 8, i[n + 2] = e >>> 16, i[n + 3] = e >>> 24;
      }
      function Nd(i, e) {
        return (i[e] | i[e + 1] << 8 | i[e + 2] << 16) + (i[e + 3] << 24);
      }
      Hi.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(i, e, n) {
        for (n = n || this.length; this.pos < n; ) {
          var a = this.readVarint(), u = a >> 3, d = this.pos;
          this.type = 7 & a, i(u, e, this), this.pos === d && this.skip(a);
        }
        return e;
      }, readMessage: function(i, e) {
        return this.readFields(i, e, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var i = wh(this.buf, this.pos);
        return this.pos += 4, i;
      }, readSFixed32: function() {
        var i = Nd(this.buf, this.pos);
        return this.pos += 4, i;
      }, readFixed64: function() {
        var i = wh(this.buf, this.pos) + wh(this.buf, this.pos + 4) * ou;
        return this.pos += 8, i;
      }, readSFixed64: function() {
        var i = wh(this.buf, this.pos) + Nd(this.buf, this.pos + 4) * ou;
        return this.pos += 8, i;
      }, readFloat: function() {
        var i = Ld(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, i;
      }, readDouble: function() {
        var i = Ld(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, i;
      }, readVarint: function(i) {
        var e, n, a = this.buf;
        return e = 127 & (n = a[this.pos++]), n < 128 ? e : (e |= (127 & (n = a[this.pos++])) << 7, n < 128 ? e : (e |= (127 & (n = a[this.pos++])) << 14, n < 128 ? e : (e |= (127 & (n = a[this.pos++])) << 21, n < 128 ? e : function(u, d, m) {
          var S, I, C = m.buf;
          if (S = (112 & (I = C[m.pos++])) >> 4, I < 128 || (S |= (127 & (I = C[m.pos++])) << 3, I < 128) || (S |= (127 & (I = C[m.pos++])) << 10, I < 128) || (S |= (127 & (I = C[m.pos++])) << 17, I < 128) || (S |= (127 & (I = C[m.pos++])) << 24, I < 128) || (S |= (1 & (I = C[m.pos++])) << 31, I < 128)) return vc(u, S, d);
          throw new Error("Expected varint not more than 10 bytes");
        }(e |= (15 & (n = a[this.pos])) << 28, i, this))));
      }, readVarint64: function() {
        return this.readVarint(!0);
      }, readSVarint: function() {
        var i = this.readVarint();
        return i % 2 == 1 ? (i + 1) / -2 : i / 2;
      }, readBoolean: function() {
        return !!this.readVarint();
      }, readString: function() {
        var i = this.readVarint() + this.pos, e = this.pos;
        return this.pos = i, i - e >= 12 && Ed ? function(n, a, u) {
          return Ed.decode(n.subarray(a, u));
        }(this.buf, e, i) : function(n, a, u) {
          for (var d = "", m = a; m < u; ) {
            var S, I, C, N = n[m], D = null, G = N > 239 ? 4 : N > 223 ? 3 : N > 191 ? 2 : 1;
            if (m + G > u) break;
            G === 1 ? N < 128 && (D = N) : G === 2 ? (192 & (S = n[m + 1])) == 128 && (D = (31 & N) << 6 | 63 & S) <= 127 && (D = null) : G === 3 ? (I = n[m + 2], (192 & (S = n[m + 1])) == 128 && (192 & I) == 128 && ((D = (15 & N) << 12 | (63 & S) << 6 | 63 & I) <= 2047 || D >= 55296 && D <= 57343) && (D = null)) : G === 4 && (I = n[m + 2], C = n[m + 3], (192 & (S = n[m + 1])) == 128 && (192 & I) == 128 && (192 & C) == 128 && ((D = (15 & N) << 18 | (63 & S) << 12 | (63 & I) << 6 | 63 & C) <= 65535 || D >= 1114112) && (D = null)), D === null ? (D = 65533, G = 1) : D > 65535 && (D -= 65536, d += String.fromCharCode(D >>> 10 & 1023 | 55296), D = 56320 | 1023 & D), d += String.fromCharCode(D), m += G;
          }
          return d;
        }(this.buf, e, i);
      }, readBytes: function() {
        var i = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, i);
        return this.pos = i, e;
      }, readPackedVarint: function(i, e) {
        if (this.type !== Hi.Bytes) return i.push(this.readVarint(e));
        var n = sl(this);
        for (i = i || []; this.pos < n; ) i.push(this.readVarint(e));
        return i;
      }, readPackedSVarint: function(i) {
        if (this.type !== Hi.Bytes) return i.push(this.readSVarint());
        var e = sl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readSVarint());
        return i;
      }, readPackedBoolean: function(i) {
        if (this.type !== Hi.Bytes) return i.push(this.readBoolean());
        var e = sl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readBoolean());
        return i;
      }, readPackedFloat: function(i) {
        if (this.type !== Hi.Bytes) return i.push(this.readFloat());
        var e = sl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readFloat());
        return i;
      }, readPackedDouble: function(i) {
        if (this.type !== Hi.Bytes) return i.push(this.readDouble());
        var e = sl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readDouble());
        return i;
      }, readPackedFixed32: function(i) {
        if (this.type !== Hi.Bytes) return i.push(this.readFixed32());
        var e = sl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readFixed32());
        return i;
      }, readPackedSFixed32: function(i) {
        if (this.type !== Hi.Bytes) return i.push(this.readSFixed32());
        var e = sl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readSFixed32());
        return i;
      }, readPackedFixed64: function(i) {
        if (this.type !== Hi.Bytes) return i.push(this.readFixed64());
        var e = sl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readFixed64());
        return i;
      }, readPackedSFixed64: function(i) {
        if (this.type !== Hi.Bytes) return i.push(this.readSFixed64());
        var e = sl(this);
        for (i = i || []; this.pos < e; ) i.push(this.readSFixed64());
        return i;
      }, skip: function(i) {
        var e = 7 & i;
        if (e === Hi.Varint) for (; this.buf[this.pos++] > 127; ) ;
        else if (e === Hi.Bytes) this.pos = this.readVarint() + this.pos;
        else if (e === Hi.Fixed32) this.pos += 4;
        else {
          if (e !== Hi.Fixed64) throw new Error("Unimplemented type: " + e);
          this.pos += 8;
        }
      }, writeTag: function(i, e) {
        this.writeVarint(i << 3 | e);
      }, realloc: function(i) {
        for (var e = this.length || 16; e < this.pos + i; ) e *= 2;
        if (e !== this.length) {
          var n = new Uint8Array(e);
          n.set(this.buf), this.buf = n, this.length = e;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(i) {
        this.realloc(4), xc(this.buf, i, this.pos), this.pos += 4;
      }, writeSFixed32: function(i) {
        this.realloc(4), xc(this.buf, i, this.pos), this.pos += 4;
      }, writeFixed64: function(i) {
        this.realloc(8), xc(this.buf, -1 & i, this.pos), xc(this.buf, Math.floor(i * Md), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(i) {
        this.realloc(8), xc(this.buf, -1 & i, this.pos), xc(this.buf, Math.floor(i * Md), this.pos + 4), this.pos += 8;
      }, writeVarint: function(i) {
        (i = +i || 0) > 268435455 || i < 0 ? function(e, n) {
          var a, u;
          if (e >= 0 ? (a = e % 4294967296 | 0, u = e / 4294967296 | 0) : (u = ~(-e / 4294967296), 4294967295 ^ (a = ~(-e % 4294967296)) ? a = a + 1 | 0 : (a = 0, u = u + 1 | 0)), e >= 18446744073709552e3 || e < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
          n.realloc(10), function(d, m, S) {
            S.buf[S.pos++] = 127 & d | 128, d >>>= 7, S.buf[S.pos++] = 127 & d | 128, d >>>= 7, S.buf[S.pos++] = 127 & d | 128, d >>>= 7, S.buf[S.pos++] = 127 & d | 128, S.buf[S.pos] = 127 & (d >>>= 7);
          }(a, 0, n), function(d, m) {
            var S = (7 & d) << 4;
            m.buf[m.pos++] |= S | ((d >>>= 3) ? 128 : 0), d && (m.buf[m.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (m.buf[m.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (m.buf[m.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (m.buf[m.pos++] = 127 & d | ((d >>>= 7) ? 128 : 0), d && (m.buf[m.pos++] = 127 & d)))));
          }(u, n);
        }(i, this) : (this.realloc(4), this.buf[this.pos++] = 127 & i | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = 127 & (i >>>= 7) | (i > 127 ? 128 : 0), i <= 127 || (this.buf[this.pos++] = i >>> 7 & 127))));
      }, writeSVarint: function(i) {
        this.writeVarint(i < 0 ? 2 * -i - 1 : 2 * i);
      }, writeBoolean: function(i) {
        this.writeVarint(!!i);
      }, writeString: function(i) {
        i = String(i), this.realloc(4 * i.length), this.pos++;
        var e = this.pos;
        this.pos = function(a, u, d) {
          for (var m, S, I = 0; I < u.length; I++) {
            if ((m = u.charCodeAt(I)) > 55295 && m < 57344) {
              if (!S) {
                m > 56319 || I + 1 === u.length ? (a[d++] = 239, a[d++] = 191, a[d++] = 189) : S = m;
                continue;
              }
              if (m < 56320) {
                a[d++] = 239, a[d++] = 191, a[d++] = 189, S = m;
                continue;
              }
              m = S - 55296 << 10 | m - 56320 | 65536, S = null;
            } else S && (a[d++] = 239, a[d++] = 191, a[d++] = 189, S = null);
            m < 128 ? a[d++] = m : (m < 2048 ? a[d++] = m >> 6 | 192 : (m < 65536 ? a[d++] = m >> 12 | 224 : (a[d++] = m >> 18 | 240, a[d++] = m >> 12 & 63 | 128), a[d++] = m >> 6 & 63 | 128), a[d++] = 63 & m | 128);
          }
          return d;
        }(this.buf, i, this.pos);
        var n = this.pos - e;
        n >= 128 && zd(e, n, this), this.pos = e - 1, this.writeVarint(n), this.pos += n;
      }, writeFloat: function(i) {
        this.realloc(4), Cd(this.buf, i, this.pos, !0, 23, 4), this.pos += 4;
      }, writeDouble: function(i) {
        this.realloc(8), Cd(this.buf, i, this.pos, !0, 52, 8), this.pos += 8;
      }, writeBytes: function(i) {
        var e = i.length;
        this.writeVarint(e), this.realloc(e);
        for (var n = 0; n < e; n++) this.buf[this.pos++] = i[n];
      }, writeRawMessage: function(i, e) {
        this.pos++;
        var n = this.pos;
        i(e, this);
        var a = this.pos - n;
        a >= 128 && zd(n, a, this), this.pos = n - 1, this.writeVarint(a), this.pos += a;
      }, writeMessage: function(i, e, n) {
        this.writeTag(i, Hi.Bytes), this.writeRawMessage(e, n);
      }, writePackedVarint: function(i, e) {
        e.length && this.writeMessage(i, ym, e);
      }, writePackedSVarint: function(i, e) {
        e.length && this.writeMessage(i, _m, e);
      }, writePackedBoolean: function(i, e) {
        e.length && this.writeMessage(i, bm, e);
      }, writePackedFloat: function(i, e) {
        e.length && this.writeMessage(i, vm, e);
      }, writePackedDouble: function(i, e) {
        e.length && this.writeMessage(i, xm, e);
      }, writePackedFixed32: function(i, e) {
        e.length && this.writeMessage(i, wm, e);
      }, writePackedSFixed32: function(i, e) {
        e.length && this.writeMessage(i, Sm, e);
      }, writePackedFixed64: function(i, e) {
        e.length && this.writeMessage(i, Am, e);
      }, writePackedSFixed64: function(i, e) {
        e.length && this.writeMessage(i, Pm, e);
      }, writeBytesField: function(i, e) {
        this.writeTag(i, Hi.Bytes), this.writeBytes(e);
      }, writeFixed32Field: function(i, e) {
        this.writeTag(i, Hi.Fixed32), this.writeFixed32(e);
      }, writeSFixed32Field: function(i, e) {
        this.writeTag(i, Hi.Fixed32), this.writeSFixed32(e);
      }, writeFixed64Field: function(i, e) {
        this.writeTag(i, Hi.Fixed64), this.writeFixed64(e);
      }, writeSFixed64Field: function(i, e) {
        this.writeTag(i, Hi.Fixed64), this.writeSFixed64(e);
      }, writeVarintField: function(i, e) {
        this.writeTag(i, Hi.Varint), this.writeVarint(e);
      }, writeSVarintField: function(i, e) {
        this.writeTag(i, Hi.Varint), this.writeSVarint(e);
      }, writeStringField: function(i, e) {
        this.writeTag(i, Hi.Bytes), this.writeString(e);
      }, writeFloatField: function(i, e) {
        this.writeTag(i, Hi.Fixed32), this.writeFloat(e);
      }, writeDoubleField: function(i, e) {
        this.writeTag(i, Hi.Fixed64), this.writeDouble(e);
      }, writeBooleanField: function(i, e) {
        this.writeVarintField(i, !!e);
      } };
      var lu = z(Td);
      const cu = 3;
      function Im(i, e, n) {
        i === 1 && n.readMessage(km, e);
      }
      function km(i, e, n) {
        if (i === 3) {
          const { id: a, bitmap: u, width: d, height: m, left: S, top: I, advance: C } = n.readMessage(Tm, {});
          e.push({ id: a, bitmap: new Zc({ width: d + 2 * cu, height: m + 2 * cu }, u), metrics: { width: d, height: m, left: S, top: I, advance: C } });
        }
      }
      function Tm(i, e, n) {
        i === 1 ? e.id = n.readVarint() : i === 2 ? e.bitmap = n.readBytes() : i === 3 ? e.width = n.readVarint() : i === 4 ? e.height = n.readVarint() : i === 5 ? e.left = n.readSVarint() : i === 6 ? e.top = n.readSVarint() : i === 7 && (e.advance = n.readVarint());
      }
      const Dd = cu;
      function Fd(i) {
        let e = 0, n = 0;
        for (const m of i) e += m.w * m.h, n = Math.max(n, m.w);
        i.sort((m, S) => S.h - m.h);
        const a = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), n), h: 1 / 0 }];
        let u = 0, d = 0;
        for (const m of i) for (let S = a.length - 1; S >= 0; S--) {
          const I = a[S];
          if (!(m.w > I.w || m.h > I.h)) {
            if (m.x = I.x, m.y = I.y, d = Math.max(d, m.y + m.h), u = Math.max(u, m.x + m.w), m.w === I.w && m.h === I.h) {
              const C = a.pop();
              S < a.length && (a[S] = C);
            } else m.h === I.h ? (I.x += m.w, I.w -= m.w) : m.w === I.w ? (I.y += m.h, I.h -= m.h) : (a.push({ x: I.x + m.w, y: I.y, w: I.w - m.w, h: m.h }), I.y += m.h, I.h -= m.h);
            break;
          }
        }
        return { w: u, h: d, fill: e / (u * d) || 0 };
      }
      const ds = 1;
      class hu {
        constructor(e, { pixelRatio: n, version: a, stretchX: u, stretchY: d, content: m, textFitWidth: S, textFitHeight: I }) {
          this.paddedRect = e, this.pixelRatio = n, this.stretchX = u, this.stretchY = d, this.content = m, this.version = a, this.textFitWidth = S, this.textFitHeight = I;
        }
        get tl() {
          return [this.paddedRect.x + ds, this.paddedRect.y + ds];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - ds, this.paddedRect.y + this.paddedRect.h - ds];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * ds) / this.pixelRatio, (this.paddedRect.h - 2 * ds) / this.pixelRatio];
        }
      }
      class Bd {
        constructor(e, n) {
          const a = {}, u = {};
          this.haveRenderCallbacks = [];
          const d = [];
          this.addImages(e, a, d), this.addImages(n, u, d);
          const { w: m, h: S } = Fd(d), I = new $s({ width: m || 1, height: S || 1 });
          for (const C in e) {
            const N = e[C], D = a[C].paddedRect;
            $s.copy(N.data, I, { x: 0, y: 0 }, { x: D.x + ds, y: D.y + ds }, N.data);
          }
          for (const C in n) {
            const N = n[C], D = u[C].paddedRect, G = D.x + ds, W = D.y + ds, J = N.data.width, rt = N.data.height;
            $s.copy(N.data, I, { x: 0, y: 0 }, { x: G, y: W }, N.data), $s.copy(N.data, I, { x: 0, y: rt - 1 }, { x: G, y: W - 1 }, { width: J, height: 1 }), $s.copy(N.data, I, { x: 0, y: 0 }, { x: G, y: W + rt }, { width: J, height: 1 }), $s.copy(N.data, I, { x: J - 1, y: 0 }, { x: G - 1, y: W }, { width: 1, height: rt }), $s.copy(N.data, I, { x: 0, y: 0 }, { x: G + J, y: W }, { width: 1, height: rt });
          }
          this.image = I, this.iconPositions = a, this.patternPositions = u;
        }
        addImages(e, n, a) {
          for (const u in e) {
            const d = e[u], m = { x: 0, y: 0, w: d.data.width + 2 * ds, h: d.data.height + 2 * ds };
            a.push(m), n[u] = new hu(m, d), d.hasRenderCallback && this.haveRenderCallbacks.push(u);
          }
        }
        patchUpdatedImages(e, n) {
          e.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const a in e.updatedImages) this.patchUpdatedImage(this.iconPositions[a], e.getImage(a), n), this.patchUpdatedImage(this.patternPositions[a], e.getImage(a), n);
        }
        patchUpdatedImage(e, n, a) {
          if (!e || !n || e.version === n.version) return;
          e.version = n.version;
          const [u, d] = e.tl;
          a.update(n.data, void 0, { x: u, y: d });
        }
      }
      var wl;
      De("ImagePosition", hu), De("ImageAtlas", Bd), v.ah = void 0, (wl = v.ah || (v.ah = {}))[wl.none = 0] = "none", wl[wl.horizontal = 1] = "horizontal", wl[wl.vertical = 2] = "vertical", wl[wl.horizontalOnly = 3] = "horizontalOnly";
      const Qc = -17;
      class th {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(e, n) {
          const a = new th();
          return a.scale = e || 1, a.fontStack = n, a;
        }
        static forImage(e) {
          const n = new th();
          return n.imageName = e, n;
        }
      }
      class bc {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(e, n) {
          const a = new bc();
          for (let u = 0; u < e.sections.length; u++) {
            const d = e.sections[u];
            d.image ? a.addImageSection(d) : a.addTextSection(d, n);
          }
          return a;
        }
        length() {
          return this.text.length;
        }
        getSection(e) {
          return this.sections[this.sectionIndex[e]];
        }
        getSectionIndex(e) {
          return this.sectionIndex[e];
        }
        getCharCode(e) {
          return this.text.charCodeAt(e);
        }
        verticalizePunctuation() {
          this.text = function(e) {
            let n = "";
            for (let a = 0; a < e.length; a++) {
              const u = e.charCodeAt(a + 1) || null, d = e.charCodeAt(a - 1) || null;
              n += u && Yo(u) && !Jc[e[a + 1]] || d && Yo(d) && !Jc[e[a - 1]] || !Jc[e[a]] ? e[a] : Jc[e[a]];
            }
            return n;
          }(this.text);
        }
        trim() {
          let e = 0;
          for (let a = 0; a < this.text.length && Ah[this.text.charCodeAt(a)]; a++) e++;
          let n = this.text.length;
          for (let a = this.text.length - 1; a >= 0 && a >= e && Ah[this.text.charCodeAt(a)]; a--) n--;
          this.text = this.text.substring(e, n), this.sectionIndex = this.sectionIndex.slice(e, n);
        }
        substring(e, n) {
          const a = new bc();
          return a.text = this.text.substring(e, n), a.sectionIndex = this.sectionIndex.slice(e, n), a.sections = this.sections, a;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((e, n) => Math.max(e, this.sections[n].scale), 0);
        }
        addTextSection(e, n) {
          this.text += e.text, this.sections.push(th.forText(e.scale, e.fontStack || n));
          const a = this.sections.length - 1;
          for (let u = 0; u < e.text.length; ++u) this.sectionIndex.push(a);
        }
        addImageSection(e) {
          const n = e.image ? e.image.name : "";
          if (n.length === 0) return void It("Can't add FormattedSection with an empty image.");
          const a = this.getNextImageSectionCharCode();
          a ? (this.text += String.fromCharCode(a), this.sections.push(th.forImage(n)), this.sectionIndex.push(this.sections.length - 1)) : It("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Sh(i, e, n, a, u, d, m, S, I, C, N, D, G, W, J) {
        const rt = bc.fromFeature(i, u);
        let dt;
        D === v.ah.vertical && rt.verticalizePunctuation();
        const { processBidirectionalText: vt, processStyledBidirectionalText: Dt } = Ln;
        if (vt && rt.sections.length === 1) {
          dt = [];
          const Zt = vt(rt.toString(), uu(rt, C, d, e, a, W));
          for (const ge of Zt) {
            const Me = new bc();
            Me.text = ge, Me.sections = rt.sections;
            for (let ri = 0; ri < ge.length; ri++) Me.sectionIndex.push(0);
            dt.push(Me);
          }
        } else if (Dt) {
          dt = [];
          const Zt = Dt(rt.text, rt.sectionIndex, uu(rt, C, d, e, a, W));
          for (const ge of Zt) {
            const Me = new bc();
            Me.text = ge[0], Me.sectionIndex = ge[1], Me.sections = rt.sections, dt.push(Me);
          }
        } else dt = function(Zt, ge) {
          const Me = [], ri = Zt.text;
          let Le = 0;
          for (const Ae of ge) Me.push(Zt.substring(Le, Ae)), Le = Ae;
          return Le < ri.length && Me.push(Zt.substring(Le, ri.length)), Me;
        }(rt, uu(rt, C, d, e, a, W));
        const Lt = [], Nt = { positionedLines: Lt, text: rt.toString(), top: N[1], bottom: N[1], left: N[0], right: N[0], writingMode: D, iconsInText: !1, verticalizable: !1 };
        return function(Zt, ge, Me, ri, Le, Ae, Ve, Re, Fe, ne, We, qe) {
          let hi = 0, Ki = Qc, Yi = 0, sn = 0;
          const ya = Re === "right" ? 1 : Re === "left" ? 0 : 0.5;
          let xn = 0;
          for (const Tr of Le) {
            Tr.trim();
            const on = Tr.getMaxScale(), zn = (on - 1) * Gr, bn = { positionedGlyphs: [], lineOffset: 0 };
            Zt.positionedLines[xn] = bn;
            const Zn = bn.positionedGlyphs;
            let wn = 0;
            if (!Tr.length()) {
              Ki += Ae, ++xn;
              continue;
            }
            for (let ps = 0; ps < Tr.length(); ps++) {
              const Ui = Tr.getSection(ps), rr = Tr.getSectionIndex(ps), lr = Tr.getCharCode(ps);
              let Cs = 0, br = null, Pc = null, ko = null, To = Gr;
              const _a = !(Fe === v.ah.horizontal || !We && !Ul(lr) || We && (Ah[lr] || (an = lr, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(an)))));
              if (Ui.imageName) {
                const Xs = ri[Ui.imageName];
                if (!Xs) continue;
                ko = Ui.imageName, Zt.iconsInText = Zt.iconsInText || !0, Pc = Xs.paddedRect;
                const fn = Xs.displaySize;
                Ui.scale = Ui.scale * Gr / qe, br = { width: fn[0], height: fn[1], left: ds, top: -Dd, advance: _a ? fn[1] : fn[0] }, Cs = zn + (Gr - fn[1] * Ui.scale), To = br.advance;
                const al = _a ? fn[0] * Ui.scale - Gr * on : fn[1] * Ui.scale - Gr * on;
                al > 0 && al > wn && (wn = al);
              } else {
                const Xs = Me[Ui.fontStack], fn = Xs && Xs[lr];
                if (fn && fn.rect) Pc = fn.rect, br = fn.metrics;
                else {
                  const al = ge[Ui.fontStack], ah = al && al[lr];
                  if (!ah) continue;
                  br = ah.metrics;
                }
                Cs = (on - Ui.scale) * Gr;
              }
              _a ? (Zt.verticalizable = !0, Zn.push({ glyph: lr, imageName: ko, x: hi, y: Ki + Cs, vertical: _a, scale: Ui.scale, fontStack: Ui.fontStack, sectionIndex: rr, metrics: br, rect: Pc }), hi += To * Ui.scale + ne) : (Zn.push({ glyph: lr, imageName: ko, x: hi, y: Ki + Cs, vertical: _a, scale: Ui.scale, fontStack: Ui.fontStack, sectionIndex: rr, metrics: br, rect: Pc }), hi += br.advance * Ui.scale + ne);
            }
            Zn.length !== 0 && (Yi = Math.max(hi - ne, Yi), Em(Zn, 0, Zn.length - 1, ya, wn)), hi = 0;
            const Ws = Ae * on + wn;
            bn.lineOffset = Math.max(wn, zn), Ki += Ws, sn = Math.max(Ws, sn), ++xn;
          }
          var an;
          const Vn = Ki - Qc, { horizontalAlign: Gn, verticalAlign: $n } = du(Ve);
          (function(Tr, on, zn, bn, Zn, wn, Ws, ps, Ui) {
            const rr = (on - zn) * Zn;
            let lr = 0;
            lr = wn !== Ws ? -ps * bn - Qc : (-bn * Ui + 0.5) * Ws;
            for (const Cs of Tr) for (const br of Cs.positionedGlyphs) br.x += rr, br.y += lr;
          })(Zt.positionedLines, ya, Gn, $n, Yi, sn, Ae, Vn, Le.length), Zt.top += -$n * Vn, Zt.bottom = Zt.top + Vn, Zt.left += -Gn * Yi, Zt.right = Zt.left + Yi;
        }(Nt, e, n, a, dt, m, S, I, D, C, G, J), !function(Zt) {
          for (const ge of Zt) if (ge.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(Lt) && Nt;
      }
      const Ah = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Lm = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, Cm = { 40: !0 };
      function Rd(i, e, n, a, u, d) {
        if (e.imageName) {
          const m = a[e.imageName];
          return m ? m.displaySize[0] * e.scale * Gr / d + u : 0;
        }
        {
          const m = n[e.fontStack], S = m && m[i];
          return S ? S.metrics.advance * e.scale + u : 0;
        }
      }
      function Od(i, e, n, a) {
        const u = Math.pow(i - e, 2);
        return a ? i < e ? u / 2 : 2 * u : u + Math.abs(n) * n;
      }
      function Mm(i, e, n) {
        let a = 0;
        return i === 10 && (a -= 1e4), n && (a += 150), i !== 40 && i !== 65288 || (a += 50), e !== 41 && e !== 65289 || (a += 50), a;
      }
      function jd(i, e, n, a, u, d) {
        let m = null, S = Od(e, n, u, d);
        for (const I of a) {
          const C = Od(e - I.x, n, u, d) + I.badness;
          C <= S && (m = I, S = C);
        }
        return { index: i, x: e, priorBreak: m, badness: S };
      }
      function qd(i) {
        return i ? qd(i.priorBreak).concat(i.index) : [];
      }
      function uu(i, e, n, a, u, d) {
        if (!i) return [];
        const m = [], S = function(D, G, W, J, rt, dt) {
          let vt = 0;
          for (let Dt = 0; Dt < D.length(); Dt++) {
            const Lt = D.getSection(Dt);
            vt += Rd(D.getCharCode(Dt), Lt, J, rt, G, dt);
          }
          return vt / Math.max(1, Math.ceil(vt / W));
        }(i, e, n, a, u, d), I = i.text.indexOf("") >= 0;
        let C = 0;
        for (let D = 0; D < i.length(); D++) {
          const G = i.getSection(D), W = i.getCharCode(D);
          if (Ah[W] || (C += Rd(W, G, a, u, e, d)), D < i.length() - 1) {
            const J = !((N = W) < 11904) && (!!fi["CJK Compatibility Forms"](N) || !!fi["CJK Compatibility"](N) || !!fi["CJK Strokes"](N) || !!fi["CJK Symbols and Punctuation"](N) || !!fi["Enclosed CJK Letters and Months"](N) || !!fi["Halfwidth and Fullwidth Forms"](N) || !!fi["Ideographic Description Characters"](N) || !!fi["Vertical Forms"](N) || ql.test(String.fromCodePoint(N)));
            (Lm[W] || J || G.imageName || D !== i.length() - 2 && Cm[i.getCharCode(D + 1)]) && m.push(jd(D + 1, C, S, m, Mm(W, i.getCharCode(D + 1), J && I), !1));
          }
        }
        var N;
        return qd(jd(i.length(), C, S, m, 0, !0));
      }
      function du(i) {
        let e = 0.5, n = 0.5;
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            e = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e = 0;
        }
        switch (i) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            n = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            n = 0;
        }
        return { horizontalAlign: e, verticalAlign: n };
      }
      function Em(i, e, n, a, u) {
        if (!a && !u) return;
        const d = i[n], m = (i[n].x + d.metrics.advance * d.scale) * a;
        for (let S = e; S <= n; S++) i[S].x -= m, i[S].y += u;
      }
      function zm(i, e, n) {
        const { horizontalAlign: a, verticalAlign: u } = du(n), d = e[0] - i.displaySize[0] * a, m = e[1] - i.displaySize[1] * u;
        return { image: i, top: m, bottom: m + i.displaySize[1], left: d, right: d + i.displaySize[0] };
      }
      function Ud(i) {
        var e, n;
        let a = i.left, u = i.top, d = i.right - a, m = i.bottom - u;
        const S = (e = i.image.textFitWidth) !== null && e !== void 0 ? e : "stretchOrShrink", I = (n = i.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", C = (i.image.content[2] - i.image.content[0]) / (i.image.content[3] - i.image.content[1]);
        if (I === "proportional") {
          if (S === "stretchOnly" && d / m < C || S === "proportional") {
            const N = Math.ceil(m * C);
            a *= N / d, d = N;
          }
        } else if (S === "proportional" && I === "stretchOnly" && C !== 0 && d / m > C) {
          const N = Math.ceil(d / C);
          u *= N / m, m = N;
        }
        return { x1: a, y1: u, x2: a + d, y2: u + m };
      }
      function Vd(i, e, n, a, u, d) {
        const m = i.image;
        let S;
        if (m.content) {
          const dt = m.content, vt = m.pixelRatio || 1;
          S = [dt[0] / vt, dt[1] / vt, m.displaySize[0] - dt[2] / vt, m.displaySize[1] - dt[3] / vt];
        }
        const I = e.left * d, C = e.right * d;
        let N, D, G, W;
        n === "width" || n === "both" ? (W = u[0] + I - a[3], D = u[0] + C + a[1]) : (W = u[0] + (I + C - m.displaySize[0]) / 2, D = W + m.displaySize[0]);
        const J = e.top * d, rt = e.bottom * d;
        return n === "height" || n === "both" ? (N = u[1] + J - a[0], G = u[1] + rt + a[2]) : (N = u[1] + (J + rt - m.displaySize[1]) / 2, G = N + m.displaySize[1]), { image: m, top: N, right: D, bottom: G, left: W, collisionPadding: S };
      }
      const eh = 255, Io = 128, Sl = eh * Io;
      function Gd(i, e) {
        const { expression: n } = e;
        if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new Xi(i + 1)) };
        if (n.kind === "source") return { kind: "source" };
        {
          const { zoomStops: a, interpolationType: u } = n;
          let d = 0;
          for (; d < a.length && a[d] <= i; ) d++;
          d = Math.max(0, d - 1);
          let m = d;
          for (; m < a.length && a[m] < i + 1; ) m++;
          m = Math.min(a.length - 1, m);
          const S = a[d], I = a[m];
          return n.kind === "composite" ? { kind: "composite", minZoom: S, maxZoom: I, interpolationType: u } : { kind: "camera", minZoom: S, maxZoom: I, minSize: n.evaluate(new Xi(S)), maxSize: n.evaluate(new Xi(I)), interpolationType: u };
        }
      }
      function pu(i, e, n) {
        let a = "never";
        const u = i.get(e);
        return u ? a = u : i.get(n) && (a = "always"), a;
      }
      const Nm = bl.VectorTileFeature.types, Dm = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Ph(i, e, n, a, u, d, m, S, I, C, N, D, G) {
        const W = S ? Math.min(Sl, Math.round(S[0])) : 0, J = S ? Math.min(Sl, Math.round(S[1])) : 0;
        i.emplaceBack(e, n, Math.round(32 * a), Math.round(32 * u), d, m, (W << 1) + (I ? 1 : 0), J, 16 * C, 16 * N, 256 * D, 256 * G);
      }
      function fu(i, e, n) {
        i.emplaceBack(e.x, e.y, n), i.emplaceBack(e.x, e.y, n), i.emplaceBack(e.x, e.y, n), i.emplaceBack(e.x, e.y, n);
      }
      function Fm(i) {
        for (const e of i.sections) if (oc(e.text)) return !0;
        return !1;
      }
      class mu {
        constructor(e) {
          this.layoutVertexArray = new tl(), this.indexArray = new rn(), this.programConfigurations = e, this.segments = new Li(), this.dynamicLayoutVertexArray = new vo(), this.opacityVertexArray = new en(), this.hasVisibleVertices = !1, this.placedSymbolArray = new ni();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(e, n, a, u) {
          this.isEmpty() || (a && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, dm.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, pm.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Dm, !0), this.opacityVertexBuffer.itemSize = 1), (a || u) && this.programConfigurations.upload(e));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      De("SymbolBuffers", mu);
      class gu {
        constructor(e, n, a) {
          this.layoutVertexArray = new e(), this.layoutAttributes = n, this.indexArray = new a(), this.segments = new Li(), this.collisionVertexArray = new Fr();
        }
        upload(e) {
          this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, fm.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      De("CollisionBuffers", gu);
      class wc {
        constructor(e) {
          this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((m) => m.id), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Hh([]), this.placementViewportMatrix = Hh([]);
          const n = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Gd(this.zoom, n["text-size"]), this.iconSizeData = Gd(this.zoom, n["icon-size"]);
          const a = this.layers[0].layout, u = a.get("symbol-sort-key"), d = a.get("symbol-z-order");
          this.canOverlap = pu(a, "text-overlap", "text-allow-overlap") !== "never" || pu(a, "icon-overlap", "icon-allow-overlap") !== "never" || a.get("text-ignore-placement") || a.get("icon-ignore-placement"), this.sortFeaturesByKey = d !== "viewport-y" && !u.isConstant(), this.sortFeaturesByY = (d === "viewport-y" || d === "auto" && !this.sortFeaturesByKey) && this.canOverlap, a.get("symbol-placement") === "point" && (this.writingModes = a.get("text-writing-mode").map((m) => v.ah[m])), this.stateDependentLayerIds = this.layers.filter((m) => m.isStateDependent()).map((m) => m.id), this.sourceID = e.sourceID;
        }
        createArrays() {
          this.text = new mu(new wo(this.layers, this.zoom, (e) => /^text/.test(e))), this.icon = new mu(new wo(this.layers, this.zoom, (e) => /^icon/.test(e))), this.glyphOffsetArray = new bi(), this.lineVertexArray = new ji(), this.symbolInstances = new ci(), this.textAnchorOffsets = new Ni();
        }
        calculateGlyphDependencies(e, n, a, u, d) {
          for (let m = 0; m < e.length; m++) if (n[e.charCodeAt(m)] = !0, (a || u) && d) {
            const S = Jc[e.charAt(m)];
            S && (n[S.charCodeAt(0)] = !0);
          }
        }
        populate(e, n, a) {
          const u = this.layers[0], d = u.layout, m = d.get("text-font"), S = d.get("text-field"), I = d.get("icon-image"), C = (S.value.kind !== "constant" || S.value.value instanceof Hr && !S.value.value.isEmpty() || S.value.value.toString().length > 0) && (m.value.kind !== "constant" || m.value.value.length > 0), N = I.value.kind !== "constant" || !!I.value.value || Object.keys(I.parameters).length > 0, D = d.get("symbol-sort-key");
          if (this.features = [], !C && !N) return;
          const G = n.iconDependencies, W = n.glyphDependencies, J = n.availableImages, rt = new Xi(this.zoom);
          for (const { feature: dt, id: vt, index: Dt, sourceLayerIndex: Lt } of e) {
            const Nt = u._featureFilter.needGeometry, Zt = So(dt, Nt);
            if (!u._featureFilter.filter(rt, Zt, a)) continue;
            let ge, Me;
            if (Nt || (Zt.geometry = rl(dt)), C) {
              const Le = u.getValueAndResolveTokens("text-field", Zt, a, J), Ae = Hr.factory(Le), Ve = this.hasRTLText = this.hasRTLText || Fm(Ae);
              (!Ve || Ln.getRTLTextPluginStatus() === "unavailable" || Ve && Ln.isParsed()) && (ge = gm(Ae, u, Zt));
            }
            if (N) {
              const Le = u.getValueAndResolveTokens("icon-image", Zt, a, J);
              Me = Le instanceof Yr ? Le : Yr.fromString(Le);
            }
            if (!ge && !Me) continue;
            const ri = this.sortFeaturesByKey ? D.evaluate(Zt, {}, a) : void 0;
            if (this.features.push({ id: vt, text: ge, icon: Me, index: Dt, sourceLayerIndex: Lt, geometry: Zt.geometry, properties: dt.properties, type: Nm[dt.type], sortKey: ri }), Me && (G[Me.name] = !0), ge) {
              const Le = m.evaluate(Zt, {}, a).join(","), Ae = d.get("text-rotation-alignment") !== "viewport" && d.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(v.ah.vertical) >= 0;
              for (const Ve of ge.sections) if (Ve.image) G[Ve.image.name] = !0;
              else {
                const Re = jl(ge.toString()), Fe = Ve.fontStack || Le, ne = W[Fe] = W[Fe] || {};
                this.calculateGlyphDependencies(Ve.text, ne, Ae, this.allowVerticalPlacement, Re);
              }
            }
          }
          d.get("symbol-placement") === "line" && (this.features = function(dt) {
            const vt = {}, Dt = {}, Lt = [];
            let Nt = 0;
            function Zt(Le) {
              Lt.push(dt[Le]), Nt++;
            }
            function ge(Le, Ae, Ve) {
              const Re = Dt[Le];
              return delete Dt[Le], Dt[Ae] = Re, Lt[Re].geometry[0].pop(), Lt[Re].geometry[0] = Lt[Re].geometry[0].concat(Ve[0]), Re;
            }
            function Me(Le, Ae, Ve) {
              const Re = vt[Ae];
              return delete vt[Ae], vt[Le] = Re, Lt[Re].geometry[0].shift(), Lt[Re].geometry[0] = Ve[0].concat(Lt[Re].geometry[0]), Re;
            }
            function ri(Le, Ae, Ve) {
              const Re = Ve ? Ae[0][Ae[0].length - 1] : Ae[0][0];
              return `${Le}:${Re.x}:${Re.y}`;
            }
            for (let Le = 0; Le < dt.length; Le++) {
              const Ae = dt[Le], Ve = Ae.geometry, Re = Ae.text ? Ae.text.toString() : null;
              if (!Re) {
                Zt(Le);
                continue;
              }
              const Fe = ri(Re, Ve), ne = ri(Re, Ve, !0);
              if (Fe in Dt && ne in vt && Dt[Fe] !== vt[ne]) {
                const We = Me(Fe, ne, Ve), qe = ge(Fe, ne, Lt[We].geometry);
                delete vt[Fe], delete Dt[ne], Dt[ri(Re, Lt[qe].geometry, !0)] = qe, Lt[We].geometry = null;
              } else Fe in Dt ? ge(Fe, ne, Ve) : ne in vt ? Me(Fe, ne, Ve) : (Zt(Le), vt[Fe] = Nt - 1, Dt[ne] = Nt - 1);
            }
            return Lt.filter((Le) => Le.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((dt, vt) => dt.sortKey - vt.sortKey);
        }
        update(e, n, a) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, n, this.layers, a), this.icon.programConfigurations.updatePaintArrays(e, n, this.layers, a));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(e) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(e, n) {
          const a = this.lineVertexArray.length;
          if (e.segment !== void 0) {
            let u = e.dist(n[e.segment + 1]), d = e.dist(n[e.segment]);
            const m = {};
            for (let S = e.segment + 1; S < n.length; S++) m[S] = { x: n[S].x, y: n[S].y, tileUnitDistanceFromAnchor: u }, S < n.length - 1 && (u += n[S + 1].dist(n[S]));
            for (let S = e.segment || 0; S >= 0; S--) m[S] = { x: n[S].x, y: n[S].y, tileUnitDistanceFromAnchor: d }, S > 0 && (d += n[S - 1].dist(n[S]));
            for (let S = 0; S < n.length; S++) {
              const I = m[S];
              this.lineVertexArray.emplaceBack(I.x, I.y, I.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: a, lineLength: this.lineVertexArray.length - a };
        }
        addSymbols(e, n, a, u, d, m, S, I, C, N, D, G) {
          const W = e.indexArray, J = e.layoutVertexArray, rt = e.segments.prepareSegment(4 * n.length, J, W, this.canOverlap ? m.sortKey : void 0), dt = this.glyphOffsetArray.length, vt = rt.vertexLength, Dt = this.allowVerticalPlacement && S === v.ah.vertical ? Math.PI / 2 : 0, Lt = m.text && m.text.sections;
          for (let Nt = 0; Nt < n.length; Nt++) {
            const { tl: Zt, tr: ge, bl: Me, br: ri, tex: Le, pixelOffsetTL: Ae, pixelOffsetBR: Ve, minFontScaleX: Re, minFontScaleY: Fe, glyphOffset: ne, isSDF: We, sectionIndex: qe } = n[Nt], hi = rt.vertexLength, Ki = ne[1];
            Ph(J, I.x, I.y, Zt.x, Ki + Zt.y, Le.x, Le.y, a, We, Ae.x, Ae.y, Re, Fe), Ph(J, I.x, I.y, ge.x, Ki + ge.y, Le.x + Le.w, Le.y, a, We, Ve.x, Ae.y, Re, Fe), Ph(J, I.x, I.y, Me.x, Ki + Me.y, Le.x, Le.y + Le.h, a, We, Ae.x, Ve.y, Re, Fe), Ph(J, I.x, I.y, ri.x, Ki + ri.y, Le.x + Le.w, Le.y + Le.h, a, We, Ve.x, Ve.y, Re, Fe), fu(e.dynamicLayoutVertexArray, I, Dt), W.emplaceBack(hi, hi + 1, hi + 2), W.emplaceBack(hi + 1, hi + 2, hi + 3), rt.vertexLength += 4, rt.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(ne[0]), Nt !== n.length - 1 && qe === n[Nt + 1].sectionIndex || e.programConfigurations.populatePaintArrays(J.length, m, m.index, {}, G, Lt && Lt[qe]);
          }
          e.placedSymbolArray.emplaceBack(I.x, I.y, dt, this.glyphOffsetArray.length - dt, vt, C, N, I.segment, a ? a[0] : 0, a ? a[1] : 0, u[0], u[1], S, 0, !1, 0, D);
        }
        _addCollisionDebugVertex(e, n, a, u, d, m) {
          return n.emplaceBack(0, 0), e.emplaceBack(a.x, a.y, u, d, Math.round(m.x), Math.round(m.y));
        }
        addCollisionDebugVertices(e, n, a, u, d, m, S) {
          const I = d.segments.prepareSegment(4, d.layoutVertexArray, d.indexArray), C = I.vertexLength, N = d.layoutVertexArray, D = d.collisionVertexArray, G = S.anchorX, W = S.anchorY;
          this._addCollisionDebugVertex(N, D, m, G, W, new O(e, n)), this._addCollisionDebugVertex(N, D, m, G, W, new O(a, n)), this._addCollisionDebugVertex(N, D, m, G, W, new O(a, u)), this._addCollisionDebugVertex(N, D, m, G, W, new O(e, u)), I.vertexLength += 4;
          const J = d.indexArray;
          J.emplaceBack(C, C + 1), J.emplaceBack(C + 1, C + 2), J.emplaceBack(C + 2, C + 3), J.emplaceBack(C + 3, C), I.primitiveLength += 4;
        }
        addDebugCollisionBoxes(e, n, a, u) {
          for (let d = e; d < n; d++) {
            const m = this.collisionBoxArray.get(d);
            this.addCollisionDebugVertices(m.x1, m.y1, m.x2, m.y2, u ? this.textCollisionBox : this.iconCollisionBox, m.anchorPoint, a);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new gu(pn, kd.members, yr), this.iconCollisionBox = new gu(pn, kd.members, yr);
          for (let e = 0; e < this.symbolInstances.length; e++) {
            const n = this.symbolInstances.get(e);
            this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(e, n, a, u, d, m, S, I, C) {
          const N = {};
          for (let D = n; D < a; D++) {
            const G = e.get(D);
            N.textBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, N.textFeatureIndex = G.featureIndex;
            break;
          }
          for (let D = u; D < d; D++) {
            const G = e.get(D);
            N.verticalTextBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, N.verticalTextFeatureIndex = G.featureIndex;
            break;
          }
          for (let D = m; D < S; D++) {
            const G = e.get(D);
            N.iconBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, N.iconFeatureIndex = G.featureIndex;
            break;
          }
          for (let D = I; D < C; D++) {
            const G = e.get(D);
            N.verticalIconBox = { x1: G.x1, y1: G.y1, x2: G.x2, y2: G.y2, anchorPointX: G.anchorPointX, anchorPointY: G.anchorPointY }, N.verticalIconFeatureIndex = G.featureIndex;
            break;
          }
          return N;
        }
        deserializeCollisionBoxes(e) {
          this.collisionArrays = [];
          for (let n = 0; n < this.symbolInstances.length; n++) {
            const a = this.symbolInstances.get(n);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, a.textBoxStartIndex, a.textBoxEndIndex, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a.iconBoxStartIndex, a.iconBoxEndIndex, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(e, n) {
          const a = e.placedSymbolArray.get(n), u = a.vertexStartIndex + 4 * a.numGlyphs;
          for (let d = a.vertexStartIndex; d < u; d += 4) e.indexArray.emplaceBack(d, d + 1, d + 2), e.indexArray.emplaceBack(d + 1, d + 2, d + 3);
        }
        getSortedSymbolIndexes(e) {
          if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const n = Math.sin(e), a = Math.cos(e), u = [], d = [], m = [];
          for (let S = 0; S < this.symbolInstances.length; ++S) {
            m.push(S);
            const I = this.symbolInstances.get(S);
            u.push(0 | Math.round(n * I.anchorX + a * I.anchorY)), d.push(I.featureIndex);
          }
          return m.sort((S, I) => u[S] - u[I] || d[I] - d[S]), m;
        }
        addToSortKeyRanges(e, n) {
          const a = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          a && a.sortKey === n ? a.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
        }
        sortFeatures(e) {
          if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const n of this.symbolInstanceIndexes) {
              const a = this.symbolInstances.get(n);
              this.featureSortOrder.push(a.featureIndex), [a.rightJustifiedTextSymbolIndex, a.centerJustifiedTextSymbolIndex, a.leftJustifiedTextSymbolIndex].forEach((u, d, m) => {
                u >= 0 && m.indexOf(u) === d && this.addIndicesForPlacedSymbol(this.text, u);
              }), a.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, a.verticalPlacedTextSymbolIndex), a.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.placedIconSymbolIndex), a.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, a.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let $d, Zd;
      De("SymbolBucket", wc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), wc.MAX_GLYPHS = 65535, wc.addDynamicAttributes = fu;
      var yu = { get paint() {
        return Zd = Zd || new o({ "icon-opacity": new Qe(Y.paint_symbol["icon-opacity"]), "icon-color": new Qe(Y.paint_symbol["icon-color"]), "icon-halo-color": new Qe(Y.paint_symbol["icon-halo-color"]), "icon-halo-width": new Qe(Y.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Qe(Y.paint_symbol["icon-halo-blur"]), "icon-translate": new je(Y.paint_symbol["icon-translate"]), "icon-translate-anchor": new je(Y.paint_symbol["icon-translate-anchor"]), "text-opacity": new Qe(Y.paint_symbol["text-opacity"]), "text-color": new Qe(Y.paint_symbol["text-color"], { runtimeType: zi, getOverride: (i) => i.textColor, hasOverride: (i) => !!i.textColor }), "text-halo-color": new Qe(Y.paint_symbol["text-halo-color"]), "text-halo-width": new Qe(Y.paint_symbol["text-halo-width"]), "text-halo-blur": new Qe(Y.paint_symbol["text-halo-blur"]), "text-translate": new je(Y.paint_symbol["text-translate"]), "text-translate-anchor": new je(Y.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return $d = $d || new o({ "symbol-placement": new je(Y.layout_symbol["symbol-placement"]), "symbol-spacing": new je(Y.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new je(Y.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Qe(Y.layout_symbol["symbol-sort-key"]), "symbol-z-order": new je(Y.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new je(Y.layout_symbol["icon-allow-overlap"]), "icon-overlap": new je(Y.layout_symbol["icon-overlap"]), "icon-ignore-placement": new je(Y.layout_symbol["icon-ignore-placement"]), "icon-optional": new je(Y.layout_symbol["icon-optional"]), "icon-rotation-alignment": new je(Y.layout_symbol["icon-rotation-alignment"]), "icon-size": new Qe(Y.layout_symbol["icon-size"]), "icon-text-fit": new je(Y.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new je(Y.layout_symbol["icon-text-fit-padding"]), "icon-image": new Qe(Y.layout_symbol["icon-image"]), "icon-rotate": new Qe(Y.layout_symbol["icon-rotate"]), "icon-padding": new Qe(Y.layout_symbol["icon-padding"]), "icon-keep-upright": new je(Y.layout_symbol["icon-keep-upright"]), "icon-offset": new Qe(Y.layout_symbol["icon-offset"]), "icon-anchor": new Qe(Y.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new je(Y.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new je(Y.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new je(Y.layout_symbol["text-rotation-alignment"]), "text-field": new Qe(Y.layout_symbol["text-field"]), "text-font": new Qe(Y.layout_symbol["text-font"]), "text-size": new Qe(Y.layout_symbol["text-size"]), "text-max-width": new Qe(Y.layout_symbol["text-max-width"]), "text-line-height": new je(Y.layout_symbol["text-line-height"]), "text-letter-spacing": new Qe(Y.layout_symbol["text-letter-spacing"]), "text-justify": new Qe(Y.layout_symbol["text-justify"]), "text-radial-offset": new Qe(Y.layout_symbol["text-radial-offset"]), "text-variable-anchor": new je(Y.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Qe(Y.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Qe(Y.layout_symbol["text-anchor"]), "text-max-angle": new je(Y.layout_symbol["text-max-angle"]), "text-writing-mode": new je(Y.layout_symbol["text-writing-mode"]), "text-rotate": new Qe(Y.layout_symbol["text-rotate"]), "text-padding": new je(Y.layout_symbol["text-padding"]), "text-keep-upright": new je(Y.layout_symbol["text-keep-upright"]), "text-transform": new Qe(Y.layout_symbol["text-transform"]), "text-offset": new Qe(Y.layout_symbol["text-offset"]), "text-allow-overlap": new je(Y.layout_symbol["text-allow-overlap"]), "text-overlap": new je(Y.layout_symbol["text-overlap"]), "text-ignore-placement": new je(Y.layout_symbol["text-ignore-placement"]), "text-optional": new je(Y.layout_symbol["text-optional"]) });
      } };
      class Wd {
        constructor(e) {
          if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = e.property.overrides ? e.property.overrides.runtimeType : cr, this.defaultValue = e;
        }
        evaluate(e) {
          if (e.formattedSection) {
            const n = this.defaultValue.property.overrides;
            if (n && n.hasOverride(e.formattedSection)) return n.getOverride(e.formattedSection);
          }
          return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(e) {
          this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      De("FormatSectionOverride", Wd, { omit: ["defaultValue"] });
      class Ih extends r {
        constructor(e) {
          super(e, yu);
        }
        recalculate(e, n) {
          if (super.recalculate(e, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const a = this.layout.get("text-writing-mode");
            if (a) {
              const u = [];
              for (const d of a) u.indexOf(d) < 0 && u.push(d);
              this.layout._values["text-writing-mode"] = u;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(e, n, a, u) {
          const d = this.layout.get(e).evaluate(n, {}, a, u), m = this._unevaluatedLayout._values[e];
          return m.isDataDriven() || oa(m.value) || !d ? d : function(S, I) {
            return I.replace(/{([^{}]+)}/g, (C, N) => S && N in S ? String(S[N]) : "");
          }(n.properties, d);
        }
        createBucket(e) {
          return new wc(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const e of yu.paint.overridableProperties) {
            if (!Ih.hasPaintOverride(this.layout, e)) continue;
            const n = this.paint.get(e), a = new Wd(n), u = new ar(a, n.property.specification);
            let d = null;
            d = n.value.kind === "constant" || n.value.kind === "source" ? new Ur("source", u) : new ss("composite", u, n.value.zoomStops), this.paint._values[e] = new hs(n.property, d, n.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(e, n, a) {
          return !(!this.layout || n.isDataDriven() || a.isDataDriven()) && Ih.hasPaintOverride(this.layout, e);
        }
        static hasPaintOverride(e, n) {
          const a = e.get("text-field"), u = yu.paint.properties[n];
          let d = !1;
          const m = (S) => {
            for (const I of S) if (u.overrides && u.overrides.hasOverride(I)) return void (d = !0);
          };
          if (a.value.kind === "constant" && a.value.value instanceof Hr) m(a.value.value.sections);
          else if (a.value.kind === "source") {
            const S = (C) => {
              d || (C instanceof gn && fr(C.value) === Vi ? m(C.value.sections) : C instanceof Qa ? m(C.sections) : C.eachChild(S));
            }, I = a.value;
            I._styleExpression && S(I._styleExpression.expression);
          }
          return d;
        }
      }
      let Xd;
      var Bm = { get paint() {
        return Xd = Xd || new o({ "background-color": new je(Y.paint_background["background-color"]), "background-pattern": new p(Y.paint_background["background-pattern"]), "background-opacity": new je(Y.paint_background["background-opacity"]) });
      } };
      class Rm extends r {
        constructor(e) {
          super(e, Bm);
        }
      }
      let Hd;
      var Om = { get paint() {
        return Hd = Hd || new o({ "raster-opacity": new je(Y.paint_raster["raster-opacity"]), "raster-hue-rotate": new je(Y.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new je(Y.paint_raster["raster-brightness-min"]), "raster-brightness-max": new je(Y.paint_raster["raster-brightness-max"]), "raster-saturation": new je(Y.paint_raster["raster-saturation"]), "raster-contrast": new je(Y.paint_raster["raster-contrast"]), "raster-resampling": new je(Y.paint_raster["raster-resampling"]), "raster-fade-duration": new je(Y.paint_raster["raster-fade-duration"]) });
      } };
      class jm extends r {
        constructor(e) {
          super(e, Om);
        }
      }
      class qm extends r {
        constructor(e) {
          super(e, {}), this.onAdd = (n) => {
            this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl);
          }, this.onRemove = (n) => {
            this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl);
          }, this.implementation = e;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class Um {
        constructor(e) {
          this._methodToThrottle = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const _u = 63710088e-1;
      class Al {
        constructor(e, n) {
          if (isNaN(e) || isNaN(n)) throw new Error(`Invalid LngLat object: (${e}, ${n})`);
          if (this.lng = +e, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Al(pe(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(e) {
          const n = Math.PI / 180, a = this.lat * n, u = e.lat * n, d = Math.sin(a) * Math.sin(u) + Math.cos(a) * Math.cos(u) * Math.cos((e.lng - this.lng) * n);
          return _u * Math.acos(Math.min(d, 1));
        }
        static convert(e) {
          if (e instanceof Al) return e;
          if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new Al(Number(e[0]), Number(e[1]));
          if (!Array.isArray(e) && typeof e == "object" && e !== null) return new Al(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Yd = 2 * Math.PI * _u;
      function Kd(i) {
        return Yd * Math.cos(i * Math.PI / 180);
      }
      function Jd(i) {
        return (180 + i) / 360;
      }
      function Qd(i) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + i * Math.PI / 360))) / 360;
      }
      function tp(i, e) {
        return i / Kd(e);
      }
      function vu(i) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90;
      }
      class ih {
        constructor(e, n, a = 0) {
          this.x = +e, this.y = +n, this.z = +a;
        }
        static fromLngLat(e, n = 0) {
          const a = Al.convert(e);
          return new ih(Jd(a.lng), Qd(a.lat), tp(n, a.lat));
        }
        toLngLat() {
          return new Al(360 * this.x - 180, vu(this.y));
        }
        toAltitude() {
          return this.z * Kd(vu(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Yd * (e = vu(this.y), 1 / Math.cos(e * Math.PI / 180));
          var e;
        }
      }
      function ep(i, e, n) {
        var a = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
        return [i * a - 2 * Math.PI * 6378137 / 2, e * a - 2 * Math.PI * 6378137 / 2];
      }
      class xu {
        constructor(e, n, a) {
          if (!function(u, d, m) {
            return !(u < 0 || u > 25 || m < 0 || m >= Math.pow(2, u) || d < 0 || d >= Math.pow(2, u));
          }(e, n, a)) throw new Error(`x=${n}, y=${a}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} 0<=z<=25 `);
          this.z = e, this.x = n, this.y = a, this.key = rh(0, e, e, n, a);
        }
        equals(e) {
          return this.z === e.z && this.x === e.x && this.y === e.y;
        }
        url(e, n, a) {
          const u = (m = this.y, S = this.z, I = ep(256 * (d = this.x), 256 * (m = Math.pow(2, S) - m - 1), S), C = ep(256 * (d + 1), 256 * (m + 1), S), I[0] + "," + I[1] + "," + C[0] + "," + C[1]);
          var d, m, S, I, C;
          const N = function(D, G, W) {
            let J, rt = "";
            for (let dt = D; dt > 0; dt--) J = 1 << dt - 1, rt += (G & J ? 1 : 0) + (W & J ? 2 : 0);
            return rt;
          }(this.z, this.x, this.y);
          return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, N).replace(/{bbox-epsg-3857}/g, u);
        }
        isChildOf(e) {
          const n = this.z - e.z;
          return n > 0 && e.x === this.x >> n && e.y === this.y >> n;
        }
        getTilePoint(e) {
          const n = Math.pow(2, this.z);
          return new O((e.x * n - this.x) * ir, (e.y * n - this.y) * ir);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class ip {
        constructor(e, n) {
          this.wrap = e, this.canonical = n, this.key = rh(e, n.z, n.z, n.x, n.y);
        }
      }
      class Zs {
        constructor(e, n, a, u, d) {
          if (e < a) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${a}`);
          this.overscaledZ = e, this.wrap = n, this.canonical = new xu(a, +u, +d), this.key = rh(n, e, a, u, d);
        }
        clone() {
          return new Zs(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(e) {
          return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
        }
        scaledTo(e) {
          if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
          const n = this.canonical.z - e;
          return e > this.canonical.z ? new Zs(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Zs(e, this.wrap, e, this.canonical.x >> n, this.canonical.y >> n);
        }
        calculateScaledKey(e, n) {
          if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
          const a = this.canonical.z - e;
          return e > this.canonical.z ? rh(this.wrap * +n, e, this.canonical.z, this.canonical.x, this.canonical.y) : rh(this.wrap * +n, e, e, this.canonical.x >> a, this.canonical.y >> a);
        }
        isChildOf(e) {
          if (e.wrap !== this.wrap) return !1;
          const n = this.canonical.z - e.canonical.z;
          return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> n && e.canonical.y === this.canonical.y >> n;
        }
        children(e) {
          if (this.overscaledZ >= e) return [new Zs(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const n = this.canonical.z + 1, a = 2 * this.canonical.x, u = 2 * this.canonical.y;
          return [new Zs(n, this.wrap, n, a, u), new Zs(n, this.wrap, n, a + 1, u), new Zs(n, this.wrap, n, a, u + 1), new Zs(n, this.wrap, n, a + 1, u + 1)];
        }
        isLessThan(e) {
          return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
        }
        wrapped() {
          return new Zs(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(e) {
          return new Zs(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new ip(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(e) {
          return this.canonical.getTilePoint(new ih(e.x - this.wrap, e.y));
        }
      }
      function rh(i, e, n, a, u) {
        (i *= 2) < 0 && (i = -1 * i - 1);
        const d = 1 << n;
        return (d * d * i + d * u + a).toString(36) + n.toString(36) + e.toString(36);
      }
      De("CanonicalTileID", xu), De("OverscaledTileID", Zs, { omit: ["posMatrix"] });
      class rp {
        constructor(e, n, a, u = 1, d = 1, m = 1, S = 0) {
          if (this.uid = e, n.height !== n.width) throw new RangeError("DEM tiles must be square");
          if (a && !["mapbox", "terrarium", "custom"].includes(a)) return void It(`"${a}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = n.height;
          const I = this.dim = n.height - 2;
          switch (this.data = new Uint32Array(n.data.buffer), a) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = u, this.greenFactor = d, this.blueFactor = m, this.baseShift = S;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let C = 0; C < I; C++) this.data[this._idx(-1, C)] = this.data[this._idx(0, C)], this.data[this._idx(I, C)] = this.data[this._idx(I - 1, C)], this.data[this._idx(C, -1)] = this.data[this._idx(C, 0)], this.data[this._idx(C, I)] = this.data[this._idx(C, I - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(I, -1)] = this.data[this._idx(I - 1, 0)], this.data[this._idx(-1, I)] = this.data[this._idx(0, I - 1)], this.data[this._idx(I, I)] = this.data[this._idx(I - 1, I - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let C = 0; C < I; C++) for (let N = 0; N < I; N++) {
            const D = this.get(C, N);
            D > this.max && (this.max = D), D < this.min && (this.min = D);
          }
        }
        get(e, n) {
          const a = new Uint8Array(this.data.buffer), u = 4 * this._idx(e, n);
          return this.unpack(a[u], a[u + 1], a[u + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(e, n) {
          if (e < -1 || e >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (n + 1) * this.stride + (e + 1);
        }
        unpack(e, n, a) {
          return e * this.redFactor + n * this.greenFactor + a * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new $s({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(e, n, a) {
          if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
          let u = n * this.dim, d = n * this.dim + this.dim, m = a * this.dim, S = a * this.dim + this.dim;
          switch (n) {
            case -1:
              u = d - 1;
              break;
            case 1:
              d = u + 1;
          }
          switch (a) {
            case -1:
              m = S - 1;
              break;
            case 1:
              S = m + 1;
          }
          const I = -n * this.dim, C = -a * this.dim;
          for (let N = m; N < S; N++) for (let D = u; D < d; D++) this.data[this._idx(D, N)] = e.data[this._idx(D + I, N + C)];
        }
      }
      De("DEMData", rp);
      class np {
        constructor(e) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let n = 0; n < e.length; n++) {
            const a = e[n];
            this._stringToNumber[a] = n, this._numberToString[n] = a;
          }
        }
        encode(e) {
          return this._stringToNumber[e];
        }
        decode(e) {
          if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[e];
        }
      }
      class sp {
        constructor(e, n, a, u, d) {
          this.type = "Feature", this._vectorTileFeature = e, e._z = n, e._x = a, e._y = u, this.properties = e.properties, this.id = d;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(e) {
          this._geometry = e;
        }
        toJSON() {
          const e = { geometry: this.geometry };
          for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (e[n] = this[n]);
          return e;
        }
      }
      class ap {
        constructor(e, n) {
          this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new go(ir, 16, 0), this.grid3D = new go(ir, 16, 0), this.featureIndexArray = new qi(), this.promoteId = n;
        }
        insert(e, n, a, u, d, m) {
          const S = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(a, u, d);
          const I = m ? this.grid3D : this.grid;
          for (let C = 0; C < n.length; C++) {
            const N = n[C], D = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let G = 0; G < N.length; G++) {
              const W = N[G];
              D[0] = Math.min(D[0], W.x), D[1] = Math.min(D[1], W.y), D[2] = Math.max(D[2], W.x), D[3] = Math.max(D[3], W.y);
            }
            D[0] < ir && D[1] < ir && D[2] >= 0 && D[3] >= 0 && I.insert(S, D[0], D[1], D[2], D[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new bl.VectorTile(new lu(this.rawTileData)).layers, this.sourceLayerCoder = new np(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(e, n, a, u) {
          this.loadVTLayers();
          const d = e.params || {}, m = ir / e.tileSize / e.scale, S = js(d.filter), I = e.queryGeometry, C = e.queryPadding * m, N = lp(I), D = this.grid.query(N.minX - C, N.minY - C, N.maxX + C, N.maxY + C), G = lp(e.cameraQueryGeometry), W = this.grid3D.query(G.minX - C, G.minY - C, G.maxX + C, G.maxY + C, (dt, vt, Dt, Lt) => function(Nt, Zt, ge, Me, ri) {
            for (const Ae of Nt) if (Zt <= Ae.x && ge <= Ae.y && Me >= Ae.x && ri >= Ae.y) return !0;
            const Le = [new O(Zt, ge), new O(Zt, ri), new O(Me, ri), new O(Me, ge)];
            if (Nt.length > 2) {
              for (const Ae of Le) if (Po(Nt, Ae)) return !0;
            }
            for (let Ae = 0; Ae < Nt.length - 1; Ae++) if (Vc(Nt[Ae], Nt[Ae + 1], Le)) return !0;
            return !1;
          }(e.cameraQueryGeometry, dt - C, vt - C, Dt + C, Lt + C));
          for (const dt of W) D.push(dt);
          D.sort(Vm);
          const J = {};
          let rt;
          for (let dt = 0; dt < D.length; dt++) {
            const vt = D[dt];
            if (vt === rt) continue;
            rt = vt;
            const Dt = this.featureIndexArray.get(vt);
            let Lt = null;
            this.loadMatchingFeature(J, Dt.bucketIndex, Dt.sourceLayerIndex, Dt.featureIndex, S, d.layers, d.availableImages, n, a, u, (Nt, Zt, ge) => (Lt || (Lt = rl(Nt)), Zt.queryIntersectsFeature(I, Nt, ge, Lt, this.z, e.transform, m, e.pixelPosMatrix)));
          }
          return J;
        }
        loadMatchingFeature(e, n, a, u, d, m, S, I, C, N, D) {
          const G = this.bucketLayerIDs[n];
          if (m && !function(dt, vt) {
            for (let Dt = 0; Dt < dt.length; Dt++) if (vt.indexOf(dt[Dt]) >= 0) return !0;
            return !1;
          }(m, G)) return;
          const W = this.sourceLayerCoder.decode(a), J = this.vtLayers[W].feature(u);
          if (d.needGeometry) {
            const dt = So(J, !0);
            if (!d.filter(new Xi(this.tileID.overscaledZ), dt, this.tileID.canonical)) return;
          } else if (!d.filter(new Xi(this.tileID.overscaledZ), J)) return;
          const rt = this.getId(J, W);
          for (let dt = 0; dt < G.length; dt++) {
            const vt = G[dt];
            if (m && m.indexOf(vt) < 0) continue;
            const Dt = I[vt];
            if (!Dt) continue;
            let Lt = {};
            rt && N && (Lt = N.getState(Dt.sourceLayer || "_geojsonTileLayer", rt));
            const Nt = Ot({}, C[vt]);
            Nt.paint = op(Nt.paint, Dt.paint, J, Lt, S), Nt.layout = op(Nt.layout, Dt.layout, J, Lt, S);
            const Zt = !D || D(J, Dt, Lt);
            if (!Zt) continue;
            const ge = new sp(J, this.z, this.x, this.y, rt);
            ge.layer = Nt;
            let Me = e[vt];
            Me === void 0 && (Me = e[vt] = []), Me.push({ featureIndex: u, feature: ge, intersectionZ: Zt });
          }
        }
        lookupSymbolFeatures(e, n, a, u, d, m, S, I) {
          const C = {};
          this.loadVTLayers();
          const N = js(d);
          for (const D of e) this.loadMatchingFeature(C, a, u, D, N, m, S, I, n);
          return C;
        }
        hasLayer(e) {
          for (const n of this.bucketLayerIDs) for (const a of n) if (e === a) return !0;
          return !1;
        }
        getId(e, n) {
          let a = e.id;
          return this.promoteId && (a = e.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof a == "boolean" && (a = Number(a))), a;
        }
      }
      function op(i, e, n, a, u) {
        return $t(i, (d, m) => {
          const S = e instanceof ua ? e.get(m) : null;
          return S && S.evaluate ? S.evaluate(n, a, u) : S;
        });
      }
      function lp(i) {
        let e = 1 / 0, n = 1 / 0, a = -1 / 0, u = -1 / 0;
        for (const d of i) e = Math.min(e, d.x), n = Math.min(n, d.y), a = Math.max(a, d.x), u = Math.max(u, d.y);
        return { minX: e, minY: n, maxX: a, maxY: u };
      }
      function Vm(i, e) {
        return e - i;
      }
      function cp(i, e, n, a, u) {
        const d = [];
        for (let m = 0; m < i.length; m++) {
          const S = i[m];
          let I;
          for (let C = 0; C < S.length - 1; C++) {
            let N = S[C], D = S[C + 1];
            N.x < e && D.x < e || (N.x < e ? N = new O(e, N.y + (e - N.x) / (D.x - N.x) * (D.y - N.y))._round() : D.x < e && (D = new O(e, N.y + (e - N.x) / (D.x - N.x) * (D.y - N.y))._round()), N.y < n && D.y < n || (N.y < n ? N = new O(N.x + (n - N.y) / (D.y - N.y) * (D.x - N.x), n)._round() : D.y < n && (D = new O(N.x + (n - N.y) / (D.y - N.y) * (D.x - N.x), n)._round()), N.x >= a && D.x >= a || (N.x >= a ? N = new O(a, N.y + (a - N.x) / (D.x - N.x) * (D.y - N.y))._round() : D.x >= a && (D = new O(a, N.y + (a - N.x) / (D.x - N.x) * (D.y - N.y))._round()), N.y >= u && D.y >= u || (N.y >= u ? N = new O(N.x + (u - N.y) / (D.y - N.y) * (D.x - N.x), u)._round() : D.y >= u && (D = new O(N.x + (u - N.y) / (D.y - N.y) * (D.x - N.x), u)._round()), I && N.equals(I[I.length - 1]) || (I = [N], d.push(I)), I.push(D)))));
          }
        }
        return d;
      }
      De("FeatureIndex", ap, { omit: ["rawTileData", "sourceLayerCoder"] });
      class Pl extends O {
        constructor(e, n, a, u) {
          super(e, n), this.angle = a, u !== void 0 && (this.segment = u);
        }
        clone() {
          return new Pl(this.x, this.y, this.angle, this.segment);
        }
      }
      function hp(i, e, n, a, u) {
        if (e.segment === void 0 || n === 0) return !0;
        let d = e, m = e.segment + 1, S = 0;
        for (; S > -n / 2; ) {
          if (m--, m < 0) return !1;
          S -= i[m].dist(d), d = i[m];
        }
        S += i[m].dist(i[m + 1]), m++;
        const I = [];
        let C = 0;
        for (; S < n / 2; ) {
          const N = i[m], D = i[m + 1];
          if (!D) return !1;
          let G = i[m - 1].angleTo(N) - N.angleTo(D);
          for (G = Math.abs((G + 3 * Math.PI) % (2 * Math.PI) - Math.PI), I.push({ distance: S, angleDelta: G }), C += G; S - I[0].distance > a; ) C -= I.shift().angleDelta;
          if (C > u) return !1;
          m++, S += N.dist(D);
        }
        return !0;
      }
      function up(i) {
        let e = 0;
        for (let n = 0; n < i.length - 1; n++) e += i[n].dist(i[n + 1]);
        return e;
      }
      function dp(i, e, n) {
        return i ? 0.6 * e * n : 0;
      }
      function pp(i, e) {
        return Math.max(i ? i.right - i.left : 0, e ? e.right - e.left : 0);
      }
      function Gm(i, e, n, a, u, d) {
        const m = dp(n, u, d), S = pp(n, a) * d;
        let I = 0;
        const C = up(i) / 2;
        for (let N = 0; N < i.length - 1; N++) {
          const D = i[N], G = i[N + 1], W = D.dist(G);
          if (I + W > C) {
            const J = (C - I) / W, rt = Or.number(D.x, G.x, J), dt = Or.number(D.y, G.y, J), vt = new Pl(rt, dt, G.angleTo(D), N);
            return vt._round(), !m || hp(i, vt, S, m, e) ? vt : void 0;
          }
          I += W;
        }
      }
      function $m(i, e, n, a, u, d, m, S, I) {
        const C = dp(a, d, m), N = pp(a, u), D = N * m, G = i[0].x === 0 || i[0].x === I || i[0].y === 0 || i[0].y === I;
        return e - D < e / 4 && (e = D + e / 4), fp(i, G ? e / 2 * S % e : (N / 2 + 2 * d) * m * S % e, e, C, n, D, G, !1, I);
      }
      function fp(i, e, n, a, u, d, m, S, I) {
        const C = d / 2, N = up(i);
        let D = 0, G = e - n, W = [];
        for (let J = 0; J < i.length - 1; J++) {
          const rt = i[J], dt = i[J + 1], vt = rt.dist(dt), Dt = dt.angleTo(rt);
          for (; G + n < D + vt; ) {
            G += n;
            const Lt = (G - D) / vt, Nt = Or.number(rt.x, dt.x, Lt), Zt = Or.number(rt.y, dt.y, Lt);
            if (Nt >= 0 && Nt < I && Zt >= 0 && Zt < I && G - C >= 0 && G + C <= N) {
              const ge = new Pl(Nt, Zt, Dt, J);
              ge._round(), a && !hp(i, ge, d, a, u) || W.push(ge);
            }
          }
          D += vt;
        }
        return S || W.length || m || (W = fp(i, D / 2, n, a, u, d, m, !0, I)), W;
      }
      De("Anchor", Pl);
      const Sc = ds;
      function mp(i, e, n, a) {
        const u = [], d = i.image, m = d.pixelRatio, S = d.paddedRect.w - 2 * Sc, I = d.paddedRect.h - 2 * Sc;
        let C = { x1: i.left, y1: i.top, x2: i.right, y2: i.bottom };
        const N = d.stretchX || [[0, S]], D = d.stretchY || [[0, I]], G = (ne, We) => ne + We[1] - We[0], W = N.reduce(G, 0), J = D.reduce(G, 0), rt = S - W, dt = I - J;
        let vt = 0, Dt = W, Lt = 0, Nt = J, Zt = 0, ge = rt, Me = 0, ri = dt;
        if (d.content && a) {
          const ne = d.content, We = ne[2] - ne[0], qe = ne[3] - ne[1];
          (d.textFitWidth || d.textFitHeight) && (C = Ud(i)), vt = kh(N, 0, ne[0]), Lt = kh(D, 0, ne[1]), Dt = kh(N, ne[0], ne[2]), Nt = kh(D, ne[1], ne[3]), Zt = ne[0] - vt, Me = ne[1] - Lt, ge = We - Dt, ri = qe - Nt;
        }
        const Le = C.x1, Ae = C.y1, Ve = C.x2 - Le, Re = C.y2 - Ae, Fe = (ne, We, qe, hi) => {
          const Ki = Th(ne.stretch - vt, Dt, Ve, Le), Yi = Lh(ne.fixed - Zt, ge, ne.stretch, W), sn = Th(We.stretch - Lt, Nt, Re, Ae), ya = Lh(We.fixed - Me, ri, We.stretch, J), xn = Th(qe.stretch - vt, Dt, Ve, Le), an = Lh(qe.fixed - Zt, ge, qe.stretch, W), Vn = Th(hi.stretch - Lt, Nt, Re, Ae), Gn = Lh(hi.fixed - Me, ri, hi.stretch, J), $n = new O(Ki, sn), Tr = new O(xn, sn), on = new O(xn, Vn), zn = new O(Ki, Vn), bn = new O(Yi / m, ya / m), Zn = new O(an / m, Gn / m), wn = e * Math.PI / 180;
          if (wn) {
            const Ui = Math.sin(wn), rr = Math.cos(wn), lr = [rr, -Ui, Ui, rr];
            $n._matMult(lr), Tr._matMult(lr), zn._matMult(lr), on._matMult(lr);
          }
          const Ws = ne.stretch + ne.fixed, ps = We.stretch + We.fixed;
          return { tl: $n, tr: Tr, bl: zn, br: on, tex: { x: d.paddedRect.x + Sc + Ws, y: d.paddedRect.y + Sc + ps, w: qe.stretch + qe.fixed - Ws, h: hi.stretch + hi.fixed - ps }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: bn, pixelOffsetBR: Zn, minFontScaleX: ge / m / Ve, minFontScaleY: ri / m / Re, isSDF: n };
        };
        if (a && (d.stretchX || d.stretchY)) {
          const ne = gp(N, rt, W), We = gp(D, dt, J);
          for (let qe = 0; qe < ne.length - 1; qe++) {
            const hi = ne[qe], Ki = ne[qe + 1];
            for (let Yi = 0; Yi < We.length - 1; Yi++) u.push(Fe(hi, We[Yi], Ki, We[Yi + 1]));
          }
        } else u.push(Fe({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: S + 1 }, { fixed: 0, stretch: I + 1 }));
        return u;
      }
      function kh(i, e, n) {
        let a = 0;
        for (const u of i) a += Math.max(e, Math.min(n, u[1])) - Math.max(e, Math.min(n, u[0]));
        return a;
      }
      function gp(i, e, n) {
        const a = [{ fixed: -Sc, stretch: 0 }];
        for (const [u, d] of i) {
          const m = a[a.length - 1];
          a.push({ fixed: u - m.stretch, stretch: m.stretch }), a.push({ fixed: u - m.stretch, stretch: m.stretch + (d - u) });
        }
        return a.push({ fixed: e + Sc, stretch: n }), a;
      }
      function Th(i, e, n, a) {
        return i / e * n + a;
      }
      function Lh(i, e, n, a) {
        return i - e * n / a;
      }
      class Ch {
        constructor(e, n, a, u, d, m, S, I, C, N) {
          var D;
          if (this.boxStartIndex = e.length, C) {
            let G = m.top, W = m.bottom;
            const J = m.collisionPadding;
            J && (G -= J[1], W += J[3]);
            let rt = W - G;
            rt > 0 && (rt = Math.max(10, rt), this.circleDiameter = rt);
          } else {
            const G = !((D = m.image) === null || D === void 0) && D.content && (m.image.textFitWidth || m.image.textFitHeight) ? Ud(m) : { x1: m.left, y1: m.top, x2: m.right, y2: m.bottom };
            G.y1 = G.y1 * S - I[0], G.y2 = G.y2 * S + I[2], G.x1 = G.x1 * S - I[3], G.x2 = G.x2 * S + I[1];
            const W = m.collisionPadding;
            if (W && (G.x1 -= W[0] * S, G.y1 -= W[1] * S, G.x2 += W[2] * S, G.y2 += W[3] * S), N) {
              const J = new O(G.x1, G.y1), rt = new O(G.x2, G.y1), dt = new O(G.x1, G.y2), vt = new O(G.x2, G.y2), Dt = N * Math.PI / 180;
              J._rotate(Dt), rt._rotate(Dt), dt._rotate(Dt), vt._rotate(Dt), G.x1 = Math.min(J.x, rt.x, dt.x, vt.x), G.x2 = Math.max(J.x, rt.x, dt.x, vt.x), G.y1 = Math.min(J.y, rt.y, dt.y, vt.y), G.y2 = Math.max(J.y, rt.y, dt.y, vt.y);
            }
            e.emplaceBack(n.x, n.y, G.x1, G.y1, G.x2, G.y2, a, u, d);
          }
          this.boxEndIndex = e.length;
        }
      }
      class Zm {
        constructor(e = [], n = (a, u) => a < u ? -1 : a > u ? 1 : 0) {
          if (this.data = e, this.length = this.data.length, this.compare = n, this.length > 0) for (let a = (this.length >> 1) - 1; a >= 0; a--) this._down(a);
        }
        push(e) {
          this.data.push(e), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const e = this.data[0], n = this.data.pop();
          return --this.length > 0 && (this.data[0] = n, this._down(0)), e;
        }
        peek() {
          return this.data[0];
        }
        _up(e) {
          const { data: n, compare: a } = this, u = n[e];
          for (; e > 0; ) {
            const d = e - 1 >> 1, m = n[d];
            if (a(u, m) >= 0) break;
            n[e] = m, e = d;
          }
          n[e] = u;
        }
        _down(e) {
          const { data: n, compare: a } = this, u = this.length >> 1, d = n[e];
          for (; e < u; ) {
            let m = 1 + (e << 1);
            const S = m + 1;
            if (S < this.length && a(n[S], n[m]) < 0 && (m = S), a(n[m], d) >= 0) break;
            n[e] = n[m], e = m;
          }
          n[e] = d;
        }
      }
      function Wm(i, e = 1, n = !1) {
        let a = 1 / 0, u = 1 / 0, d = -1 / 0, m = -1 / 0;
        const S = i[0];
        for (let W = 0; W < S.length; W++) {
          const J = S[W];
          (!W || J.x < a) && (a = J.x), (!W || J.y < u) && (u = J.y), (!W || J.x > d) && (d = J.x), (!W || J.y > m) && (m = J.y);
        }
        const I = Math.min(d - a, m - u);
        let C = I / 2;
        const N = new Zm([], Xm);
        if (I === 0) return new O(a, u);
        for (let W = a; W < d; W += I) for (let J = u; J < m; J += I) N.push(new Ac(W + C, J + C, C, i));
        let D = function(W) {
          let J = 0, rt = 0, dt = 0;
          const vt = W[0];
          for (let Dt = 0, Lt = vt.length, Nt = Lt - 1; Dt < Lt; Nt = Dt++) {
            const Zt = vt[Dt], ge = vt[Nt], Me = Zt.x * ge.y - ge.x * Zt.y;
            rt += (Zt.x + ge.x) * Me, dt += (Zt.y + ge.y) * Me, J += 3 * Me;
          }
          return new Ac(rt / J, dt / J, 0, W);
        }(i), G = N.length;
        for (; N.length; ) {
          const W = N.pop();
          (W.d > D.d || !D.d) && (D = W, n && console.log("found best %d after %d probes", Math.round(1e4 * W.d) / 1e4, G)), W.max - D.d <= e || (C = W.h / 2, N.push(new Ac(W.p.x - C, W.p.y - C, C, i)), N.push(new Ac(W.p.x + C, W.p.y - C, C, i)), N.push(new Ac(W.p.x - C, W.p.y + C, C, i)), N.push(new Ac(W.p.x + C, W.p.y + C, C, i)), G += 4);
        }
        return n && (console.log(`num probes: ${G}`), console.log(`best distance: ${D.d}`)), D.p;
      }
      function Xm(i, e) {
        return e.max - i.max;
      }
      function Ac(i, e, n, a) {
        this.p = new O(i, e), this.h = n, this.d = function(u, d) {
          let m = !1, S = 1 / 0;
          for (let I = 0; I < d.length; I++) {
            const C = d[I];
            for (let N = 0, D = C.length, G = D - 1; N < D; G = N++) {
              const W = C[N], J = C[G];
              W.y > u.y != J.y > u.y && u.x < (J.x - W.x) * (u.y - W.y) / (J.y - W.y) + W.x && (m = !m), S = Math.min(S, Uc(u, W, J));
            }
          }
          return (m ? 1 : -1) * Math.sqrt(S);
        }(this.p, a), this.max = this.d + this.h * Math.SQRT2;
      }
      var vn;
      v.aq = void 0, (vn = v.aq || (v.aq = {}))[vn.center = 1] = "center", vn[vn.left = 2] = "left", vn[vn.right = 3] = "right", vn[vn.top = 4] = "top", vn[vn.bottom = 5] = "bottom", vn[vn["top-left"] = 6] = "top-left", vn[vn["top-right"] = 7] = "top-right", vn[vn["bottom-left"] = 8] = "bottom-left", vn[vn["bottom-right"] = 9] = "bottom-right";
      const Il = 7, bu = Number.POSITIVE_INFINITY;
      function yp(i, e) {
        return e[1] !== bu ? function(n, a, u) {
          let d = 0, m = 0;
          switch (a = Math.abs(a), u = Math.abs(u), n) {
            case "top-right":
            case "top-left":
            case "top":
              m = u - Il;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              m = -u + Il;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
            case "right":
              d = -a;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              d = a;
          }
          return [d, m];
        }(i, e[0], e[1]) : function(n, a) {
          let u = 0, d = 0;
          a < 0 && (a = 0);
          const m = a / Math.SQRT2;
          switch (n) {
            case "top-right":
            case "top-left":
              d = m - Il;
              break;
            case "bottom-right":
            case "bottom-left":
              d = -m + Il;
              break;
            case "bottom":
              d = -a + Il;
              break;
            case "top":
              d = a - Il;
          }
          switch (n) {
            case "top-right":
            case "bottom-right":
              u = -m;
              break;
            case "top-left":
            case "bottom-left":
              u = m;
              break;
            case "left":
              u = a;
              break;
            case "right":
              u = -a;
          }
          return [u, d];
        }(i, e[0]);
      }
      function _p(i, e, n) {
        var a;
        const u = i.layout, d = (a = u.get("text-variable-anchor-offset")) === null || a === void 0 ? void 0 : a.evaluate(e, {}, n);
        if (d) {
          const S = d.values, I = [];
          for (let C = 0; C < S.length; C += 2) {
            const N = I[C] = S[C], D = S[C + 1].map((G) => G * Gr);
            N.startsWith("top") ? D[1] -= Il : N.startsWith("bottom") && (D[1] += Il), I[C + 1] = D;
          }
          return new mn(I);
        }
        const m = u.get("text-variable-anchor");
        if (m) {
          let S;
          S = i._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [u.get("text-radial-offset").evaluate(e, {}, n) * Gr, bu] : u.get("text-offset").evaluate(e, {}, n).map((C) => C * Gr);
          const I = [];
          for (const C of m) I.push(C, yp(C, S));
          return new mn(I);
        }
        return null;
      }
      function wu(i) {
        switch (i) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Hm(i, e, n, a, u, d, m, S, I, C, N) {
        let D = d.textMaxSize.evaluate(e, {});
        D === void 0 && (D = m);
        const G = i.layers[0].layout, W = G.get("icon-offset").evaluate(e, {}, N), J = xp(n.horizontal), rt = m / 24, dt = i.tilePixelRatio * rt, vt = i.tilePixelRatio * D / 24, Dt = i.tilePixelRatio * S, Lt = i.tilePixelRatio * G.get("symbol-spacing"), Nt = G.get("text-padding") * i.tilePixelRatio, Zt = function(ne, We, qe, hi = 1) {
          const Ki = ne.get("icon-padding").evaluate(We, {}, qe), Yi = Ki && Ki.values;
          return [Yi[0] * hi, Yi[1] * hi, Yi[2] * hi, Yi[3] * hi];
        }(G, e, N, i.tilePixelRatio), ge = G.get("text-max-angle") / 180 * Math.PI, Me = G.get("text-rotation-alignment") !== "viewport" && G.get("symbol-placement") !== "point", ri = G.get("icon-rotation-alignment") === "map" && G.get("symbol-placement") !== "point", Le = G.get("symbol-placement"), Ae = Lt / 2, Ve = G.get("icon-text-fit");
        let Re;
        a && Ve !== "none" && (i.allowVerticalPlacement && n.vertical && (Re = Vd(a, n.vertical, Ve, G.get("icon-text-fit-padding"), W, rt)), J && (a = Vd(a, J, Ve, G.get("icon-text-fit-padding"), W, rt)));
        const Fe = (ne, We) => {
          We.x < 0 || We.x >= ir || We.y < 0 || We.y >= ir || function(qe, hi, Ki, Yi, sn, ya, xn, an, Vn, Gn, $n, Tr, on, zn, bn, Zn, wn, Ws, ps, Ui, rr, lr, Cs, br, Pc) {
            const ko = qe.addToLineVertexArray(hi, Ki);
            let To, _a, Xs, fn, al = 0, ah = 0, Ap = 0, Pp = 0, Cu = -1, Mu = -1;
            const ol = {};
            let Ip = vl("");
            if (qe.allowVerticalPlacement && Yi.vertical) {
              const Nn = an.layout.get("text-rotate").evaluate(rr, {}, br) + 90;
              Xs = new Ch(Vn, hi, Gn, $n, Tr, Yi.vertical, on, zn, bn, Nn), xn && (fn = new Ch(Vn, hi, Gn, $n, Tr, xn, wn, Ws, bn, Nn));
            }
            if (sn) {
              const Nn = an.layout.get("icon-rotate").evaluate(rr, {}), Hs = an.layout.get("icon-text-fit") !== "none", Yl = mp(sn, Nn, Cs, Hs), Ra = xn ? mp(xn, Nn, Cs, Hs) : void 0;
              _a = new Ch(Vn, hi, Gn, $n, Tr, sn, wn, Ws, !1, Nn), al = 4 * Yl.length;
              const Kl = qe.iconSizeData;
              let Lo = null;
              Kl.kind === "source" ? (Lo = [Io * an.layout.get("icon-size").evaluate(rr, {})], Lo[0] > Sl && It(`${qe.layerIds[0]}: Value for "icon-size" is >= ${eh}. Reduce your "icon-size".`)) : Kl.kind === "composite" && (Lo = [Io * lr.compositeIconSizes[0].evaluate(rr, {}, br), Io * lr.compositeIconSizes[1].evaluate(rr, {}, br)], (Lo[0] > Sl || Lo[1] > Sl) && It(`${qe.layerIds[0]}: Value for "icon-size" is >= ${eh}. Reduce your "icon-size".`)), qe.addSymbols(qe.icon, Yl, Lo, Ui, ps, rr, v.ah.none, hi, ko.lineStartIndex, ko.lineLength, -1, br), Cu = qe.icon.placedSymbolArray.length - 1, Ra && (ah = 4 * Ra.length, qe.addSymbols(qe.icon, Ra, Lo, Ui, ps, rr, v.ah.vertical, hi, ko.lineStartIndex, ko.lineLength, -1, br), Mu = qe.icon.placedSymbolArray.length - 1);
            }
            const kp = Object.keys(Yi.horizontal);
            for (const Nn of kp) {
              const Hs = Yi.horizontal[Nn];
              if (!To) {
                Ip = vl(Hs.text);
                const Ra = an.layout.get("text-rotate").evaluate(rr, {}, br);
                To = new Ch(Vn, hi, Gn, $n, Tr, Hs, on, zn, bn, Ra);
              }
              const Yl = Hs.positionedLines.length === 1;
              if (Ap += vp(qe, hi, Hs, ya, an, bn, rr, Zn, ko, Yi.vertical ? v.ah.horizontal : v.ah.horizontalOnly, Yl ? kp : [Nn], ol, Cu, lr, br), Yl) break;
            }
            Yi.vertical && (Pp += vp(qe, hi, Yi.vertical, ya, an, bn, rr, Zn, ko, v.ah.vertical, ["vertical"], ol, Mu, lr, br));
            const Jm = To ? To.boxStartIndex : qe.collisionBoxArray.length, Qm = To ? To.boxEndIndex : qe.collisionBoxArray.length, tg = Xs ? Xs.boxStartIndex : qe.collisionBoxArray.length, eg = Xs ? Xs.boxEndIndex : qe.collisionBoxArray.length, ig = _a ? _a.boxStartIndex : qe.collisionBoxArray.length, rg = _a ? _a.boxEndIndex : qe.collisionBoxArray.length, ng = fn ? fn.boxStartIndex : qe.collisionBoxArray.length, sg = fn ? fn.boxEndIndex : qe.collisionBoxArray.length;
            let Ba = -1;
            const Eh = (Nn, Hs) => Nn && Nn.circleDiameter ? Math.max(Nn.circleDiameter, Hs) : Hs;
            Ba = Eh(To, Ba), Ba = Eh(Xs, Ba), Ba = Eh(_a, Ba), Ba = Eh(fn, Ba);
            const Tp = Ba > -1 ? 1 : 0;
            Tp && (Ba *= Pc / Gr), qe.glyphOffsetArray.length >= wc.MAX_GLYPHS && It("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), rr.sortKey !== void 0 && qe.addToSortKeyRanges(qe.symbolInstances.length, rr.sortKey);
            const ag = _p(an, rr, br), [og, lg] = function(Nn, Hs) {
              const Yl = Nn.length, Ra = Hs == null ? void 0 : Hs.values;
              if ((Ra == null ? void 0 : Ra.length) > 0) for (let Kl = 0; Kl < Ra.length; Kl += 2) {
                const Lo = Ra[Kl + 1];
                Nn.emplaceBack(v.aq[Ra[Kl]], Lo[0], Lo[1]);
              }
              return [Yl, Nn.length];
            }(qe.textAnchorOffsets, ag);
            qe.symbolInstances.emplaceBack(hi.x, hi.y, ol.right >= 0 ? ol.right : -1, ol.center >= 0 ? ol.center : -1, ol.left >= 0 ? ol.left : -1, ol.vertical || -1, Cu, Mu, Ip, Jm, Qm, tg, eg, ig, rg, ng, sg, Gn, Ap, Pp, al, ah, Tp, 0, on, Ba, og, lg);
          }(i, We, ne, n, a, u, Re, i.layers[0], i.collisionBoxArray, e.index, e.sourceLayerIndex, i.index, dt, [Nt, Nt, Nt, Nt], Me, I, Dt, Zt, ri, W, e, d, C, N, m);
        };
        if (Le === "line") for (const ne of cp(e.geometry, 0, 0, ir, ir)) {
          const We = $m(ne, Lt, ge, n.vertical || J, a, 24, vt, i.overscaling, ir);
          for (const qe of We) J && Ym(i, J.text, Ae, qe) || Fe(ne, qe);
        }
        else if (Le === "line-center") {
          for (const ne of e.geometry) if (ne.length > 1) {
            const We = Gm(ne, ge, n.vertical || J, a, 24, vt);
            We && Fe(ne, We);
          }
        } else if (e.type === "Polygon") for (const ne of ys(e.geometry, 0)) {
          const We = Wm(ne, 16);
          Fe(ne[0], new Pl(We.x, We.y, 0));
        }
        else if (e.type === "LineString") for (const ne of e.geometry) Fe(ne, new Pl(ne[0].x, ne[0].y, 0));
        else if (e.type === "Point") for (const ne of e.geometry) for (const We of ne) Fe([We], new Pl(We.x, We.y, 0));
      }
      function vp(i, e, n, a, u, d, m, S, I, C, N, D, G, W, J) {
        const rt = function(Dt, Lt, Nt, Zt, ge, Me, ri, Le) {
          const Ae = Zt.layout.get("text-rotate").evaluate(Me, {}) * Math.PI / 180, Ve = [];
          for (const Re of Lt.positionedLines) for (const Fe of Re.positionedGlyphs) {
            if (!Fe.rect) continue;
            const ne = Fe.rect || {};
            let We = Dd + 1, qe = !0, hi = 1, Ki = 0;
            const Yi = (ge || Le) && Fe.vertical, sn = Fe.metrics.advance * Fe.scale / 2;
            if (Le && Lt.verticalizable && (Ki = Re.lineOffset / 2 - (Fe.imageName ? -(Gr - Fe.metrics.width * Fe.scale) / 2 : (Fe.scale - 1) * Gr)), Fe.imageName) {
              const Ui = ri[Fe.imageName];
              qe = Ui.sdf, hi = Ui.pixelRatio, We = ds / hi;
            }
            const ya = ge ? [Fe.x + sn, Fe.y] : [0, 0];
            let xn = ge ? [0, 0] : [Fe.x + sn + Nt[0], Fe.y + Nt[1] - Ki], an = [0, 0];
            Yi && (an = xn, xn = [0, 0]);
            const Vn = Fe.metrics.isDoubleResolution ? 2 : 1, Gn = (Fe.metrics.left - We) * Fe.scale - sn + xn[0], $n = (-Fe.metrics.top - We) * Fe.scale + xn[1], Tr = Gn + ne.w / Vn * Fe.scale / hi, on = $n + ne.h / Vn * Fe.scale / hi, zn = new O(Gn, $n), bn = new O(Tr, $n), Zn = new O(Gn, on), wn = new O(Tr, on);
            if (Yi) {
              const Ui = new O(-sn, sn - Qc), rr = -Math.PI / 2, lr = Gr / 2 - sn, Cs = new O(5 - Qc - lr, -(Fe.imageName ? lr : 0)), br = new O(...an);
              zn._rotateAround(rr, Ui)._add(Cs)._add(br), bn._rotateAround(rr, Ui)._add(Cs)._add(br), Zn._rotateAround(rr, Ui)._add(Cs)._add(br), wn._rotateAround(rr, Ui)._add(Cs)._add(br);
            }
            if (Ae) {
              const Ui = Math.sin(Ae), rr = Math.cos(Ae), lr = [rr, -Ui, Ui, rr];
              zn._matMult(lr), bn._matMult(lr), Zn._matMult(lr), wn._matMult(lr);
            }
            const Ws = new O(0, 0), ps = new O(0, 0);
            Ve.push({ tl: zn, tr: bn, bl: Zn, br: wn, tex: ne, writingMode: Lt.writingMode, glyphOffset: ya, sectionIndex: Fe.sectionIndex, isSDF: qe, pixelOffsetTL: Ws, pixelOffsetBR: ps, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return Ve;
        }(0, n, S, u, d, m, a, i.allowVerticalPlacement), dt = i.textSizeData;
        let vt = null;
        dt.kind === "source" ? (vt = [Io * u.layout.get("text-size").evaluate(m, {})], vt[0] > Sl && It(`${i.layerIds[0]}: Value for "text-size" is >= ${eh}. Reduce your "text-size".`)) : dt.kind === "composite" && (vt = [Io * W.compositeTextSizes[0].evaluate(m, {}, J), Io * W.compositeTextSizes[1].evaluate(m, {}, J)], (vt[0] > Sl || vt[1] > Sl) && It(`${i.layerIds[0]}: Value for "text-size" is >= ${eh}. Reduce your "text-size".`)), i.addSymbols(i.text, rt, vt, S, d, m, C, e, I.lineStartIndex, I.lineLength, G, J);
        for (const Dt of N) D[Dt] = i.text.placedSymbolArray.length - 1;
        return 4 * rt.length;
      }
      function xp(i) {
        for (const e in i) return i[e];
        return null;
      }
      function Ym(i, e, n, a) {
        const u = i.compareText;
        if (e in u) {
          const d = u[e];
          for (let m = d.length - 1; m >= 0; m--) if (a.dist(d[m]) < n) return !0;
        } else u[e] = [];
        return u[e].push(a), !1;
      }
      const bp = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class Su {
        static from(e) {
          if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [n, a] = new Uint8Array(e, 0, 2);
          if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const u = a >> 4;
          if (u !== 1) throw new Error(`Got v${u} data when expected v1.`);
          const d = bp[15 & a];
          if (!d) throw new Error("Unrecognized array type.");
          const [m] = new Uint16Array(e, 2, 1), [S] = new Uint32Array(e, 4, 1);
          return new Su(S, m, d, e);
        }
        constructor(e, n = 64, a = Float64Array, u) {
          if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
          this.numItems = +e, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = a, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
          const d = bp.indexOf(this.ArrayType), m = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, S = e * this.IndexArrayType.BYTES_PER_ELEMENT, I = (8 - S % 8) % 8;
          if (d < 0) throw new Error(`Unexpected typed array class: ${a}.`);
          u && u instanceof ArrayBuffer ? (this.data = u, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + S + I, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + m + S + I), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + S + I, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + d]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = e);
        }
        add(e, n) {
          const a = this._pos >> 1;
          return this.ids[a] = a, this.coords[this._pos++] = e, this.coords[this._pos++] = n, a;
        }
        finish() {
          const e = this._pos >> 1;
          if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
          return Au(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(e, n, a, u) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: d, coords: m, nodeSize: S } = this, I = [0, d.length - 1, 0], C = [];
          for (; I.length; ) {
            const N = I.pop() || 0, D = I.pop() || 0, G = I.pop() || 0;
            if (D - G <= S) {
              for (let dt = G; dt <= D; dt++) {
                const vt = m[2 * dt], Dt = m[2 * dt + 1];
                vt >= e && vt <= a && Dt >= n && Dt <= u && C.push(d[dt]);
              }
              continue;
            }
            const W = G + D >> 1, J = m[2 * W], rt = m[2 * W + 1];
            J >= e && J <= a && rt >= n && rt <= u && C.push(d[W]), (N === 0 ? e <= J : n <= rt) && (I.push(G), I.push(W - 1), I.push(1 - N)), (N === 0 ? a >= J : u >= rt) && (I.push(W + 1), I.push(D), I.push(1 - N));
          }
          return C;
        }
        within(e, n, a) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: u, coords: d, nodeSize: m } = this, S = [0, u.length - 1, 0], I = [], C = a * a;
          for (; S.length; ) {
            const N = S.pop() || 0, D = S.pop() || 0, G = S.pop() || 0;
            if (D - G <= m) {
              for (let dt = G; dt <= D; dt++) Sp(d[2 * dt], d[2 * dt + 1], e, n) <= C && I.push(u[dt]);
              continue;
            }
            const W = G + D >> 1, J = d[2 * W], rt = d[2 * W + 1];
            Sp(J, rt, e, n) <= C && I.push(u[W]), (N === 0 ? e - a <= J : n - a <= rt) && (S.push(G), S.push(W - 1), S.push(1 - N)), (N === 0 ? e + a >= J : n + a >= rt) && (S.push(W + 1), S.push(D), S.push(1 - N));
          }
          return I;
        }
      }
      function Au(i, e, n, a, u, d) {
        if (u - a <= n) return;
        const m = a + u >> 1;
        wp(i, e, m, a, u, d), Au(i, e, n, a, m - 1, 1 - d), Au(i, e, n, m + 1, u, 1 - d);
      }
      function wp(i, e, n, a, u, d) {
        for (; u > a; ) {
          if (u - a > 600) {
            const C = u - a + 1, N = n - a + 1, D = Math.log(C), G = 0.5 * Math.exp(2 * D / 3), W = 0.5 * Math.sqrt(D * G * (C - G) / C) * (N - C / 2 < 0 ? -1 : 1);
            wp(i, e, n, Math.max(a, Math.floor(n - N * G / C + W)), Math.min(u, Math.floor(n + (C - N) * G / C + W)), d);
          }
          const m = e[2 * n + d];
          let S = a, I = u;
          for (nh(i, e, a, n), e[2 * u + d] > m && nh(i, e, a, u); S < I; ) {
            for (nh(i, e, S, I), S++, I--; e[2 * S + d] < m; ) S++;
            for (; e[2 * I + d] > m; ) I--;
          }
          e[2 * a + d] === m ? nh(i, e, a, I) : (I++, nh(i, e, I, u)), I <= n && (a = I + 1), n <= I && (u = I - 1);
        }
      }
      function nh(i, e, n, a) {
        Pu(i, n, a), Pu(e, 2 * n, 2 * a), Pu(e, 2 * n + 1, 2 * a + 1);
      }
      function Pu(i, e, n) {
        const a = i[e];
        i[e] = i[n], i[n] = a;
      }
      function Sp(i, e, n, a) {
        const u = i - n, d = e - a;
        return u * u + d * d;
      }
      var Iu;
      v.bg = void 0, (Iu = v.bg || (v.bg = {})).create = "create", Iu.load = "load", Iu.fullLoad = "fullLoad";
      let Mh = null, sh = [];
      const ku = 1e3 / 60, Tu = "loadTime", Lu = "fullLoadTime", Km = { mark(i) {
        performance.mark(i);
      }, frame(i) {
        const e = i;
        Mh != null && sh.push(e - Mh), Mh = e;
      }, clearMetrics() {
        Mh = null, sh = [], performance.clearMeasures(Tu), performance.clearMeasures(Lu);
        for (const i in v.bg) performance.clearMarks(v.bg[i]);
      }, getPerformanceMetrics() {
        performance.measure(Tu, v.bg.create, v.bg.load), performance.measure(Lu, v.bg.create, v.bg.fullLoad);
        const i = performance.getEntriesByName(Tu)[0].duration, e = performance.getEntriesByName(Lu)[0].duration, n = sh.length, a = 1 / (sh.reduce((d, m) => d + m, 0) / n / 1e3), u = sh.filter((d) => d > ku).reduce((d, m) => d + (m - ku) / ku, 0);
        return { loadTime: i, fullLoadTime: e, fps: a, percentDroppedFrames: u / (n + u) * 100, totalFrames: n };
      } };
      v.$ = class extends E {
      }, v.A = gc, v.B = Dc, v.C = function(i) {
        if (Xt == null) {
          const e = i.navigator ? i.navigator.userAgent : null;
          Xt = !!i.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
        }
        return Xt;
      }, v.D = je, v.E = Qt, v.F = class {
        constructor(i, e) {
          this.target = i, this.mapId = e, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Um(() => this.process()), this.subscription = function(n, a, u, d) {
            return n.addEventListener(a, u, !1), { unsubscribe: () => {
              n.removeEventListener(a, u, !1);
            } };
          }(this.target, "message", (n) => this.receive(n)), this.globalScope = Wt(self) ? i : window;
        }
        registerMessageHandler(i, e) {
          this.messageHandlers[i] = e;
        }
        sendAsync(i, e) {
          return new Promise((n, a) => {
            const u = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[u] = { resolve: n, reject: a }, e && e.signal.addEventListener("abort", () => {
              delete this.resolveRejects[u];
              const S = { id: u, type: "<cancel>", origin: location.origin, targetMapId: i.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(S);
            }, { once: !0 });
            const d = [], m = Object.assign(Object.assign({}, i), { id: u, sourceMapId: this.mapId, origin: location.origin, data: yo(i.data, d) });
            this.target.postMessage(m, { transfer: d });
          });
        }
        receive(i) {
          const e = i.data, n = e.id;
          if (!(e.origin !== "file://" && location.origin !== "file://" && e.origin !== "resource://android" && location.origin !== "resource://android" && e.origin !== location.origin || e.targetMapId && this.mapId !== e.targetMapId)) {
            if (e.type === "<cancel>") {
              delete this.tasks[n];
              const a = this.abortControllers[n];
              return delete this.abortControllers[n], void (a && a.abort());
            }
            if (Wt(self) || e.mustQueue) return this.tasks[n] = e, this.taskQueue.push(n), void this.invoker.trigger();
            this.processTask(n, e);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          const i = this.taskQueue.shift(), e = this.tasks[i];
          delete this.tasks[i], this.taskQueue.length > 0 && this.invoker.trigger(), e && this.processTask(i, e);
        }
        processTask(i, e) {
          return c(this, void 0, void 0, function* () {
            if (e.type === "<response>") {
              const u = this.resolveRejects[i];
              return delete this.resolveRejects[i], u ? void (e.error ? u.reject(za(e.error)) : u.resolve(za(e.data))) : void 0;
            }
            if (!this.messageHandlers[e.type]) return void this.completeTask(i, new Error(`Could not find a registered handler for ${e.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const n = za(e.data), a = new AbortController();
            this.abortControllers[i] = a;
            try {
              const u = yield this.messageHandlers[e.type](e.sourceMapId, n, a);
              this.completeTask(i, null, u);
            } catch (u) {
              this.completeTask(i, u);
            }
          });
        }
        completeTask(i, e, n) {
          const a = [];
          delete this.abortControllers[i];
          const u = { id: i, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e ? yo(e) : null, data: yo(n, a) };
          this.target.postMessage(u, { transfer: a });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, v.G = Et, v.H = function() {
        var i = new gc(16);
        return gc != Float32Array && (i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0), i[0] = 1, i[5] = 1, i[10] = 1, i[15] = 1, i;
      }, v.I = hu, v.J = function(i, e, n) {
        var a, u, d, m, S, I, C, N, D, G, W, J, rt = n[0], dt = n[1], vt = n[2];
        return e === i ? (i[12] = e[0] * rt + e[4] * dt + e[8] * vt + e[12], i[13] = e[1] * rt + e[5] * dt + e[9] * vt + e[13], i[14] = e[2] * rt + e[6] * dt + e[10] * vt + e[14], i[15] = e[3] * rt + e[7] * dt + e[11] * vt + e[15]) : (u = e[1], d = e[2], m = e[3], S = e[4], I = e[5], C = e[6], N = e[7], D = e[8], G = e[9], W = e[10], J = e[11], i[0] = a = e[0], i[1] = u, i[2] = d, i[3] = m, i[4] = S, i[5] = I, i[6] = C, i[7] = N, i[8] = D, i[9] = G, i[10] = W, i[11] = J, i[12] = a * rt + S * dt + D * vt + e[12], i[13] = u * rt + I * dt + G * vt + e[13], i[14] = d * rt + C * dt + W * vt + e[14], i[15] = m * rt + N * dt + J * vt + e[15]), i;
      }, v.K = function(i, e, n) {
        var a = n[0], u = n[1], d = n[2];
        return i[0] = e[0] * a, i[1] = e[1] * a, i[2] = e[2] * a, i[3] = e[3] * a, i[4] = e[4] * u, i[5] = e[5] * u, i[6] = e[6] * u, i[7] = e[7] * u, i[8] = e[8] * d, i[9] = e[9] * d, i[10] = e[10] * d, i[11] = e[11] * d, i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
      }, v.L = rd, v.M = function(i, e) {
        const n = {};
        for (let a = 0; a < e.length; a++) {
          const u = e[a];
          u in i && (n[u] = i[u]);
        }
        return n;
      }, v.N = Al, v.O = Jd, v.P = O, v.Q = Qd, v.R = $s, v.S = Zs, v.T = _l, v.U = st, v.V = gt, v.W = ee, v.X = ir, v.Y = g, v.Z = ih, v._ = c, v.a = xt, v.a$ = function(i, e) {
        var n = i[0], a = i[1], u = i[2], d = i[3], m = i[4], S = i[5], I = i[6], C = i[7], N = i[8], D = i[9], G = i[10], W = i[11], J = i[12], rt = i[13], dt = i[14], vt = i[15], Dt = e[0], Lt = e[1], Nt = e[2], Zt = e[3], ge = e[4], Me = e[5], ri = e[6], Le = e[7], Ae = e[8], Ve = e[9], Re = e[10], Fe = e[11], ne = e[12], We = e[13], qe = e[14], hi = e[15];
        return Math.abs(n - Dt) <= Un * Math.max(1, Math.abs(n), Math.abs(Dt)) && Math.abs(a - Lt) <= Un * Math.max(1, Math.abs(a), Math.abs(Lt)) && Math.abs(u - Nt) <= Un * Math.max(1, Math.abs(u), Math.abs(Nt)) && Math.abs(d - Zt) <= Un * Math.max(1, Math.abs(d), Math.abs(Zt)) && Math.abs(m - ge) <= Un * Math.max(1, Math.abs(m), Math.abs(ge)) && Math.abs(S - Me) <= Un * Math.max(1, Math.abs(S), Math.abs(Me)) && Math.abs(I - ri) <= Un * Math.max(1, Math.abs(I), Math.abs(ri)) && Math.abs(C - Le) <= Un * Math.max(1, Math.abs(C), Math.abs(Le)) && Math.abs(N - Ae) <= Un * Math.max(1, Math.abs(N), Math.abs(Ae)) && Math.abs(D - Ve) <= Un * Math.max(1, Math.abs(D), Math.abs(Ve)) && Math.abs(G - Re) <= Un * Math.max(1, Math.abs(G), Math.abs(Re)) && Math.abs(W - Fe) <= Un * Math.max(1, Math.abs(W), Math.abs(Fe)) && Math.abs(J - ne) <= Un * Math.max(1, Math.abs(J), Math.abs(ne)) && Math.abs(rt - We) <= Un * Math.max(1, Math.abs(rt), Math.abs(We)) && Math.abs(dt - qe) <= Un * Math.max(1, Math.abs(dt), Math.abs(qe)) && Math.abs(vt - hi) <= Un * Math.max(1, Math.abs(vt), Math.abs(hi));
      }, v.a0 = Li, v.a1 = xu, v.a2 = oe, v.a3 = (i) => {
        const e = window.document.createElement("video");
        return e.muted = !0, new Promise((n) => {
          e.onloadstart = () => {
            n(e);
          };
          for (const a of i) {
            const u = window.document.createElement("source");
            we(a) || (e.crossOrigin = "Anonymous"), u.src = a, e.appendChild(u);
          }
        });
      }, v.a4 = function() {
        return kt++;
      }, v.a5 = xe, v.a6 = wc, v.a7 = js, v.a8 = So, v.a9 = sp, v.aA = function(i) {
        if (i.type === "custom") return new qm(i);
        switch (i.type) {
          case "background":
            return new Rm(i);
          case "circle":
            return new Pf(i);
          case "fill":
            return new Uf(i);
          case "fill-extrusion":
            return new rm(i);
          case "heatmap":
            return new kf(i);
          case "hillshade":
            return new Lf(i);
          case "line":
            return new um(i);
          case "raster":
            return new jm(i);
          case "symbol":
            return new Ih(i);
        }
      }, v.aB = at, v.aC = function(i, e) {
        if (!i) return [{ command: "setStyle", args: [e] }];
        let n = [];
        try {
          if (!se(i.version, e.version)) return [{ command: "setStyle", args: [e] }];
          se(i.center, e.center) || n.push({ command: "setCenter", args: [e.center] }), se(i.zoom, e.zoom) || n.push({ command: "setZoom", args: [e.zoom] }), se(i.bearing, e.bearing) || n.push({ command: "setBearing", args: [e.bearing] }), se(i.pitch, e.pitch) || n.push({ command: "setPitch", args: [e.pitch] }), se(i.sprite, e.sprite) || n.push({ command: "setSprite", args: [e.sprite] }), se(i.glyphs, e.glyphs) || n.push({ command: "setGlyphs", args: [e.glyphs] }), se(i.transition, e.transition) || n.push({ command: "setTransition", args: [e.transition] }), se(i.light, e.light) || n.push({ command: "setLight", args: [e.light] }), se(i.terrain, e.terrain) || n.push({ command: "setTerrain", args: [e.terrain] }), se(i.sky, e.sky) || n.push({ command: "setSky", args: [e.sky] }), se(i.projection, e.projection) || n.push({ command: "setProjection", args: [e.projection] });
          const a = {}, u = [];
          (function(m, S, I, C) {
            let N;
            for (N in S = S || {}, m = m || {}) Object.prototype.hasOwnProperty.call(m, N) && (Object.prototype.hasOwnProperty.call(S, N) || ke(N, I, C));
            for (N in S) Object.prototype.hasOwnProperty.call(S, N) && (Object.prototype.hasOwnProperty.call(m, N) ? se(m[N], S[N]) || (m[N].type === "geojson" && S[N].type === "geojson" && di(m, S, N) ? _e(I, { command: "setGeoJSONSourceData", args: [N, S[N].data] }) : Ze(N, S, I, C)) : ze(N, S, I));
          })(i.sources, e.sources, u, a);
          const d = [];
          i.layers && i.layers.forEach((m) => {
            "source" in m && a[m.source] ? n.push({ command: "removeLayer", args: [m.id] }) : d.push(m);
          }), n = n.concat(u), function(m, S, I) {
            S = S || [];
            const C = (m = m || []).map(wi), N = S.map(wi), D = m.reduce(Ei, {}), G = S.reduce(Ei, {}), W = C.slice(), J = /* @__PURE__ */ Object.create(null);
            let rt, dt, vt, Dt, Lt;
            for (let Nt = 0, Zt = 0; Nt < C.length; Nt++) rt = C[Nt], Object.prototype.hasOwnProperty.call(G, rt) ? Zt++ : (_e(I, { command: "removeLayer", args: [rt] }), W.splice(W.indexOf(rt, Zt), 1));
            for (let Nt = 0, Zt = 0; Nt < N.length; Nt++) rt = N[N.length - 1 - Nt], W[W.length - 1 - Nt] !== rt && (Object.prototype.hasOwnProperty.call(D, rt) ? (_e(I, { command: "removeLayer", args: [rt] }), W.splice(W.lastIndexOf(rt, W.length - Zt), 1)) : Zt++, Dt = W[W.length - Nt], _e(I, { command: "addLayer", args: [G[rt], Dt] }), W.splice(W.length - Nt, 0, rt), J[rt] = !0);
            for (let Nt = 0; Nt < N.length; Nt++) if (rt = N[Nt], dt = D[rt], vt = G[rt], !J[rt] && !se(dt, vt)) if (se(dt.source, vt.source) && se(dt["source-layer"], vt["source-layer"]) && se(dt.type, vt.type)) {
              for (Lt in ai(dt.layout, vt.layout, I, rt, null, "setLayoutProperty"), ai(dt.paint, vt.paint, I, rt, null, "setPaintProperty"), se(dt.filter, vt.filter) || _e(I, { command: "setFilter", args: [rt, vt.filter] }), se(dt.minzoom, vt.minzoom) && se(dt.maxzoom, vt.maxzoom) || _e(I, { command: "setLayerZoomRange", args: [rt, vt.minzoom, vt.maxzoom] }), dt) Object.prototype.hasOwnProperty.call(dt, Lt) && Lt !== "layout" && Lt !== "paint" && Lt !== "filter" && Lt !== "metadata" && Lt !== "minzoom" && Lt !== "maxzoom" && (Lt.indexOf("paint.") === 0 ? ai(dt[Lt], vt[Lt], I, rt, Lt.slice(6), "setPaintProperty") : se(dt[Lt], vt[Lt]) || _e(I, { command: "setLayerProperty", args: [rt, Lt, vt[Lt]] }));
              for (Lt in vt) Object.prototype.hasOwnProperty.call(vt, Lt) && !Object.prototype.hasOwnProperty.call(dt, Lt) && Lt !== "layout" && Lt !== "paint" && Lt !== "filter" && Lt !== "metadata" && Lt !== "minzoom" && Lt !== "maxzoom" && (Lt.indexOf("paint.") === 0 ? ai(dt[Lt], vt[Lt], I, rt, Lt.slice(6), "setPaintProperty") : se(dt[Lt], vt[Lt]) || _e(I, { command: "setLayerProperty", args: [rt, Lt, vt[Lt]] }));
            } else _e(I, { command: "removeLayer", args: [rt] }), Dt = W[W.lastIndexOf(rt) + 1], _e(I, { command: "addLayer", args: [vt, Dt] });
          }(d, e.layers, n);
        } catch (a) {
          console.warn("Unable to compute style diff:", a), n = [{ command: "setStyle", args: [e] }];
        }
        return n;
      }, v.aD = function(i) {
        const e = [], n = i.id;
        return n === void 0 && e.push({ message: `layers.${n}: missing required property "id"` }), i.render === void 0 && e.push({ message: `layers.${n}: missing required method "render"` }), i.renderingMode && i.renderingMode !== "2d" && i.renderingMode !== "3d" && e.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), e;
      }, v.aE = function i(e, n) {
        if (Array.isArray(e)) {
          if (!Array.isArray(n) || e.length !== n.length) return !1;
          for (let a = 0; a < e.length; a++) if (!i(e[a], n[a])) return !1;
          return !0;
        }
        if (typeof e == "object" && e !== null && n !== null) {
          if (typeof n != "object" || Object.keys(e).length !== Object.keys(n).length) return !1;
          for (const a in e) if (!i(e[a], n[a])) return !1;
          return !0;
        }
        return e === n;
      }, v.aF = $t, v.aG = ae, v.aH = class extends bo {
        constructor(i, e) {
          super(i, e), this.current = 0;
        }
        set(i) {
          this.current !== i && (this.current = i, this.gl.uniform1i(this.location, i));
        }
      }, v.aI = Gl, v.aJ = class extends bo {
        constructor(i, e) {
          super(i, e), this.current = Zl;
        }
        set(i) {
          if (i[12] !== this.current[12] || i[0] !== this.current[0]) return this.current = i, void this.gl.uniformMatrix4fv(this.location, !1, i);
          for (let e = 1; e < 16; e++) if (i[e] !== this.current[e]) {
            this.current = i, this.gl.uniformMatrix4fv(this.location, !1, i);
            break;
          }
        }
      }, v.aK = $l, v.aL = hc, v.aM = Ri, v.aN = class extends bo {
        constructor(i, e) {
          super(i, e), this.current = [0, 0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i, this.gl.uniform3f(this.location, i[0], i[1], i[2]));
        }
      }, v.aO = class extends bo {
        constructor(i, e) {
          super(i, e), this.current = [0, 0];
        }
        set(i) {
          i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i, this.gl.uniform2f(this.location, i[0], i[1]));
        }
      }, v.aP = function(i, e, n, a, u, d, m) {
        var S = 1 / (e - n), I = 1 / (a - u), C = 1 / (d - m);
        return i[0] = -2 * S, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = -2 * I, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 2 * C, i[11] = 0, i[12] = (e + n) * S, i[13] = (u + a) * I, i[14] = (m + d) * C, i[15] = 1, i;
      }, v.aQ = Af, v.aR = class extends ht {
      }, v.aS = mm, v.aT = class extends _t {
      }, v.aU = Jh, v.aV = function(i) {
        return i <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
      }, v.aW = ld, v.aX = or, v.aY = rn, v.aZ = class extends fe {
      }, v.a_ = function(i, e) {
        return i[0] === e[0] && i[1] === e[1] && i[2] === e[2] && i[3] === e[3] && i[4] === e[4] && i[5] === e[5] && i[6] === e[6] && i[7] === e[7] && i[8] === e[8] && i[9] === e[9] && i[10] === e[10] && i[11] === e[11] && i[12] === e[12] && i[13] === e[13] && i[14] === e[14] && i[15] === e[15];
      }, v.aa = function(i) {
        const e = {};
        if (i.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, a, u, d) => {
          const m = u || d;
          return e[a] = !m || m.toLowerCase(), "";
        }), e["max-age"]) {
          const n = parseInt(e["max-age"], 10);
          isNaN(n) ? delete e["max-age"] : e["max-age"] = n;
        }
        return e;
      }, v.ab = function(i, e) {
        const n = [];
        for (const a in i) a in e || n.push(a);
        return n;
      }, v.ac = Kt, v.ad = function(i, e, n) {
        var a = Math.sin(n), u = Math.cos(n), d = e[0], m = e[1], S = e[2], I = e[3], C = e[4], N = e[5], D = e[6], G = e[7];
        return e !== i && (i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[0] = d * u + C * a, i[1] = m * u + N * a, i[2] = S * u + D * a, i[3] = I * u + G * a, i[4] = C * u - d * a, i[5] = N * u - m * a, i[6] = D * u - S * a, i[7] = G * u - I * a, i;
      }, v.ae = function(i) {
        var e = new gc(16);
        return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], e;
      }, v.af = yh, v.ag = function(i, e) {
        let n = 0, a = 0;
        if (i.kind === "constant") a = i.layoutSize;
        else if (i.kind !== "source") {
          const { interpolationType: u, minZoom: d, maxZoom: m } = i, S = u ? Kt(He.interpolationFactor(u, e, d, m), 0, 1) : 0;
          i.kind === "camera" ? a = Or.number(i.minSize, i.maxSize, S) : n = S;
        }
        return { uSizeT: n, uSize: a };
      }, v.ai = function(i, { uSize: e, uSizeT: n }, { lowerSize: a, upperSize: u }) {
        return i.kind === "source" ? a / Io : i.kind === "composite" ? Or.number(a / Io, u / Io, n) : e;
      }, v.aj = fu, v.ak = function(i, e, n, a) {
        const u = e.y - i.y, d = e.x - i.x, m = a.y - n.y, S = a.x - n.x, I = m * d - S * u;
        if (I === 0) return null;
        const C = (S * (i.y - n.y) - m * (i.x - n.x)) / I;
        return new O(i.x + C * d, i.y + C * u);
      }, v.al = cp, v.am = pc, v.an = Hh, v.ao = function(i) {
        let e = 1 / 0, n = 1 / 0, a = -1 / 0, u = -1 / 0;
        for (const d of i) e = Math.min(e, d.x), n = Math.min(n, d.y), a = Math.max(a, d.x), u = Math.max(u, d.y);
        return [e, n, a, u];
      }, v.ap = Gr, v.ar = pu, v.as = function(i, e) {
        var n = e[0], a = e[1], u = e[2], d = e[3], m = e[4], S = e[5], I = e[6], C = e[7], N = e[8], D = e[9], G = e[10], W = e[11], J = e[12], rt = e[13], dt = e[14], vt = e[15], Dt = n * S - a * m, Lt = n * I - u * m, Nt = n * C - d * m, Zt = a * I - u * S, ge = a * C - d * S, Me = u * C - d * I, ri = N * rt - D * J, Le = N * dt - G * J, Ae = N * vt - W * J, Ve = D * dt - G * rt, Re = D * vt - W * rt, Fe = G * vt - W * dt, ne = Dt * Fe - Lt * Re + Nt * Ve + Zt * Ae - ge * Le + Me * ri;
        return ne ? (i[0] = (S * Fe - I * Re + C * Ve) * (ne = 1 / ne), i[1] = (u * Re - a * Fe - d * Ve) * ne, i[2] = (rt * Me - dt * ge + vt * Zt) * ne, i[3] = (G * ge - D * Me - W * Zt) * ne, i[4] = (I * Ae - m * Fe - C * Le) * ne, i[5] = (n * Fe - u * Ae + d * Le) * ne, i[6] = (dt * Nt - J * Me - vt * Lt) * ne, i[7] = (N * Me - G * Nt + W * Lt) * ne, i[8] = (m * Re - S * Ae + C * ri) * ne, i[9] = (a * Ae - n * Re - d * ri) * ne, i[10] = (J * ge - rt * Nt + vt * Dt) * ne, i[11] = (D * Nt - N * ge - W * Dt) * ne, i[12] = (S * Le - m * Ve - I * ri) * ne, i[13] = (n * Ve - a * Le + u * ri) * ne, i[14] = (rt * Lt - J * Zt - dt * Dt) * ne, i[15] = (N * Zt - D * Lt + G * Dt) * ne, i) : null;
      }, v.at = wu, v.au = du, v.av = Su, v.aw = function() {
        const i = {}, e = Y.$version;
        for (const n in Y.$root) {
          const a = Y.$root[n];
          if (a.required) {
            let u = null;
            u = n === "version" ? e : a.type === "array" ? [] : {}, u != null && (i[n] = u);
          }
        }
        return i;
      }, v.ax = ks, v.ay = qt, v.az = function(i) {
        i = i.slice();
        const e = /* @__PURE__ */ Object.create(null);
        for (let n = 0; n < i.length; n++) e[i[n].id] = i[n];
        for (let n = 0; n < i.length; n++) "ref" in i[n] && (i[n] = Ge(i[n], e[i[n].ref]));
        return i;
      }, v.b = Ht, v.b0 = function(i, e) {
        return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[4] = e[4], i[5] = e[5], i[6] = e[6], i[7] = e[7], i[8] = e[8], i[9] = e[9], i[10] = e[10], i[11] = e[11], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15], i;
      }, v.b1 = function(i, e, n) {
        return i[0] = e[0] * n[0], i[1] = e[1] * n[1], i[2] = e[2] * n[2], i[3] = e[3] * n[3], i;
      }, v.b2 = function(i, e) {
        return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] * e[3];
      }, v.b3 = pe, v.b4 = ip, v.b5 = tp, v.b6 = function(i, e, n, a, u) {
        var d, m = 1 / Math.tan(e / 2);
        return i[0] = m / n, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = m, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[11] = -1, i[12] = 0, i[13] = 0, i[15] = 0, u != null && u !== 1 / 0 ? (i[10] = (u + a) * (d = 1 / (a - u)), i[14] = 2 * u * a * d) : (i[10] = -1, i[14] = -2 * a), i;
      }, v.b7 = function(i, e, n) {
        var a = Math.sin(n), u = Math.cos(n), d = e[4], m = e[5], S = e[6], I = e[7], C = e[8], N = e[9], D = e[10], G = e[11];
        return e !== i && (i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[3], i[12] = e[12], i[13] = e[13], i[14] = e[14], i[15] = e[15]), i[4] = d * u + C * a, i[5] = m * u + N * a, i[6] = S * u + D * a, i[7] = I * u + G * a, i[8] = C * u - d * a, i[9] = N * u - m * a, i[10] = D * u - S * a, i[11] = G * u - I * a, i;
      }, v.b8 = zt, v.b9 = Jt, v.bA = Td, v.bB = function(i) {
        return i.message === K;
      }, v.bC = Pr, v.bD = Ln, v.ba = function(i) {
        return i * Math.PI / 180;
      }, v.bb = function(i, e) {
        const { x: n, y: a } = ih.fromLngLat(e);
        return !(i < 0 || i > 25 || a < 0 || a >= 1 || n < 0 || n >= 1);
      }, v.bc = function(i, e) {
        return i[0] = e[0], i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = e[1], i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = e[2], i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, i;
      }, v.bd = class extends L {
      }, v.be = _u, v.bf = Km, v.bh = Rt, v.bi = function(i, e) {
        xt.REGISTERED_PROTOCOLS[i] = e;
      }, v.bj = function(i) {
        delete xt.REGISTERED_PROTOCOLS[i];
      }, v.bk = function(i, e) {
        const n = {};
        for (let u = 0; u < i.length; u++) {
          const d = e && e[i[u].id] || gr(i[u]);
          e && (e[i[u].id] = d);
          let m = n[d];
          m || (m = n[d] = []), m.push(i[u]);
        }
        const a = [];
        for (const u in n) a.push(n[u]);
        return a;
      }, v.bl = De, v.bm = np, v.bn = ap, v.bo = Bd, v.bp = function(i) {
        i.bucket.createArrays(), i.bucket.tilePixelRatio = ir / (512 * i.bucket.overscaling), i.bucket.compareText = {}, i.bucket.iconsNeedLinear = !1;
        const e = i.bucket.layers[0], n = e.layout, a = e._unevaluatedLayout._values, u = { layoutIconSize: a["icon-size"].possiblyEvaluate(new Xi(i.bucket.zoom + 1), i.canonical), layoutTextSize: a["text-size"].possiblyEvaluate(new Xi(i.bucket.zoom + 1), i.canonical), textMaxSize: a["text-size"].possiblyEvaluate(new Xi(18)) };
        if (i.bucket.textSizeData.kind === "composite") {
          const { minZoom: C, maxZoom: N } = i.bucket.textSizeData;
          u.compositeTextSizes = [a["text-size"].possiblyEvaluate(new Xi(C), i.canonical), a["text-size"].possiblyEvaluate(new Xi(N), i.canonical)];
        }
        if (i.bucket.iconSizeData.kind === "composite") {
          const { minZoom: C, maxZoom: N } = i.bucket.iconSizeData;
          u.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new Xi(C), i.canonical), a["icon-size"].possiblyEvaluate(new Xi(N), i.canonical)];
        }
        const d = n.get("text-line-height") * Gr, m = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", S = n.get("text-keep-upright"), I = n.get("text-size");
        for (const C of i.bucket.features) {
          const N = n.get("text-font").evaluate(C, {}, i.canonical).join(","), D = I.evaluate(C, {}, i.canonical), G = u.layoutTextSize.evaluate(C, {}, i.canonical), W = u.layoutIconSize.evaluate(C, {}, i.canonical), J = { horizontal: {}, vertical: void 0 }, rt = C.text;
          let dt, vt = [0, 0];
          if (rt) {
            const Nt = rt.toString(), Zt = n.get("text-letter-spacing").evaluate(C, {}, i.canonical) * Gr, ge = Fc(Nt) ? Zt : 0, Me = n.get("text-anchor").evaluate(C, {}, i.canonical), ri = _p(e, C, i.canonical);
            if (!ri) {
              const Re = n.get("text-radial-offset").evaluate(C, {}, i.canonical);
              vt = Re ? yp(Me, [Re * Gr, bu]) : n.get("text-offset").evaluate(C, {}, i.canonical).map((Fe) => Fe * Gr);
            }
            let Le = m ? "center" : n.get("text-justify").evaluate(C, {}, i.canonical);
            const Ae = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(C, {}, i.canonical) * Gr : 1 / 0, Ve = () => {
              i.bucket.allowVerticalPlacement && jl(Nt) && (J.vertical = Sh(rt, i.glyphMap, i.glyphPositions, i.imagePositions, N, Ae, d, Me, "left", ge, vt, v.ah.vertical, !0, G, D));
            };
            if (!m && ri) {
              const Re = /* @__PURE__ */ new Set();
              if (Le === "auto") for (let ne = 0; ne < ri.values.length; ne += 2) Re.add(wu(ri.values[ne]));
              else Re.add(Le);
              let Fe = !1;
              for (const ne of Re) if (!J.horizontal[ne]) if (Fe) J.horizontal[ne] = J.horizontal[0];
              else {
                const We = Sh(rt, i.glyphMap, i.glyphPositions, i.imagePositions, N, Ae, d, "center", ne, ge, vt, v.ah.horizontal, !1, G, D);
                We && (J.horizontal[ne] = We, Fe = We.positionedLines.length === 1);
              }
              Ve();
            } else {
              Le === "auto" && (Le = wu(Me));
              const Re = Sh(rt, i.glyphMap, i.glyphPositions, i.imagePositions, N, Ae, d, Me, Le, ge, vt, v.ah.horizontal, !1, G, D);
              Re && (J.horizontal[Le] = Re), Ve(), jl(Nt) && m && S && (J.vertical = Sh(rt, i.glyphMap, i.glyphPositions, i.imagePositions, N, Ae, d, Me, Le, ge, vt, v.ah.vertical, !1, G, D));
            }
          }
          let Dt = !1;
          if (C.icon && C.icon.name) {
            const Nt = i.imageMap[C.icon.name];
            Nt && (dt = zm(i.imagePositions[C.icon.name], n.get("icon-offset").evaluate(C, {}, i.canonical), n.get("icon-anchor").evaluate(C, {}, i.canonical)), Dt = !!Nt.sdf, i.bucket.sdfIcons === void 0 ? i.bucket.sdfIcons = Dt : i.bucket.sdfIcons !== Dt && It("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Nt.pixelRatio !== i.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (i.bucket.iconsNeedLinear = !0));
          }
          const Lt = xp(J.horizontal) || J.vertical;
          i.bucket.iconsInText = !!Lt && Lt.iconsInText, (Lt || dt) && Hm(i.bucket, C, J, dt, i.imageMap, u, G, W, vt, Dt, i.canonical);
        }
        i.showCollisionBoxes && i.bucket.generateCollisionDebugBuffers();
      }, v.bq = au, v.br = ru, v.bs = su, v.bt = bl, v.bu = lu, v.bv = class {
        constructor(i) {
          this._marks = { start: [i.url, "start"].join("#"), end: [i.url, "end"].join("#"), measure: i.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let i = performance.getEntriesByName(this._marks.measure);
          return i.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), i = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), i;
        }
      }, v.bw = function(i, e, n, a, u) {
        return c(this, void 0, void 0, function* () {
          if (gt()) try {
            return yield ee(i, e, n, a, u);
          } catch {
          }
          return function(d, m, S, I, C) {
            const N = d.width, D = d.height;
            ie && Se || (ie = new OffscreenCanvas(N, D), Se = ie.getContext("2d", { willReadFrequently: !0 })), ie.width = N, ie.height = D, Se.drawImage(d, 0, 0, N, D);
            const G = Se.getImageData(m, S, I, C);
            return Se.clearRect(0, 0, N, D), G.data;
          }(i, e, n, a, u);
        });
      }, v.bx = rp, v.by = z, v.bz = U, v.c = pt, v.d = (i) => c(void 0, void 0, void 0, function* () {
        if (i.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        const e = new Blob([new Uint8Array(i)], { type: "image/png" });
        try {
          return createImageBitmap(e);
        } catch (n) {
          throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), v.e = Ot, v.f = (i) => new Promise((e, n) => {
        const a = new Image();
        a.onload = () => {
          e(a), URL.revokeObjectURL(a.src), a.onload = null, window.requestAnimationFrame(() => {
            a.src = jt;
          });
        }, a.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const u = new Blob([new Uint8Array(i)], { type: "image/png" });
        a.src = i.byteLength ? URL.createObjectURL(u) : jt;
      }), v.g = Tt, v.h = (i, e) => Gt(Ot(i, { type: "json" }), e), v.i = Wt, v.j = ti, v.k = Pe, v.l = (i, e) => Gt(Ot(i, { type: "arrayBuffer" }), e), v.m = Gt, v.n = function(i) {
        return new lu(i).readFields(Im, []);
      }, v.o = Zc, v.p = Fd, v.q = o, v.r = Ho, v.s = we, v.t = Ol, v.u = qs, v.v = Y, v.w = It, v.x = function([i, e, n]) {
        return e += 90, e *= Math.PI / 180, n *= Math.PI / 180, { x: i * Math.cos(e) * Math.sin(n), y: i * Math.sin(e) * Math.sin(n), z: i * Math.cos(n) };
      }, v.y = Or, v.z = Xi;
    }), k("worker", ["./shared"], function(v) {
      class c {
        constructor(V) {
          this.keyCache = {}, V && this.replace(V);
        }
        replace(V) {
          this._layerConfigs = {}, this._layers = {}, this.update(V, []);
        }
        update(V, Z) {
          for (const ct of V) {
            this._layerConfigs[ct.id] = ct;
            const Pt = this._layers[ct.id] = v.aA(ct);
            Pt._featureFilter = v.a7(Pt.filter), this.keyCache[ct.id] && delete this.keyCache[ct.id];
          }
          for (const ct of Z) delete this.keyCache[ct], delete this._layerConfigs[ct], delete this._layers[ct];
          this.familiesBySource = {};
          const et = v.bk(Object.values(this._layerConfigs), this.keyCache);
          for (const ct of et) {
            const Pt = ct.map((Bt) => this._layers[Bt.id]), Mt = Pt[0];
            if (Mt.visibility === "none") continue;
            const At = Mt.source || "";
            let bt = this.familiesBySource[At];
            bt || (bt = this.familiesBySource[At] = {});
            const Ut = Mt.sourceLayer || "_geojsonTileLayer";
            let te = bt[Ut];
            te || (te = bt[Ut] = []), te.push(Pt);
          }
        }
      }
      class z {
        constructor(V) {
          const Z = {}, et = [];
          for (const At in V) {
            const bt = V[At], Ut = Z[At] = {};
            for (const te in bt) {
              const Bt = bt[+te];
              if (!Bt || Bt.bitmap.width === 0 || Bt.bitmap.height === 0) continue;
              const me = { x: 0, y: 0, w: Bt.bitmap.width + 2, h: Bt.bitmap.height + 2 };
              et.push(me), Ut[te] = { rect: me, metrics: Bt.metrics };
            }
          }
          const { w: ct, h: Pt } = v.p(et), Mt = new v.o({ width: ct || 1, height: Pt || 1 });
          for (const At in V) {
            const bt = V[At];
            for (const Ut in bt) {
              const te = bt[+Ut];
              if (!te || te.bitmap.width === 0 || te.bitmap.height === 0) continue;
              const Bt = Z[At][Ut].rect;
              v.o.copy(te.bitmap, Mt, { x: 0, y: 0 }, { x: Bt.x + 1, y: Bt.y + 1 }, te.bitmap);
            }
          }
          this.image = Mt, this.positions = Z;
        }
      }
      v.bl("GlyphAtlas", z);
      class U {
        constructor(V) {
          this.tileID = new v.S(V.tileID.overscaledZ, V.tileID.wrap, V.tileID.canonical.z, V.tileID.canonical.x, V.tileID.canonical.y), this.uid = V.uid, this.zoom = V.zoom, this.pixelRatio = V.pixelRatio, this.tileSize = V.tileSize, this.source = V.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = V.showCollisionBoxes, this.collectResourceTiming = !!V.collectResourceTiming, this.returnDependencies = !!V.returnDependencies, this.promoteId = V.promoteId, this.inFlightDependencies = [];
        }
        parse(V, Z, et, ct) {
          return v._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = V, this.collisionBoxArray = new v.a5();
            const Pt = new v.bm(Object.keys(V.layers).sort()), Mt = new v.bn(this.tileID, this.promoteId);
            Mt.bucketLayerIDs = [];
            const At = {}, bt = { featureIndex: Mt, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: et }, Ut = Z.familiesBySource[this.source];
            for (const li in Ut) {
              const Di = V.layers[li];
              if (!Di) continue;
              Di.version === 1 && v.w(`Vector tile source "${this.source}" layer "${li}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const Gi = Pt.encode(li), hr = [];
              for (let pr = 0; pr < Di.length; pr++) {
                const Ar = Di.feature(pr), Es = Mt.getId(Ar, li);
                hr.push({ feature: Ar, id: Es, index: pr, sourceLayerIndex: Gi });
              }
              for (const pr of Ut[li]) {
                const Ar = pr[0];
                Ar.source !== this.source && v.w(`layer.source = ${Ar.source} does not equal this.source = ${this.source}`), Ar.minzoom && this.zoom < Math.floor(Ar.minzoom) || Ar.maxzoom && this.zoom >= Ar.maxzoom || Ar.visibility !== "none" && (X(pr, this.zoom, et), (At[Ar.id] = Ar.createBucket({ index: Mt.bucketLayerIDs.length, layers: pr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Gi, sourceID: this.source })).populate(hr, bt, this.tileID.canonical), Mt.bucketLayerIDs.push(pr.map((Es) => Es.id)));
              }
            }
            const te = v.aF(bt.glyphDependencies, (li) => Object.keys(li).map(Number));
            this.inFlightDependencies.forEach((li) => li == null ? void 0 : li.abort()), this.inFlightDependencies = [];
            let Bt = Promise.resolve({});
            if (Object.keys(te).length) {
              const li = new AbortController();
              this.inFlightDependencies.push(li), Bt = ct.sendAsync({ type: "GG", data: { stacks: te, source: this.source, tileID: this.tileID, type: "glyphs" } }, li);
            }
            const me = Object.keys(bt.iconDependencies);
            let Ne = Promise.resolve({});
            if (me.length) {
              const li = new AbortController();
              this.inFlightDependencies.push(li), Ne = ct.sendAsync({ type: "GI", data: { icons: me, source: this.source, tileID: this.tileID, type: "icons" } }, li);
            }
            const $e = Object.keys(bt.patternDependencies);
            let xi = Promise.resolve({});
            if ($e.length) {
              const li = new AbortController();
              this.inFlightDependencies.push(li), xi = ct.sendAsync({ type: "GI", data: { icons: $e, source: this.source, tileID: this.tileID, type: "patterns" } }, li);
            }
            const [Ke, yi, pi] = yield Promise.all([Bt, Ne, xi]), Zi = new z(Ke), Bi = new v.bo(yi, pi);
            for (const li in At) {
              const Di = At[li];
              Di instanceof v.a6 ? (X(Di.layers, this.zoom, et), v.bp({ bucket: Di, glyphMap: Ke, glyphPositions: Zi.positions, imageMap: yi, imagePositions: Bi.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : Di.hasPattern && (Di instanceof v.bq || Di instanceof v.br || Di instanceof v.bs) && (X(Di.layers, this.zoom, et), Di.addFeatures(bt, this.tileID.canonical, Bi.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(At).filter((li) => !li.isEmpty()), featureIndex: Mt, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Zi.image, imageAtlas: Bi, glyphMap: this.returnDependencies ? Ke : null, iconMap: this.returnDependencies ? yi : null, glyphPositions: this.returnDependencies ? Zi.positions : null };
          });
        }
      }
      function X(ut, V, Z) {
        const et = new v.z(V);
        for (const ct of ut) ct.recalculate(et, Z);
      }
      class O {
        constructor(V, Z, et) {
          this.actor = V, this.layerIndex = Z, this.availableImages = et, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(V, Z) {
          return v._(this, void 0, void 0, function* () {
            const et = yield v.l(V.request, Z);
            try {
              return { vectorTile: new v.bt.VectorTile(new v.bu(et.data)), rawData: et.data, cacheControl: et.cacheControl, expires: et.expires };
            } catch (ct) {
              const Pt = new Uint8Array(et.data);
              let Mt = `Unable to parse the tile at ${V.request.url}, `;
              throw Mt += Pt[0] === 31 && Pt[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ct.message}`, new Error(Mt);
            }
          });
        }
        loadTile(V) {
          return v._(this, void 0, void 0, function* () {
            const Z = V.uid, et = !!(V && V.request && V.request.collectResourceTiming) && new v.bv(V.request), ct = new U(V);
            this.loading[Z] = ct;
            const Pt = new AbortController();
            ct.abort = Pt;
            try {
              const Mt = yield this.loadVectorTile(V, Pt);
              if (delete this.loading[Z], !Mt) return null;
              const At = Mt.rawData, bt = {};
              Mt.expires && (bt.expires = Mt.expires), Mt.cacheControl && (bt.cacheControl = Mt.cacheControl);
              const Ut = {};
              if (et) {
                const Bt = et.finish();
                Bt && (Ut.resourceTiming = JSON.parse(JSON.stringify(Bt)));
              }
              ct.vectorTile = Mt.vectorTile;
              const te = ct.parse(Mt.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[Z] = ct, this.fetching[Z] = { rawTileData: At, cacheControl: bt, resourceTiming: Ut };
              try {
                const Bt = yield te;
                return v.e({ rawTileData: At.slice(0) }, Bt, bt, Ut);
              } finally {
                delete this.fetching[Z];
              }
            } catch (Mt) {
              throw delete this.loading[Z], ct.status = "done", this.loaded[Z] = ct, Mt;
            }
          });
        }
        reloadTile(V) {
          return v._(this, void 0, void 0, function* () {
            const Z = V.uid;
            if (!this.loaded || !this.loaded[Z]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const et = this.loaded[Z];
            if (et.showCollisionBoxes = V.showCollisionBoxes, et.status === "parsing") {
              const ct = yield et.parse(et.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let Pt;
              if (this.fetching[Z]) {
                const { rawTileData: Mt, cacheControl: At, resourceTiming: bt } = this.fetching[Z];
                delete this.fetching[Z], Pt = v.e({ rawTileData: Mt.slice(0) }, ct, At, bt);
              } else Pt = ct;
              return Pt;
            }
            if (et.status === "done" && et.vectorTile) return et.parse(et.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(V) {
          return v._(this, void 0, void 0, function* () {
            const Z = this.loading, et = V.uid;
            Z && Z[et] && Z[et].abort && (Z[et].abort.abort(), delete Z[et]);
          });
        }
        removeTile(V) {
          return v._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[V.uid] && delete this.loaded[V.uid];
          });
        }
      }
      class j {
        constructor() {
          this.loaded = {};
        }
        loadTile(V) {
          return v._(this, void 0, void 0, function* () {
            const { uid: Z, encoding: et, rawImageData: ct, redFactor: Pt, greenFactor: Mt, blueFactor: At, baseShift: bt } = V, Ut = ct.width + 2, te = ct.height + 2, Bt = v.b(ct) ? new v.R({ width: Ut, height: te }, yield v.bw(ct, -1, -1, Ut, te)) : ct, me = new v.bx(Z, Bt, et, Pt, Mt, At, bt);
            return this.loaded = this.loaded || {}, this.loaded[Z] = me, me;
          });
        }
        removeTile(V) {
          const Z = this.loaded, et = V.uid;
          Z && Z[et] && delete Z[et];
        }
      }
      function F(ut, V) {
        if (ut.length !== 0) {
          mt(ut[0], V);
          for (var Z = 1; Z < ut.length; Z++) mt(ut[Z], !V);
        }
      }
      function mt(ut, V) {
        for (var Z = 0, et = 0, ct = 0, Pt = ut.length, Mt = Pt - 1; ct < Pt; Mt = ct++) {
          var At = (ut[ct][0] - ut[Mt][0]) * (ut[Mt][1] + ut[ct][1]), bt = Z + At;
          et += Math.abs(Z) >= Math.abs(At) ? Z - bt + At : At - bt + Z, Z = bt;
        }
        Z + et >= 0 != !!V && ut.reverse();
      }
      var ot = v.by(function ut(V, Z) {
        var et, ct = V && V.type;
        if (ct === "FeatureCollection") for (et = 0; et < V.features.length; et++) ut(V.features[et], Z);
        else if (ct === "GeometryCollection") for (et = 0; et < V.geometries.length; et++) ut(V.geometries[et], Z);
        else if (ct === "Feature") ut(V.geometry, Z);
        else if (ct === "Polygon") F(V.coordinates, Z);
        else if (ct === "MultiPolygon") for (et = 0; et < V.coordinates.length; et++) F(V.coordinates[et], Z);
        return V;
      });
      const yt = v.bt.VectorTileFeature.prototype.toGeoJSON;
      var st = { exports: {} }, gt = v.bz, zt = v.bt.VectorTileFeature, Jt = Kt;
      function Kt(ut, V) {
        this.options = V || {}, this.features = ut, this.length = ut.length;
      }
      function pe(ut, V) {
        this.id = typeof ut.id == "number" ? ut.id : void 0, this.type = ut.type, this.rawGeometry = ut.type === 1 ? [ut.geometry] : ut.geometry, this.properties = ut.tags, this.extent = V || 4096;
      }
      Kt.prototype.feature = function(ut) {
        return new pe(this.features[ut], this.options.extent);
      }, pe.prototype.loadGeometry = function() {
        var ut = this.rawGeometry;
        this.geometry = [];
        for (var V = 0; V < ut.length; V++) {
          for (var Z = ut[V], et = [], ct = 0; ct < Z.length; ct++) et.push(new gt(Z[ct][0], Z[ct][1]));
          this.geometry.push(et);
        }
        return this.geometry;
      }, pe.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var ut = this.geometry, V = 1 / 0, Z = -1 / 0, et = 1 / 0, ct = -1 / 0, Pt = 0; Pt < ut.length; Pt++) for (var Mt = ut[Pt], At = 0; At < Mt.length; At++) {
          var bt = Mt[At];
          V = Math.min(V, bt.x), Z = Math.max(Z, bt.x), et = Math.min(et, bt.y), ct = Math.max(ct, bt.y);
        }
        return [V, et, Z, ct];
      }, pe.prototype.toGeoJSON = zt.prototype.toGeoJSON;
      var Ot = v.bA, kt = Jt;
      function $t(ut) {
        var V = new Ot();
        return function(Z, et) {
          for (var ct in Z.layers) et.writeMessage(3, ae, Z.layers[ct]);
        }(ut, V), V.finish();
      }
      function ae(ut, V) {
        var Z;
        V.writeVarintField(15, ut.version || 1), V.writeStringField(1, ut.name || ""), V.writeVarintField(5, ut.extent || 4096);
        var et = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (Z = 0; Z < ut.length; Z++) et.feature = ut.feature(Z), V.writeMessage(2, at, et);
        var ct = et.keys;
        for (Z = 0; Z < ct.length; Z++) V.writeStringField(3, ct[Z]);
        var Pt = et.values;
        for (Z = 0; Z < Pt.length; Z++) V.writeMessage(4, Xt, Pt[Z]);
      }
      function at(ut, V) {
        var Z = ut.feature;
        Z.id !== void 0 && V.writeVarintField(1, Z.id), V.writeMessage(2, lt, ut), V.writeVarintField(3, Z.type), V.writeMessage(4, Wt, Z);
      }
      function lt(ut, V) {
        var Z = ut.feature, et = ut.keys, ct = ut.values, Pt = ut.keycache, Mt = ut.valuecache;
        for (var At in Z.properties) {
          var bt = Z.properties[At], Ut = Pt[At];
          if (bt !== null) {
            Ut === void 0 && (et.push(At), Pt[At] = Ut = et.length - 1), V.writeVarint(Ut);
            var te = typeof bt;
            te !== "string" && te !== "boolean" && te !== "number" && (bt = JSON.stringify(bt));
            var Bt = te + ":" + bt, me = Mt[Bt];
            me === void 0 && (ct.push(bt), Mt[Bt] = me = ct.length - 1), V.writeVarint(me);
          }
        }
      }
      function It(ut, V) {
        return (V << 3) + (7 & ut);
      }
      function St(ut) {
        return ut << 1 ^ ut >> 31;
      }
      function Wt(ut, V) {
        for (var Z = ut.loadGeometry(), et = ut.type, ct = 0, Pt = 0, Mt = Z.length, At = 0; At < Mt; At++) {
          var bt = Z[At], Ut = 1;
          et === 1 && (Ut = bt.length), V.writeVarint(It(1, Ut));
          for (var te = et === 3 ? bt.length - 1 : bt.length, Bt = 0; Bt < te; Bt++) {
            Bt === 1 && et !== 1 && V.writeVarint(It(2, te - 1));
            var me = bt[Bt].x - ct, Ne = bt[Bt].y - Pt;
            V.writeVarint(St(me)), V.writeVarint(St(Ne)), ct += me, Pt += Ne;
          }
          et === 3 && V.writeVarint(It(7, 1));
        }
      }
      function Xt(ut, V) {
        var Z = typeof ut;
        Z === "string" ? V.writeStringField(1, ut) : Z === "boolean" ? V.writeBooleanField(7, ut) : Z === "number" && (ut % 1 != 0 ? V.writeDoubleField(3, ut) : ut < 0 ? V.writeSVarintField(6, ut) : V.writeVarintField(5, ut));
      }
      st.exports = $t, st.exports.fromVectorTileJs = $t, st.exports.fromGeojsonVt = function(ut, V) {
        V = V || {};
        var Z = {};
        for (var et in ut) Z[et] = new kt(ut[et].features, V), Z[et].name = et, Z[et].version = V.version, Z[et].extent = V.extent;
        return $t({ layers: Z });
      }, st.exports.GeoJSONWrapper = kt;
      var Ht = v.by(st.exports);
      const jt = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (ut) => ut }, ee = Math.fround || (ie = new Float32Array(1), (ut) => (ie[0] = +ut, ie[0]));
      var ie;
      const Se = 3, K = 5, pt = 6;
      class xt {
        constructor(V) {
          this.options = Object.assign(Object.create(jt), V), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(V) {
          const { log: Z, minZoom: et, maxZoom: ct } = this.options;
          Z && console.time("total time");
          const Pt = `prepare ${V.length} points`;
          Z && console.time(Pt), this.points = V;
          const Mt = [];
          for (let bt = 0; bt < V.length; bt++) {
            const Ut = V[bt];
            if (!Ut.geometry) continue;
            const [te, Bt] = Ut.geometry.coordinates, me = ee(Rt(te)), Ne = ee(qt(Bt));
            Mt.push(me, Ne, 1 / 0, bt, -1, 1), this.options.reduce && Mt.push(0);
          }
          let At = this.trees[ct + 1] = this._createTree(Mt);
          Z && console.timeEnd(Pt);
          for (let bt = ct; bt >= et; bt--) {
            const Ut = +Date.now();
            At = this.trees[bt] = this._createTree(this._cluster(At, bt)), Z && console.log("z%d: %d clusters in %dms", bt, At.numItems, +Date.now() - Ut);
          }
          return Z && console.timeEnd("total time"), this;
        }
        getClusters(V, Z) {
          let et = ((V[0] + 180) % 360 + 360) % 360 - 180;
          const ct = Math.max(-90, Math.min(90, V[1]));
          let Pt = V[2] === 180 ? 180 : ((V[2] + 180) % 360 + 360) % 360 - 180;
          const Mt = Math.max(-90, Math.min(90, V[3]));
          if (V[2] - V[0] >= 360) et = -180, Pt = 180;
          else if (et > Pt) {
            const Bt = this.getClusters([et, ct, 180, Mt], Z), me = this.getClusters([-180, ct, Pt, Mt], Z);
            return Bt.concat(me);
          }
          const At = this.trees[this._limitZoom(Z)], bt = At.range(Rt(et), qt(Mt), Rt(Pt), qt(ct)), Ut = At.data, te = [];
          for (const Bt of bt) {
            const me = this.stride * Bt;
            te.push(Ut[me + K] > 1 ? Tt(Ut, me, this.clusterProps) : this.points[Ut[me + Se]]);
          }
          return te;
        }
        getChildren(V) {
          const Z = this._getOriginId(V), et = this._getOriginZoom(V), ct = "No cluster with the specified id.", Pt = this.trees[et];
          if (!Pt) throw new Error(ct);
          const Mt = Pt.data;
          if (Z * this.stride >= Mt.length) throw new Error(ct);
          const At = this.options.radius / (this.options.extent * Math.pow(2, et - 1)), bt = Pt.within(Mt[Z * this.stride], Mt[Z * this.stride + 1], At), Ut = [];
          for (const te of bt) {
            const Bt = te * this.stride;
            Mt[Bt + 4] === V && Ut.push(Mt[Bt + K] > 1 ? Tt(Mt, Bt, this.clusterProps) : this.points[Mt[Bt + Se]]);
          }
          if (Ut.length === 0) throw new Error(ct);
          return Ut;
        }
        getLeaves(V, Z, et) {
          const ct = [];
          return this._appendLeaves(ct, V, Z = Z || 10, et = et || 0, 0), ct;
        }
        getTile(V, Z, et) {
          const ct = this.trees[this._limitZoom(V)], Pt = Math.pow(2, V), { extent: Mt, radius: At } = this.options, bt = At / Mt, Ut = (et - bt) / Pt, te = (et + 1 + bt) / Pt, Bt = { features: [] };
          return this._addTileFeatures(ct.range((Z - bt) / Pt, Ut, (Z + 1 + bt) / Pt, te), ct.data, Z, et, Pt, Bt), Z === 0 && this._addTileFeatures(ct.range(1 - bt / Pt, Ut, 1, te), ct.data, Pt, et, Pt, Bt), Z === Pt - 1 && this._addTileFeatures(ct.range(0, Ut, bt / Pt, te), ct.data, -1, et, Pt, Bt), Bt.features.length ? Bt : null;
        }
        getClusterExpansionZoom(V) {
          let Z = this._getOriginZoom(V) - 1;
          for (; Z <= this.options.maxZoom; ) {
            const et = this.getChildren(V);
            if (Z++, et.length !== 1) break;
            V = et[0].properties.cluster_id;
          }
          return Z;
        }
        _appendLeaves(V, Z, et, ct, Pt) {
          const Mt = this.getChildren(Z);
          for (const At of Mt) {
            const bt = At.properties;
            if (bt && bt.cluster ? Pt + bt.point_count <= ct ? Pt += bt.point_count : Pt = this._appendLeaves(V, bt.cluster_id, et, ct, Pt) : Pt < ct ? Pt++ : V.push(At), V.length === et) break;
          }
          return Pt;
        }
        _createTree(V) {
          const Z = new v.av(V.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let et = 0; et < V.length; et += this.stride) Z.add(V[et], V[et + 1]);
          return Z.finish(), Z.data = V, Z;
        }
        _addTileFeatures(V, Z, et, ct, Pt, Mt) {
          for (const At of V) {
            const bt = At * this.stride, Ut = Z[bt + K] > 1;
            let te, Bt, me;
            if (Ut) te = Et(Z, bt, this.clusterProps), Bt = Z[bt], me = Z[bt + 1];
            else {
              const xi = this.points[Z[bt + Se]];
              te = xi.properties;
              const [Ke, yi] = xi.geometry.coordinates;
              Bt = Rt(Ke), me = qt(yi);
            }
            const Ne = { type: 1, geometry: [[Math.round(this.options.extent * (Bt * Pt - et)), Math.round(this.options.extent * (me * Pt - ct))]], tags: te };
            let $e;
            $e = Ut || this.options.generateId ? Z[bt + Se] : this.points[Z[bt + Se]].id, $e !== void 0 && (Ne.id = $e), Mt.features.push(Ne);
          }
        }
        _limitZoom(V) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+V), this.options.maxZoom + 1));
        }
        _cluster(V, Z) {
          const { radius: et, extent: ct, reduce: Pt, minPoints: Mt } = this.options, At = et / (ct * Math.pow(2, Z)), bt = V.data, Ut = [], te = this.stride;
          for (let Bt = 0; Bt < bt.length; Bt += te) {
            if (bt[Bt + 2] <= Z) continue;
            bt[Bt + 2] = Z;
            const me = bt[Bt], Ne = bt[Bt + 1], $e = V.within(bt[Bt], bt[Bt + 1], At), xi = bt[Bt + K];
            let Ke = xi;
            for (const yi of $e) {
              const pi = yi * te;
              bt[pi + 2] > Z && (Ke += bt[pi + K]);
            }
            if (Ke > xi && Ke >= Mt) {
              let yi, pi = me * xi, Zi = Ne * xi, Bi = -1;
              const li = ((Bt / te | 0) << 5) + (Z + 1) + this.points.length;
              for (const Di of $e) {
                const Gi = Di * te;
                if (bt[Gi + 2] <= Z) continue;
                bt[Gi + 2] = Z;
                const hr = bt[Gi + K];
                pi += bt[Gi] * hr, Zi += bt[Gi + 1] * hr, bt[Gi + 4] = li, Pt && (yi || (yi = this._map(bt, Bt, !0), Bi = this.clusterProps.length, this.clusterProps.push(yi)), Pt(yi, this._map(bt, Gi)));
              }
              bt[Bt + 4] = li, Ut.push(pi / Ke, Zi / Ke, 1 / 0, li, -1, Ke), Pt && Ut.push(Bi);
            } else {
              for (let yi = 0; yi < te; yi++) Ut.push(bt[Bt + yi]);
              if (Ke > 1) for (const yi of $e) {
                const pi = yi * te;
                if (!(bt[pi + 2] <= Z)) {
                  bt[pi + 2] = Z;
                  for (let Zi = 0; Zi < te; Zi++) Ut.push(bt[pi + Zi]);
                }
              }
            }
          }
          return Ut;
        }
        _getOriginId(V) {
          return V - this.points.length >> 5;
        }
        _getOriginZoom(V) {
          return (V - this.points.length) % 32;
        }
        _map(V, Z, et) {
          if (V[Z + K] > 1) {
            const Mt = this.clusterProps[V[Z + pt]];
            return et ? Object.assign({}, Mt) : Mt;
          }
          const ct = this.points[V[Z + Se]].properties, Pt = this.options.map(ct);
          return et && Pt === ct ? Object.assign({}, Pt) : Pt;
        }
      }
      function Tt(ut, V, Z) {
        return { type: "Feature", id: ut[V + Se], properties: Et(ut, V, Z), geometry: { type: "Point", coordinates: [(et = ut[V], 360 * (et - 0.5)), Gt(ut[V + 1])] } };
        var et;
      }
      function Et(ut, V, Z) {
        const et = ut[V + K], ct = et >= 1e4 ? `${Math.round(et / 1e3)}k` : et >= 1e3 ? Math.round(et / 100) / 10 + "k" : et, Pt = ut[V + pt], Mt = Pt === -1 ? {} : Object.assign({}, Z[Pt]);
        return Object.assign(Mt, { cluster: !0, cluster_id: ut[V + Se], point_count: et, point_count_abbreviated: ct });
      }
      function Rt(ut) {
        return ut / 360 + 0.5;
      }
      function qt(ut) {
        const V = Math.sin(ut * Math.PI / 180), Z = 0.5 - 0.25 * Math.log((1 + V) / (1 - V)) / Math.PI;
        return Z < 0 ? 0 : Z > 1 ? 1 : Z;
      }
      function Gt(ut) {
        const V = (180 - 360 * ut) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(V)) / Math.PI - 90;
      }
      function we(ut, V, Z, et) {
        let ct = et;
        const Pt = V + (Z - V >> 1);
        let Mt, At = Z - V;
        const bt = ut[V], Ut = ut[V + 1], te = ut[Z], Bt = ut[Z + 1];
        for (let me = V + 3; me < Z; me += 3) {
          const Ne = be(ut[me], ut[me + 1], bt, Ut, te, Bt);
          if (Ne > ct) Mt = me, ct = Ne;
          else if (Ne === ct) {
            const $e = Math.abs(me - Pt);
            $e < At && (Mt = me, At = $e);
          }
        }
        ct > et && (Mt - V > 3 && we(ut, V, Mt, et), ut[Mt + 2] = ct, Z - Mt > 3 && we(ut, Mt, Z, et));
      }
      function be(ut, V, Z, et, ct, Pt) {
        let Mt = ct - Z, At = Pt - et;
        if (Mt !== 0 || At !== 0) {
          const bt = ((ut - Z) * Mt + (V - et) * At) / (Mt * Mt + At * At);
          bt > 1 ? (Z = ct, et = Pt) : bt > 0 && (Z += Mt * bt, et += At * bt);
        }
        return Mt = ut - Z, At = V - et, Mt * Mt + At * At;
      }
      function Ie(ut, V, Z, et) {
        const ct = { id: ut ?? null, type: V, geometry: Z, tags: et, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (V === "Point" || V === "MultiPoint" || V === "LineString") Pe(ct, Z);
        else if (V === "Polygon") Pe(ct, Z[0]);
        else if (V === "MultiLineString") for (const Pt of Z) Pe(ct, Pt);
        else if (V === "MultiPolygon") for (const Pt of Z) Pe(ct, Pt[0]);
        return ct;
      }
      function Pe(ut, V) {
        for (let Z = 0; Z < V.length; Z += 3) ut.minX = Math.min(ut.minX, V[Z]), ut.minY = Math.min(ut.minY, V[Z + 1]), ut.maxX = Math.max(ut.maxX, V[Z]), ut.maxY = Math.max(ut.maxY, V[Z + 1]);
      }
      function ti(ut, V, Z, et) {
        if (!V.geometry) return;
        const ct = V.geometry.coordinates;
        if (ct && ct.length === 0) return;
        const Pt = V.geometry.type, Mt = Math.pow(Z.tolerance / ((1 << Z.maxZoom) * Z.extent), 2);
        let At = [], bt = V.id;
        if (Z.promoteId ? bt = V.properties[Z.promoteId] : Z.generateId && (bt = et || 0), Pt === "Point") Qt(ct, At);
        else if (Pt === "MultiPoint") for (const Ut of ct) Qt(Ut, At);
        else if (Pt === "LineString") Y(ct, At, Mt, !1);
        else if (Pt === "MultiLineString") {
          if (Z.lineMetrics) {
            for (const Ut of ct) At = [], Y(Ut, At, Mt, !1), ut.push(Ie(bt, "LineString", At, V.properties));
            return;
          }
          ui(ct, At, Mt, !1);
        } else if (Pt === "Polygon") ui(ct, At, Mt, !0);
        else {
          if (Pt !== "MultiPolygon") {
            if (Pt === "GeometryCollection") {
              for (const Ut of V.geometry.geometries) ti(ut, { id: bt, geometry: Ut, properties: V.properties }, Z, et);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const Ut of ct) {
            const te = [];
            ui(Ut, te, Mt, !0), At.push(te);
          }
        }
        ut.push(Ie(bt, Pt, At, V.properties));
      }
      function Qt(ut, V) {
        V.push(Ge(ut[0]), se(ut[1]), 0);
      }
      function Y(ut, V, Z, et) {
        let ct, Pt, Mt = 0;
        for (let bt = 0; bt < ut.length; bt++) {
          const Ut = Ge(ut[bt][0]), te = se(ut[bt][1]);
          V.push(Ut, te, 0), bt > 0 && (Mt += et ? (ct * te - Ut * Pt) / 2 : Math.sqrt(Math.pow(Ut - ct, 2) + Math.pow(te - Pt, 2))), ct = Ut, Pt = te;
        }
        const At = V.length - 3;
        V[2] = 1, we(V, 0, At, Z), V[At + 2] = 1, V.size = Math.abs(Mt), V.start = 0, V.end = V.size;
      }
      function ui(ut, V, Z, et) {
        for (let ct = 0; ct < ut.length; ct++) {
          const Pt = [];
          Y(ut[ct], Pt, Z, et), V.push(Pt);
        }
      }
      function Ge(ut) {
        return ut / 360 + 0.5;
      }
      function se(ut) {
        const V = Math.sin(ut * Math.PI / 180), Z = 0.5 - 0.25 * Math.log((1 + V) / (1 - V)) / Math.PI;
        return Z < 0 ? 0 : Z > 1 ? 1 : Z;
      }
      function _e(ut, V, Z, et, ct, Pt, Mt, At) {
        if (et /= V, Pt >= (Z /= V) && Mt < et) return ut;
        if (Mt < Z || Pt >= et) return null;
        const bt = [];
        for (const Ut of ut) {
          const te = Ut.geometry;
          let Bt = Ut.type;
          const me = ct === 0 ? Ut.minX : Ut.minY, Ne = ct === 0 ? Ut.maxX : Ut.maxY;
          if (me >= Z && Ne < et) {
            bt.push(Ut);
            continue;
          }
          if (Ne < Z || me >= et) continue;
          let $e = [];
          if (Bt === "Point" || Bt === "MultiPoint") ze(te, $e, Z, et, ct);
          else if (Bt === "LineString") ke(te, $e, Z, et, ct, !1, At.lineMetrics);
          else if (Bt === "MultiLineString") di(te, $e, Z, et, ct, !1);
          else if (Bt === "Polygon") di(te, $e, Z, et, ct, !0);
          else if (Bt === "MultiPolygon") for (const xi of te) {
            const Ke = [];
            di(xi, Ke, Z, et, ct, !0), Ke.length && $e.push(Ke);
          }
          if ($e.length) {
            if (At.lineMetrics && Bt === "LineString") {
              for (const xi of $e) bt.push(Ie(Ut.id, Bt, xi, Ut.tags));
              continue;
            }
            Bt !== "LineString" && Bt !== "MultiLineString" || ($e.length === 1 ? (Bt = "LineString", $e = $e[0]) : Bt = "MultiLineString"), Bt !== "Point" && Bt !== "MultiPoint" || (Bt = $e.length === 3 ? "Point" : "MultiPoint"), bt.push(Ie(Ut.id, Bt, $e, Ut.tags));
          }
        }
        return bt.length ? bt : null;
      }
      function ze(ut, V, Z, et, ct) {
        for (let Pt = 0; Pt < ut.length; Pt += 3) {
          const Mt = ut[Pt + ct];
          Mt >= Z && Mt <= et && ai(V, ut[Pt], ut[Pt + 1], ut[Pt + 2]);
        }
      }
      function ke(ut, V, Z, et, ct, Pt, Mt) {
        let At = Ze(ut);
        const bt = ct === 0 ? wi : Ei;
        let Ut, te, Bt = ut.start;
        for (let Ke = 0; Ke < ut.length - 3; Ke += 3) {
          const yi = ut[Ke], pi = ut[Ke + 1], Zi = ut[Ke + 2], Bi = ut[Ke + 3], li = ut[Ke + 4], Di = ct === 0 ? yi : pi, Gi = ct === 0 ? Bi : li;
          let hr = !1;
          Mt && (Ut = Math.sqrt(Math.pow(yi - Bi, 2) + Math.pow(pi - li, 2))), Di < Z ? Gi > Z && (te = bt(At, yi, pi, Bi, li, Z), Mt && (At.start = Bt + Ut * te)) : Di > et ? Gi < et && (te = bt(At, yi, pi, Bi, li, et), Mt && (At.start = Bt + Ut * te)) : ai(At, yi, pi, Zi), Gi < Z && Di >= Z && (te = bt(At, yi, pi, Bi, li, Z), hr = !0), Gi > et && Di <= et && (te = bt(At, yi, pi, Bi, li, et), hr = !0), !Pt && hr && (Mt && (At.end = Bt + Ut * te), V.push(At), At = Ze(ut)), Mt && (Bt += Ut);
        }
        let me = ut.length - 3;
        const Ne = ut[me], $e = ut[me + 1], xi = ct === 0 ? Ne : $e;
        xi >= Z && xi <= et && ai(At, Ne, $e, ut[me + 2]), me = At.length - 3, Pt && me >= 3 && (At[me] !== At[0] || At[me + 1] !== At[1]) && ai(At, At[0], At[1], At[2]), At.length && V.push(At);
      }
      function Ze(ut) {
        const V = [];
        return V.size = ut.size, V.start = ut.start, V.end = ut.end, V;
      }
      function di(ut, V, Z, et, ct, Pt) {
        for (const Mt of ut) ke(Mt, V, Z, et, ct, Pt, !1);
      }
      function ai(ut, V, Z, et) {
        ut.push(V, Z, et);
      }
      function wi(ut, V, Z, et, ct, Pt) {
        const Mt = (Pt - V) / (et - V);
        return ai(ut, Pt, Z + (ct - Z) * Mt, 1), Mt;
      }
      function Ei(ut, V, Z, et, ct, Pt) {
        const Mt = (Pt - Z) / (ct - Z);
        return ai(ut, V + (et - V) * Mt, Pt, 1), Mt;
      }
      function oe(ut, V) {
        const Z = [];
        for (let et = 0; et < ut.length; et++) {
          const ct = ut[et], Pt = ct.type;
          let Mt;
          if (Pt === "Point" || Pt === "MultiPoint" || Pt === "LineString") Mt = ei(ct.geometry, V);
          else if (Pt === "MultiLineString" || Pt === "Polygon") {
            Mt = [];
            for (const At of ct.geometry) Mt.push(ei(At, V));
          } else if (Pt === "MultiPolygon") {
            Mt = [];
            for (const At of ct.geometry) {
              const bt = [];
              for (const Ut of At) bt.push(ei(Ut, V));
              Mt.push(bt);
            }
          }
          Z.push(Ie(ct.id, Pt, Mt, ct.tags));
        }
        return Z;
      }
      function ei(ut, V) {
        const Z = [];
        Z.size = ut.size, ut.start !== void 0 && (Z.start = ut.start, Z.end = ut.end);
        for (let et = 0; et < ut.length; et += 3) Z.push(ut[et] + V, ut[et + 1], ut[et + 2]);
        return Z;
      }
      function oi(ut, V) {
        if (ut.transformed) return ut;
        const Z = 1 << ut.z, et = ut.x, ct = ut.y;
        for (const Pt of ut.features) {
          const Mt = Pt.geometry, At = Pt.type;
          if (Pt.geometry = [], At === 1) for (let bt = 0; bt < Mt.length; bt += 2) Pt.geometry.push(Te(Mt[bt], Mt[bt + 1], V, Z, et, ct));
          else for (let bt = 0; bt < Mt.length; bt++) {
            const Ut = [];
            for (let te = 0; te < Mt[bt].length; te += 2) Ut.push(Te(Mt[bt][te], Mt[bt][te + 1], V, Z, et, ct));
            Pt.geometry.push(Ut);
          }
        }
        return ut.transformed = !0, ut;
      }
      function Te(ut, V, Z, et, ct, Pt) {
        return [Math.round(Z * (ut * et - ct)), Math.round(Z * (V * et - Pt))];
      }
      function cr(ut, V, Z, et, ct) {
        const Pt = V === ct.maxZoom ? 0 : ct.tolerance / ((1 << V) * ct.extent), Mt = { features: [], numPoints: 0, numSimplified: 0, numFeatures: ut.length, source: null, x: Z, y: et, z: V, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const At of ut) le(Mt, At, Pt, ct);
        return Mt;
      }
      function le(ut, V, Z, et) {
        const ct = V.geometry, Pt = V.type, Mt = [];
        if (ut.minX = Math.min(ut.minX, V.minX), ut.minY = Math.min(ut.minY, V.minY), ut.maxX = Math.max(ut.maxX, V.maxX), ut.maxY = Math.max(ut.maxY, V.maxY), Pt === "Point" || Pt === "MultiPoint") for (let At = 0; At < ct.length; At += 3) Mt.push(ct[At], ct[At + 1]), ut.numPoints++, ut.numSimplified++;
        else if (Pt === "LineString") si(Mt, ct, ut, Z, !1, !1);
        else if (Pt === "MultiLineString" || Pt === "Polygon") for (let At = 0; At < ct.length; At++) si(Mt, ct[At], ut, Z, Pt === "Polygon", At === 0);
        else if (Pt === "MultiPolygon") for (let At = 0; At < ct.length; At++) {
          const bt = ct[At];
          for (let Ut = 0; Ut < bt.length; Ut++) si(Mt, bt[Ut], ut, Z, !0, Ut === 0);
        }
        if (Mt.length) {
          let At = V.tags || null;
          if (Pt === "LineString" && et.lineMetrics) {
            At = {};
            for (const Ut in V.tags) At[Ut] = V.tags[Ut];
            At.mapbox_clip_start = ct.start / ct.size, At.mapbox_clip_end = ct.end / ct.size;
          }
          const bt = { geometry: Mt, type: Pt === "Polygon" || Pt === "MultiPolygon" ? 3 : Pt === "LineString" || Pt === "MultiLineString" ? 2 : 1, tags: At };
          V.id !== null && (bt.id = V.id), ut.features.push(bt);
        }
      }
      function si(ut, V, Z, et, ct, Pt) {
        const Mt = et * et;
        if (et > 0 && V.size < (ct ? Mt : et)) return void (Z.numPoints += V.length / 3);
        const At = [];
        for (let bt = 0; bt < V.length; bt += 3) (et === 0 || V[bt + 2] > Mt) && (Z.numSimplified++, At.push(V[bt], V[bt + 1])), Z.numPoints++;
        ct && function(bt, Ut) {
          let te = 0;
          for (let Bt = 0, me = bt.length, Ne = me - 2; Bt < me; Ne = Bt, Bt += 2) te += (bt[Bt] - bt[Ne]) * (bt[Bt + 1] + bt[Ne + 1]);
          if (te > 0 === Ut) for (let Bt = 0, me = bt.length; Bt < me / 2; Bt += 2) {
            const Ne = bt[Bt], $e = bt[Bt + 1];
            bt[Bt] = bt[me - 2 - Bt], bt[Bt + 1] = bt[me - 1 - Bt], bt[me - 2 - Bt] = Ne, bt[me - 1 - Bt] = $e;
          }
        }(At, Pt), ut.push(At);
      }
      const Ce = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class zi {
        constructor(V, Z) {
          const et = (Z = this.options = function(Pt, Mt) {
            for (const At in Mt) Pt[At] = Mt[At];
            return Pt;
          }(Object.create(Ce), Z)).debug;
          if (et && console.time("preprocess data"), Z.maxZoom < 0 || Z.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (Z.promoteId && Z.generateId) throw new Error("promoteId and generateId cannot be used together.");
          let ct = function(Pt, Mt) {
            const At = [];
            if (Pt.type === "FeatureCollection") for (let bt = 0; bt < Pt.features.length; bt++) ti(At, Pt.features[bt], Mt, bt);
            else ti(At, Pt.type === "Feature" ? Pt : { geometry: Pt }, Mt);
            return At;
          }(V, Z);
          this.tiles = {}, this.tileCoords = [], et && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", Z.indexMaxZoom, Z.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ct = function(Pt, Mt) {
            const At = Mt.buffer / Mt.extent;
            let bt = Pt;
            const Ut = _e(Pt, 1, -1 - At, At, 0, -1, 2, Mt), te = _e(Pt, 1, 1 - At, 2 + At, 0, -1, 2, Mt);
            return (Ut || te) && (bt = _e(Pt, 1, -At, 1 + At, 0, -1, 2, Mt) || [], Ut && (bt = oe(Ut, 1).concat(bt)), te && (bt = bt.concat(oe(te, -1)))), bt;
          }(ct, Z), ct.length && this.splitTile(ct, 0, 0, 0), et && (ct.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(V, Z, et, ct, Pt, Mt, At) {
          const bt = [V, Z, et, ct], Ut = this.options, te = Ut.debug;
          for (; bt.length; ) {
            ct = bt.pop(), et = bt.pop(), Z = bt.pop(), V = bt.pop();
            const Bt = 1 << Z, me = Sr(Z, et, ct);
            let Ne = this.tiles[me];
            if (!Ne && (te > 1 && console.time("creation"), Ne = this.tiles[me] = cr(V, Z, et, ct, Ut), this.tileCoords.push({ z: Z, x: et, y: ct }), te)) {
              te > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Z, et, ct, Ne.numFeatures, Ne.numPoints, Ne.numSimplified), console.timeEnd("creation"));
              const hr = `z${Z}`;
              this.stats[hr] = (this.stats[hr] || 0) + 1, this.total++;
            }
            if (Ne.source = V, Pt == null) {
              if (Z === Ut.indexMaxZoom || Ne.numPoints <= Ut.indexMaxPoints) continue;
            } else {
              if (Z === Ut.maxZoom || Z === Pt) continue;
              if (Pt != null) {
                const hr = Pt - Z;
                if (et !== Mt >> hr || ct !== At >> hr) continue;
              }
            }
            if (Ne.source = null, V.length === 0) continue;
            te > 1 && console.time("clipping");
            const $e = 0.5 * Ut.buffer / Ut.extent, xi = 0.5 - $e, Ke = 0.5 + $e, yi = 1 + $e;
            let pi = null, Zi = null, Bi = null, li = null, Di = _e(V, Bt, et - $e, et + Ke, 0, Ne.minX, Ne.maxX, Ut), Gi = _e(V, Bt, et + xi, et + yi, 0, Ne.minX, Ne.maxX, Ut);
            V = null, Di && (pi = _e(Di, Bt, ct - $e, ct + Ke, 1, Ne.minY, Ne.maxY, Ut), Zi = _e(Di, Bt, ct + xi, ct + yi, 1, Ne.minY, Ne.maxY, Ut), Di = null), Gi && (Bi = _e(Gi, Bt, ct - $e, ct + Ke, 1, Ne.minY, Ne.maxY, Ut), li = _e(Gi, Bt, ct + xi, ct + yi, 1, Ne.minY, Ne.maxY, Ut), Gi = null), te > 1 && console.timeEnd("clipping"), bt.push(pi || [], Z + 1, 2 * et, 2 * ct), bt.push(Zi || [], Z + 1, 2 * et, 2 * ct + 1), bt.push(Bi || [], Z + 1, 2 * et + 1, 2 * ct), bt.push(li || [], Z + 1, 2 * et + 1, 2 * ct + 1);
          }
        }
        getTile(V, Z, et) {
          V = +V, Z = +Z, et = +et;
          const ct = this.options, { extent: Pt, debug: Mt } = ct;
          if (V < 0 || V > 24) return null;
          const At = 1 << V, bt = Sr(V, Z = Z + At & At - 1, et);
          if (this.tiles[bt]) return oi(this.tiles[bt], Pt);
          Mt > 1 && console.log("drilling down to z%d-%d-%d", V, Z, et);
          let Ut, te = V, Bt = Z, me = et;
          for (; !Ut && te > 0; ) te--, Bt >>= 1, me >>= 1, Ut = this.tiles[Sr(te, Bt, me)];
          return Ut && Ut.source ? (Mt > 1 && (console.log("found parent tile z%d-%d-%d", te, Bt, me), console.time("drilling down")), this.splitTile(Ut.source, te, Bt, me, V, Z, et), Mt > 1 && console.timeEnd("drilling down"), this.tiles[bt] ? oi(this.tiles[bt], Pt) : null) : null;
        }
      }
      function Sr(ut, V, Z) {
        return 32 * ((1 << ut) * Z + V) + ut;
      }
      function Ee(ut, V) {
        return V ? ut.properties[V] : ut.id;
      }
      function Xr(ut, V) {
        if (ut == null) return !0;
        if (ut.type === "Feature") return Ee(ut, V) != null;
        if (ut.type === "FeatureCollection") {
          const Z = /* @__PURE__ */ new Set();
          for (const et of ut.features) {
            const ct = Ee(et, V);
            if (ct == null || Z.has(ct)) return !1;
            Z.add(ct);
          }
          return !0;
        }
        return !1;
      }
      function Vi(ut, V) {
        const Z = /* @__PURE__ */ new Map();
        if (ut != null) if (ut.type === "Feature") Z.set(Ee(ut, V), ut);
        else for (const et of ut.features) Z.set(Ee(et, V), et);
        return Z;
      }
      class Mr extends O {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile(V, Z) {
          return v._(this, void 0, void 0, function* () {
            const et = V.tileID.canonical;
            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
            const ct = this._geoJSONIndex.getTile(et.z, et.x, et.y);
            if (!ct) return null;
            const Pt = new class {
              constructor(At) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = v.X, this.length = At.length, this._features = At;
              }
              feature(At) {
                return new class {
                  constructor(bt) {
                    this._feature = bt, this.extent = v.X, this.type = bt.type, this.properties = bt.tags, "id" in bt && !isNaN(bt.id) && (this.id = parseInt(bt.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const bt = [];
                      for (const Ut of this._feature.geometry) bt.push([new v.P(Ut[0], Ut[1])]);
                      return bt;
                    }
                    {
                      const bt = [];
                      for (const Ut of this._feature.geometry) {
                        const te = [];
                        for (const Bt of Ut) te.push(new v.P(Bt[0], Bt[1]));
                        bt.push(te);
                      }
                      return bt;
                    }
                  }
                  toGeoJSON(bt, Ut, te) {
                    return yt.call(this, bt, Ut, te);
                  }
                }(this._features[At]);
              }
            }(ct.features);
            let Mt = Ht(Pt);
            return Mt.byteOffset === 0 && Mt.byteLength === Mt.buffer.byteLength || (Mt = new Uint8Array(Mt)), { vectorTile: Pt, rawData: Mt.buffer };
          });
        }
        loadData(V) {
          return v._(this, void 0, void 0, function* () {
            var Z;
            (Z = this._pendingRequest) === null || Z === void 0 || Z.abort();
            const et = !!(V && V.request && V.request.collectResourceTiming) && new v.bv(V.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON(V, this._pendingRequest), this._geoJSONIndex = V.cluster ? new xt(function({ superclusterOptions: Mt, clusterProperties: At }) {
                if (!At || !Mt) return Mt;
                const bt = {}, Ut = {}, te = { accumulated: null, zoom: 0 }, Bt = { properties: null }, me = Object.keys(At);
                for (const Ne of me) {
                  const [$e, xi] = At[Ne], Ke = v.bC(xi), yi = v.bC(typeof $e == "string" ? [$e, ["accumulated"], ["get", Ne]] : $e);
                  bt[Ne] = Ke.value, Ut[Ne] = yi.value;
                }
                return Mt.map = (Ne) => {
                  Bt.properties = Ne;
                  const $e = {};
                  for (const xi of me) $e[xi] = bt[xi].evaluate(te, Bt);
                  return $e;
                }, Mt.reduce = (Ne, $e) => {
                  Bt.properties = $e;
                  for (const xi of me) te.accumulated = Ne[xi], Ne[xi] = Ut[xi].evaluate(te, Bt);
                }, Mt;
              }(V)).load((yield this._pendingData).features) : (ct = yield this._pendingData, new zi(ct, V.geojsonVtOptions)), this.loaded = {};
              const Pt = {};
              if (et) {
                const Mt = et.finish();
                Mt && (Pt.resourceTiming = {}, Pt.resourceTiming[V.source] = JSON.parse(JSON.stringify(Mt)));
              }
              return Pt;
            } catch (Pt) {
              if (delete this._pendingRequest, v.bB(Pt)) return { abandoned: !0 };
              throw Pt;
            }
            var ct;
          });
        }
        getData() {
          return v._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(V) {
          const Z = this.loaded;
          return Z && Z[V.uid] ? super.reloadTile(V) : this.loadTile(V);
        }
        loadAndProcessGeoJSON(V, Z) {
          return v._(this, void 0, void 0, function* () {
            let et = yield this.loadGeoJSON(V, Z);
            if (delete this._pendingRequest, typeof et != "object") throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`);
            if (ot(et, !0), V.filter) {
              const ct = v.bC(V.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (ct.result === "error") throw new Error(ct.value.map((Mt) => `${Mt.key}: ${Mt.message}`).join(", "));
              et = { type: "FeatureCollection", features: et.features.filter((Mt) => ct.value.evaluate({ zoom: 0 }, Mt)) };
            }
            return et;
          });
        }
        loadGeoJSON(V, Z) {
          return v._(this, void 0, void 0, function* () {
            const { promoteId: et } = V;
            if (V.request) {
              const ct = yield v.h(V.request, Z);
              return this._dataUpdateable = Xr(ct.data, et) ? Vi(ct.data, et) : void 0, ct.data;
            }
            if (typeof V.data == "string") try {
              const ct = JSON.parse(V.data);
              return this._dataUpdateable = Xr(ct, et) ? Vi(ct, et) : void 0, ct;
            } catch {
              throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`);
            }
            if (!V.dataDiff) throw new Error(`Input data given to '${V.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${V.source}`);
            return function(ct, Pt, Mt) {
              var At, bt, Ut, te;
              if (Pt.removeAll && ct.clear(), Pt.remove) for (const Bt of Pt.remove) ct.delete(Bt);
              if (Pt.add) for (const Bt of Pt.add) {
                const me = Ee(Bt, Mt);
                me != null && ct.set(me, Bt);
              }
              if (Pt.update) for (const Bt of Pt.update) {
                let me = ct.get(Bt.id);
                if (me == null) continue;
                const Ne = !Bt.removeAllProperties && (((At = Bt.removeProperties) === null || At === void 0 ? void 0 : At.length) > 0 || ((bt = Bt.addOrUpdateProperties) === null || bt === void 0 ? void 0 : bt.length) > 0);
                if ((Bt.newGeometry || Bt.removeAllProperties || Ne) && (me = Object.assign({}, me), ct.set(Bt.id, me), Ne && (me.properties = Object.assign({}, me.properties))), Bt.newGeometry && (me.geometry = Bt.newGeometry), Bt.removeAllProperties) me.properties = {};
                else if (((Ut = Bt.removeProperties) === null || Ut === void 0 ? void 0 : Ut.length) > 0) for (const $e of Bt.removeProperties) Object.prototype.hasOwnProperty.call(me.properties, $e) && delete me.properties[$e];
                if (((te = Bt.addOrUpdateProperties) === null || te === void 0 ? void 0 : te.length) > 0) for (const { key: $e, value: xi } of Bt.addOrUpdateProperties) me.properties[$e] = xi;
              }
            }(this._dataUpdateable, V.dataDiff, et), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(V) {
          return v._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(V) {
          return this._geoJSONIndex.getClusterExpansionZoom(V.clusterId);
        }
        getClusterChildren(V) {
          return this._geoJSONIndex.getChildren(V.clusterId);
        }
        getClusterLeaves(V) {
          return this._geoJSONIndex.getLeaves(V.clusterId, V.limit, V.offset);
        }
      }
      class Er {
        constructor(V) {
          this.self = V, this.actor = new v.F(V), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (Z, et) => {
            if (this.externalWorkerSourceTypes[Z]) throw new Error(`Worker source with name "${Z}" already registered.`);
            this.externalWorkerSourceTypes[Z] = et;
          }, this.self.addProtocol = v.bi, this.self.removeProtocol = v.bj, this.self.registerRTLTextPlugin = (Z) => {
            if (v.bD.isParsed()) throw new Error("RTL text plugin already registered.");
            v.bD.setMethods(Z);
          }, this.actor.registerMessageHandler("LDT", (Z, et) => this._getDEMWorkerSource(Z, et.source).loadTile(et)), this.actor.registerMessageHandler("RDT", (Z, et) => v._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource(Z, et.source).removeTile(et);
          })), this.actor.registerMessageHandler("GCEZ", (Z, et) => v._(this, void 0, void 0, function* () {
            return this._getWorkerSource(Z, et.type, et.source).getClusterExpansionZoom(et);
          })), this.actor.registerMessageHandler("GCC", (Z, et) => v._(this, void 0, void 0, function* () {
            return this._getWorkerSource(Z, et.type, et.source).getClusterChildren(et);
          })), this.actor.registerMessageHandler("GCL", (Z, et) => v._(this, void 0, void 0, function* () {
            return this._getWorkerSource(Z, et.type, et.source).getClusterLeaves(et);
          })), this.actor.registerMessageHandler("LD", (Z, et) => this._getWorkerSource(Z, et.type, et.source).loadData(et)), this.actor.registerMessageHandler("GD", (Z, et) => this._getWorkerSource(Z, et.type, et.source).getData()), this.actor.registerMessageHandler("LT", (Z, et) => this._getWorkerSource(Z, et.type, et.source).loadTile(et)), this.actor.registerMessageHandler("RT", (Z, et) => this._getWorkerSource(Z, et.type, et.source).reloadTile(et)), this.actor.registerMessageHandler("AT", (Z, et) => this._getWorkerSource(Z, et.type, et.source).abortTile(et)), this.actor.registerMessageHandler("RMT", (Z, et) => this._getWorkerSource(Z, et.type, et.source).removeTile(et)), this.actor.registerMessageHandler("RS", (Z, et) => v._(this, void 0, void 0, function* () {
            if (!this.workerSources[Z] || !this.workerSources[Z][et.type] || !this.workerSources[Z][et.type][et.source]) return;
            const ct = this.workerSources[Z][et.type][et.source];
            delete this.workerSources[Z][et.type][et.source], ct.removeSource !== void 0 && ct.removeSource(et);
          })), this.actor.registerMessageHandler("RM", (Z) => v._(this, void 0, void 0, function* () {
            delete this.layerIndexes[Z], delete this.availableImages[Z], delete this.workerSources[Z], delete this.demWorkerSources[Z];
          })), this.actor.registerMessageHandler("SR", (Z, et) => v._(this, void 0, void 0, function* () {
            this.referrer = et;
          })), this.actor.registerMessageHandler("SRPS", (Z, et) => this._syncRTLPluginState(Z, et)), this.actor.registerMessageHandler("IS", (Z, et) => v._(this, void 0, void 0, function* () {
            this.self.importScripts(et);
          })), this.actor.registerMessageHandler("SI", (Z, et) => this._setImages(Z, et)), this.actor.registerMessageHandler("UL", (Z, et) => v._(this, void 0, void 0, function* () {
            this._getLayerIndex(Z).update(et.layers, et.removedIds);
          })), this.actor.registerMessageHandler("SL", (Z, et) => v._(this, void 0, void 0, function* () {
            this._getLayerIndex(Z).replace(et);
          }));
        }
        _setImages(V, Z) {
          return v._(this, void 0, void 0, function* () {
            this.availableImages[V] = Z;
            for (const et in this.workerSources[V]) {
              const ct = this.workerSources[V][et];
              for (const Pt in ct) ct[Pt].availableImages = Z;
            }
          });
        }
        _syncRTLPluginState(V, Z) {
          return v._(this, void 0, void 0, function* () {
            if (v.bD.isParsed()) return v.bD.getState();
            if (Z.pluginStatus !== "loading") return v.bD.setState(Z), Z;
            const et = Z.pluginURL;
            if (this.self.importScripts(et), v.bD.isParsed()) {
              const ct = { pluginStatus: "loaded", pluginURL: et };
              return v.bD.setState(ct), ct;
            }
            throw v.bD.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${et}`);
          });
        }
        _getAvailableImages(V) {
          let Z = this.availableImages[V];
          return Z || (Z = []), Z;
        }
        _getLayerIndex(V) {
          let Z = this.layerIndexes[V];
          return Z || (Z = this.layerIndexes[V] = new c()), Z;
        }
        _getWorkerSource(V, Z, et) {
          if (this.workerSources[V] || (this.workerSources[V] = {}), this.workerSources[V][Z] || (this.workerSources[V][Z] = {}), !this.workerSources[V][Z][et]) {
            const ct = { sendAsync: (Pt, Mt) => (Pt.targetMapId = V, this.actor.sendAsync(Pt, Mt)) };
            switch (Z) {
              case "vector":
                this.workerSources[V][Z][et] = new O(ct, this._getLayerIndex(V), this._getAvailableImages(V));
                break;
              case "geojson":
                this.workerSources[V][Z][et] = new Mr(ct, this._getLayerIndex(V), this._getAvailableImages(V));
                break;
              default:
                this.workerSources[V][Z][et] = new this.externalWorkerSourceTypes[Z](ct, this._getLayerIndex(V), this._getAvailableImages(V));
            }
          }
          return this.workerSources[V][Z][et];
        }
        _getDEMWorkerSource(V, Z) {
          return this.demWorkerSources[V] || (this.demWorkerSources[V] = {}), this.demWorkerSources[V][Z] || (this.demWorkerSources[V][Z] = new j()), this.demWorkerSources[V][Z];
        }
      }
      return v.i(self) && (self.worker = new Er(self)), Er;
    }), k("index", ["exports", "./shared"], function(v, c) {
      var z = "4.7.1";
      let U, X;
      const O = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (o) => new Promise((t, r) => {
        const s = requestAnimationFrame(t);
        o.signal.addEventListener("abort", () => {
          cancelAnimationFrame(s), r(c.c());
        });
      }), getImageData(o, t = 0) {
        return this.getImageCanvasContext(o).getImageData(-t, -t, o.width + 2 * t, o.height + 2 * t);
      }, getImageCanvasContext(o) {
        const t = window.document.createElement("canvas"), r = t.getContext("2d", { willReadFrequently: !0 });
        if (!r) throw new Error("failed to create canvas 2d context");
        return t.width = o.width, t.height = o.height, r.drawImage(o, 0, 0, o.width, o.height), r;
      }, resolveURL: (o) => (U || (U = document.createElement("a")), U.href = o, U.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (X == null && (X = matchMedia("(prefers-reduced-motion: reduce)")), X.matches);
      } };
      class j {
        static testProp(t) {
          if (!j.docStyle) return t[0];
          for (let r = 0; r < t.length; r++) if (t[r] in j.docStyle) return t[r];
          return t[0];
        }
        static create(t, r, s) {
          const l = window.document.createElement(t);
          return r !== void 0 && (l.className = r), s && s.appendChild(l), l;
        }
        static createNS(t, r) {
          return window.document.createElementNS(t, r);
        }
        static disableDrag() {
          j.docStyle && j.selectProp && (j.userSelect = j.docStyle[j.selectProp], j.docStyle[j.selectProp] = "none");
        }
        static enableDrag() {
          j.docStyle && j.selectProp && (j.docStyle[j.selectProp] = j.userSelect);
        }
        static setTransform(t, r) {
          t.style[j.transformProp] = r;
        }
        static addEventListener(t, r, s, l = {}) {
          t.addEventListener(r, s, "passive" in l ? l : l.capture);
        }
        static removeEventListener(t, r, s, l = {}) {
          t.removeEventListener(r, s, "passive" in l ? l : l.capture);
        }
        static suppressClickInternal(t) {
          t.preventDefault(), t.stopPropagation(), window.removeEventListener("click", j.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", j.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", j.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(t) {
          const r = t.getBoundingClientRect();
          return { x: r.width / t.offsetWidth || 1, y: r.height / t.offsetHeight || 1, boundingClientRect: r };
        }
        static getPoint(t, r, s) {
          const l = r.boundingClientRect;
          return new c.P((s.clientX - l.left) / r.x - t.clientLeft, (s.clientY - l.top) / r.y - t.clientTop);
        }
        static mousePos(t, r) {
          const s = j.getScale(t);
          return j.getPoint(t, s, r);
        }
        static touchPos(t, r) {
          const s = [], l = j.getScale(t);
          for (let h = 0; h < r.length; h++) s.push(j.getPoint(t, l, r[h]));
          return s;
        }
        static mouseButton(t) {
          return t.button;
        }
        static remove(t) {
          t.parentNode && t.parentNode.removeChild(t);
        }
      }
      j.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, j.selectProp = j.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), j.transformProp = j.testProp(["transform", "WebkitTransform"]);
      const F = { supported: !1, testSupport: function(o) {
        !yt && ot && (st ? gt(o) : mt = o);
      } };
      let mt, ot, yt = !1, st = !1;
      function gt(o) {
        const t = o.createTexture();
        o.bindTexture(o.TEXTURE_2D, t);
        try {
          if (o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, o.RGBA, o.UNSIGNED_BYTE, ot), o.isContextLost()) return;
          F.supported = !0;
        } catch {
        }
        o.deleteTexture(t), yt = !0;
      }
      var zt;
      typeof document < "u" && (ot = document.createElement("img"), ot.onload = () => {
        mt && gt(mt), mt = null, st = !0;
      }, ot.onerror = () => {
        yt = !0, mt = null;
      }, ot.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(o) {
        let t, r, s, l;
        o.resetRequestQueue = () => {
          t = [], r = 0, s = 0, l = {};
        }, o.addThrottleControl = (A) => {
          const L = s++;
          return l[L] = A, L;
        }, o.removeThrottleControl = (A) => {
          delete l[A], g();
        }, o.getImage = (A, L, E = !0) => new Promise((M, R) => {
          F.supported && (A.headers || (A.headers = {}), A.headers.accept = "image/webp,*/*"), c.e(A, { type: "image" }), t.push({ abortController: L, requestParameters: A, supportImageRefresh: E, state: "queued", onError: (q) => {
            R(q);
          }, onSuccess: (q) => {
            M(q);
          } }), g();
        });
        const h = (A) => c._(this, void 0, void 0, function* () {
          A.state = "running";
          const { requestParameters: L, supportImageRefresh: E, onError: M, onSuccess: R, abortController: q } = A, B = E === !1 && !c.i(self) && !c.g(L.url) && (!L.headers || Object.keys(L.headers).reduce((tt, nt) => tt && nt === "accept", !0));
          r++;
          const $ = B ? _(L, q) : c.m(L, q);
          try {
            const tt = yield $;
            delete A.abortController, A.state = "completed", tt.data instanceof HTMLImageElement || c.b(tt.data) ? R(tt) : tt.data && R({ data: yield (Q = tt.data, typeof createImageBitmap == "function" ? c.d(Q) : c.f(Q)), cacheControl: tt.cacheControl, expires: tt.expires });
          } catch (tt) {
            delete A.abortController, M(tt);
          } finally {
            r--, g();
          }
          var Q;
        }), g = () => {
          const A = (() => {
            for (const L of Object.keys(l)) if (l[L]()) return !0;
            return !1;
          })() ? c.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : c.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let L = r; L < A && t.length > 0; L++) {
            const E = t.shift();
            E.abortController.signal.aborted ? L-- : h(E);
          }
        }, _ = (A, L) => new Promise((E, M) => {
          const R = new Image(), q = A.url, B = A.credentials;
          B && B === "include" ? R.crossOrigin = "use-credentials" : (B && B === "same-origin" || !c.s(q)) && (R.crossOrigin = "anonymous"), L.signal.addEventListener("abort", () => {
            R.src = "", M(c.c());
          }), R.fetchPriority = "high", R.onload = () => {
            R.onerror = R.onload = null, E({ data: R });
          }, R.onerror = () => {
            R.onerror = R.onload = null, L.signal.aborted || M(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, R.src = q;
        });
      }(zt || (zt = {})), zt.resetRequestQueue();
      class Jt {
        constructor(t) {
          this._transformRequestFn = t;
        }
        transformRequest(t, r) {
          return this._transformRequestFn && this._transformRequestFn(t, r) || { url: t };
        }
        setTransformRequest(t) {
          this._transformRequestFn = t;
        }
      }
      function Kt(o) {
        var t = new c.A(3);
        return t[0] = o[0], t[1] = o[1], t[2] = o[2], t;
      }
      var pe, Ot = function(o, t, r) {
        return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], o;
      };
      pe = new c.A(3), c.A != Float32Array && (pe[0] = 0, pe[1] = 0, pe[2] = 0);
      var kt = function(o) {
        var t = o[0], r = o[1];
        return t * t + r * r;
      };
      function $t(o) {
        const t = [];
        if (typeof o == "string") t.push({ id: "default", url: o });
        else if (o && o.length > 0) {
          const r = [];
          for (const { id: s, url: l } of o) {
            const h = `${s}${l}`;
            r.indexOf(h) === -1 && (r.push(h), t.push({ id: s, url: l }));
          }
        }
        return t;
      }
      function ae(o, t, r) {
        const s = o.split("?");
        return s[0] += `${t}${r}`, s.join("?");
      }
      (function() {
        var o = new c.A(2);
        c.A != Float32Array && (o[0] = 0, o[1] = 0);
      })();
      class at {
        constructor(t, r, s, l) {
          this.context = t, this.format = s, this.texture = t.gl.createTexture(), this.update(r, l);
        }
        update(t, r, s) {
          const { width: l, height: h } = t, g = !(this.size && this.size[0] === l && this.size[1] === h || s), { context: _ } = this, { gl: A } = _;
          if (this.useMipmap = !!(r && r.useMipmap), A.bindTexture(A.TEXTURE_2D, this.texture), _.pixelStoreUnpackFlipY.set(!1), _.pixelStoreUnpack.set(1), _.pixelStoreUnpackPremultiplyAlpha.set(this.format === A.RGBA && (!r || r.premultiply !== !1)), g) this.size = [l, h], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || c.b(t) ? A.texImage2D(A.TEXTURE_2D, 0, this.format, this.format, A.UNSIGNED_BYTE, t) : A.texImage2D(A.TEXTURE_2D, 0, this.format, l, h, 0, this.format, A.UNSIGNED_BYTE, t.data);
          else {
            const { x: L, y: E } = s || { x: 0, y: 0 };
            t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || c.b(t) ? A.texSubImage2D(A.TEXTURE_2D, 0, L, E, A.RGBA, A.UNSIGNED_BYTE, t) : A.texSubImage2D(A.TEXTURE_2D, 0, L, E, l, h, A.RGBA, A.UNSIGNED_BYTE, t.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && A.generateMipmap(A.TEXTURE_2D);
        }
        bind(t, r, s) {
          const { context: l } = this, { gl: h } = l;
          h.bindTexture(h.TEXTURE_2D, this.texture), s !== h.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (s = h.LINEAR), t !== this.filter && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, t), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, s || t), this.filter = t), r !== this.wrap && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, r), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, r), this.wrap = r);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: t } = this.context;
          t.deleteTexture(this.texture), this.texture = null;
        }
      }
      function lt(o) {
        const { userImage: t } = o;
        return !!(t && t.render && t.render()) && (o.data.replace(new Uint8Array(t.data.buffer)), !0);
      }
      class It extends c.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new c.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(t) {
          if (this.loaded !== t && (this.loaded = t, t)) {
            for (const { ids: r, promiseResolve: s } of this.requestors) s(this._getImagesForIds(r));
            this.requestors = [];
          }
        }
        getImage(t) {
          const r = this.images[t];
          if (r && !r.data && r.spriteData) {
            const s = r.spriteData;
            r.data = new c.R({ width: s.width, height: s.height }, s.context.getImageData(s.x, s.y, s.width, s.height).data), r.spriteData = null;
          }
          return r;
        }
        addImage(t, r) {
          if (this.images[t]) throw new Error(`Image id ${t} already exist, use updateImage instead`);
          this._validate(t, r) && (this.images[t] = r);
        }
        _validate(t, r) {
          let s = !0;
          const l = r.data || r.spriteData;
          return this._validateStretch(r.stretchX, l && l.width) || (this.fire(new c.j(new Error(`Image "${t}" has invalid "stretchX" value`))), s = !1), this._validateStretch(r.stretchY, l && l.height) || (this.fire(new c.j(new Error(`Image "${t}" has invalid "stretchY" value`))), s = !1), this._validateContent(r.content, r) || (this.fire(new c.j(new Error(`Image "${t}" has invalid "content" value`))), s = !1), s;
        }
        _validateStretch(t, r) {
          if (!t) return !0;
          let s = 0;
          for (const l of t) {
            if (l[0] < s || l[1] < l[0] || r < l[1]) return !1;
            s = l[1];
          }
          return !0;
        }
        _validateContent(t, r) {
          if (!t) return !0;
          if (t.length !== 4) return !1;
          const s = r.spriteData, l = s && s.width || r.data.width, h = s && s.height || r.data.height;
          return !(t[0] < 0 || l < t[0] || t[1] < 0 || h < t[1] || t[2] < 0 || l < t[2] || t[3] < 0 || h < t[3] || t[2] < t[0] || t[3] < t[1]);
        }
        updateImage(t, r, s = !0) {
          const l = this.getImage(t);
          if (s && (l.data.width !== r.data.width || l.data.height !== r.data.height)) throw new Error(`size mismatch between old image (${l.data.width}x${l.data.height}) and new image (${r.data.width}x${r.data.height}).`);
          r.version = l.version + 1, this.images[t] = r, this.updatedImages[t] = !0;
        }
        removeImage(t) {
          const r = this.images[t];
          delete this.images[t], delete this.patterns[t], r.userImage && r.userImage.onRemove && r.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(t) {
          return new Promise((r, s) => {
            let l = !0;
            if (!this.isLoaded()) for (const h of t) this.images[h] || (l = !1);
            this.isLoaded() || l ? r(this._getImagesForIds(t)) : this.requestors.push({ ids: t, promiseResolve: r });
          });
        }
        _getImagesForIds(t) {
          const r = {};
          for (const s of t) {
            let l = this.getImage(s);
            l || (this.fire(new c.k("styleimagemissing", { id: s })), l = this.getImage(s)), l ? r[s] = { data: l.data.clone(), pixelRatio: l.pixelRatio, sdf: l.sdf, version: l.version, stretchX: l.stretchX, stretchY: l.stretchY, content: l.content, textFitWidth: l.textFitWidth, textFitHeight: l.textFitHeight, hasRenderCallback: !!(l.userImage && l.userImage.render) } : c.w(`Image "${s}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return r;
        }
        getPixelSize() {
          const { width: t, height: r } = this.atlasImage;
          return { width: t, height: r };
        }
        getPattern(t) {
          const r = this.patterns[t], s = this.getImage(t);
          if (!s) return null;
          if (r && r.position.version === s.version) return r.position;
          if (r) r.position.version = s.version;
          else {
            const l = { w: s.data.width + 2, h: s.data.height + 2, x: 0, y: 0 }, h = new c.I(l, s);
            this.patterns[t] = { bin: l, position: h };
          }
          return this._updatePatternAtlas(), this.patterns[t].position;
        }
        bind(t) {
          const r = t.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new at(t, this.atlasImage, r.RGBA), this.atlasTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const t = [];
          for (const h in this.patterns) t.push(this.patterns[h].bin);
          const { w: r, h: s } = c.p(t), l = this.atlasImage;
          l.resize({ width: r || 1, height: s || 1 });
          for (const h in this.patterns) {
            const { bin: g } = this.patterns[h], _ = g.x + 1, A = g.y + 1, L = this.getImage(h).data, E = L.width, M = L.height;
            c.R.copy(L, l, { x: 0, y: 0 }, { x: _, y: A }, { width: E, height: M }), c.R.copy(L, l, { x: 0, y: M - 1 }, { x: _, y: A - 1 }, { width: E, height: 1 }), c.R.copy(L, l, { x: 0, y: 0 }, { x: _, y: A + M }, { width: E, height: 1 }), c.R.copy(L, l, { x: E - 1, y: 0 }, { x: _ - 1, y: A }, { width: 1, height: M }), c.R.copy(L, l, { x: 0, y: 0 }, { x: _ + E, y: A }, { width: 1, height: M });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(t) {
          for (const r of t) {
            if (this.callbackDispatchedThisFrame[r]) continue;
            this.callbackDispatchedThisFrame[r] = !0;
            const s = this.getImage(r);
            s || c.w(`Image with ID: "${r}" was not found`), lt(s) && this.updateImage(r, s);
          }
        }
      }
      const St = 1e20;
      function Wt(o, t, r, s, l, h, g, _, A) {
        for (let L = t; L < t + s; L++) Xt(o, r * h + L, h, l, g, _, A);
        for (let L = r; L < r + l; L++) Xt(o, L * h + t, 1, s, g, _, A);
      }
      function Xt(o, t, r, s, l, h, g) {
        h[0] = 0, g[0] = -St, g[1] = St, l[0] = o[t];
        for (let _ = 1, A = 0, L = 0; _ < s; _++) {
          l[_] = o[t + _ * r];
          const E = _ * _;
          do {
            const M = h[A];
            L = (l[_] - l[M] + E - M * M) / (_ - M) / 2;
          } while (L <= g[A] && --A > -1);
          A++, h[A] = _, g[A] = L, g[A + 1] = St;
        }
        for (let _ = 0, A = 0; _ < s; _++) {
          for (; g[A + 1] < _; ) A++;
          const L = h[A], E = _ - L;
          o[t + _ * r] = l[L] + E * E;
        }
      }
      class Ht {
        constructor(t, r) {
          this.requestManager = t, this.localIdeographFontFamily = r, this.entries = {};
        }
        setURL(t) {
          this.url = t;
        }
        getGlyphs(t) {
          return c._(this, void 0, void 0, function* () {
            const r = [];
            for (const h in t) for (const g of t[h]) r.push(this._getAndCacheGlyphsPromise(h, g));
            const s = yield Promise.all(r), l = {};
            for (const { stack: h, id: g, glyph: _ } of s) l[h] || (l[h] = {}), l[h][g] = _ && { id: _.id, bitmap: _.bitmap.clone(), metrics: _.metrics };
            return l;
          });
        }
        _getAndCacheGlyphsPromise(t, r) {
          return c._(this, void 0, void 0, function* () {
            let s = this.entries[t];
            s || (s = this.entries[t] = { glyphs: {}, requests: {}, ranges: {} });
            let l = s.glyphs[r];
            if (l !== void 0) return { stack: t, id: r, glyph: l };
            if (l = this._tinySDF(s, t, r), l) return s.glyphs[r] = l, { stack: t, id: r, glyph: l };
            const h = Math.floor(r / 256);
            if (256 * h > 65535) throw new Error("glyphs > 65535 not supported");
            if (s.ranges[h]) return { stack: t, id: r, glyph: l };
            if (!this.url) throw new Error("glyphsUrl is not set");
            if (!s.requests[h]) {
              const _ = Ht.loadGlyphRange(t, h, this.url, this.requestManager);
              s.requests[h] = _;
            }
            const g = yield s.requests[h];
            for (const _ in g) this._doesCharSupportLocalGlyph(+_) || (s.glyphs[+_] = g[+_]);
            return s.ranges[h] = !0, { stack: t, id: r, glyph: g[r] || null };
          });
        }
        _doesCharSupportLocalGlyph(t) {
          return !!this.localIdeographFontFamily && new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(t));
        }
        _tinySDF(t, r, s) {
          const l = this.localIdeographFontFamily;
          if (!l || !this._doesCharSupportLocalGlyph(s)) return;
          let h = t.tinySDF;
          if (!h) {
            let _ = "400";
            /bold/i.test(r) ? _ = "900" : /medium/i.test(r) ? _ = "500" : /light/i.test(r) && (_ = "200"), h = t.tinySDF = new Ht.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: l, fontWeight: _ });
          }
          const g = h.draw(String.fromCharCode(s));
          return { id: s, bitmap: new c.o({ width: g.width || 60, height: g.height || 60 }, g.data), metrics: { width: g.glyphWidth / 2 || 24, height: g.glyphHeight / 2 || 24, left: g.glyphLeft / 2 + 0.5 || 0, top: g.glyphTop / 2 - 27.5 || -8, advance: g.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      Ht.loadGlyphRange = function(o, t, r, s) {
        return c._(this, void 0, void 0, function* () {
          const l = 256 * t, h = l + 255, g = s.transformRequest(r.replace("{fontstack}", o).replace("{range}", `${l}-${h}`), "Glyphs"), _ = yield c.l(g, new AbortController());
          if (!_ || !_.data) throw new Error(`Could not load glyph range. range: ${t}, ${l}-${h}`);
          const A = {};
          for (const L of c.n(_.data)) A[L.id] = L;
          return A;
        });
      }, Ht.TinySDF = class {
        constructor({ fontSize: o = 24, buffer: t = 3, radius: r = 8, cutoff: s = 0.25, fontFamily: l = "sans-serif", fontWeight: h = "normal", fontStyle: g = "normal" } = {}) {
          this.buffer = t, this.cutoff = s, this.radius = r;
          const _ = this.size = o + 4 * t, A = this._createCanvas(_), L = this.ctx = A.getContext("2d", { willReadFrequently: !0 });
          L.font = `${g} ${h} ${o}px ${l}`, L.textBaseline = "alphabetic", L.textAlign = "left", L.fillStyle = "black", this.gridOuter = new Float64Array(_ * _), this.gridInner = new Float64Array(_ * _), this.f = new Float64Array(_), this.z = new Float64Array(_ + 1), this.v = new Uint16Array(_);
        }
        _createCanvas(o) {
          const t = document.createElement("canvas");
          return t.width = t.height = o, t;
        }
        draw(o) {
          const { width: t, actualBoundingBoxAscent: r, actualBoundingBoxDescent: s, actualBoundingBoxLeft: l, actualBoundingBoxRight: h } = this.ctx.measureText(o), g = Math.ceil(r), _ = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(h - l))), A = Math.min(this.size - this.buffer, g + Math.ceil(s)), L = _ + 2 * this.buffer, E = A + 2 * this.buffer, M = Math.max(L * E, 0), R = new Uint8ClampedArray(M), q = { data: R, width: L, height: E, glyphWidth: _, glyphHeight: A, glyphTop: g, glyphLeft: 0, glyphAdvance: t };
          if (_ === 0 || A === 0) return q;
          const { ctx: B, buffer: $, gridInner: Q, gridOuter: tt } = this;
          B.clearRect($, $, _, A), B.fillText(o, $, $ + g);
          const nt = B.getImageData($, $, _, A);
          tt.fill(St, 0, M), Q.fill(0, 0, M);
          for (let it = 0; it < A; it++) for (let ht = 0; ht < _; ht++) {
            const wt = nt.data[4 * (it * _ + ht) + 3] / 255;
            if (wt === 0) continue;
            const _t = (it + $) * L + ht + $;
            if (wt === 1) tt[_t] = 0, Q[_t] = St;
            else {
              const Vt = 0.5 - wt;
              tt[_t] = Vt > 0 ? Vt * Vt : 0, Q[_t] = Vt < 0 ? Vt * Vt : 0;
            }
          }
          Wt(tt, 0, 0, L, E, L, this.f, this.v, this.z), Wt(Q, $, $, _, A, L, this.f, this.v, this.z);
          for (let it = 0; it < M; it++) {
            const ht = Math.sqrt(tt[it]) - Math.sqrt(Q[it]);
            R[it] = Math.round(255 - 255 * (ht / this.radius + this.cutoff));
          }
          return q;
        }
      };
      class jt {
        constructor() {
          this.specification = c.v.light.position;
        }
        possiblyEvaluate(t, r) {
          return c.x(t.expression.evaluate(r));
        }
        interpolate(t, r, s) {
          return { x: c.y.number(t.x, r.x, s), y: c.y.number(t.y, r.y, s), z: c.y.number(t.z, r.z, s) };
        }
      }
      let ee;
      class ie extends c.E {
        constructor(t) {
          super(), ee = ee || new c.q({ anchor: new c.D(c.v.light.anchor), position: new jt(), color: new c.D(c.v.light.color), intensity: new c.D(c.v.light.intensity) }), this._transitionable = new c.T(ee), this.setLight(t), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t, r = {}) {
          if (!this._validate(c.r, t, r)) for (const s in t) {
            const l = t[s];
            s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), l) : this._transitionable.setValue(s, l);
          }
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, r, s) {
          return (!s || s.validate !== !1) && c.t(this, t.call(c.u, { value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v }));
        }
      }
      const Se = new c.q({ "sky-color": new c.D(c.v.sky["sky-color"]), "horizon-color": new c.D(c.v.sky["horizon-color"]), "fog-color": new c.D(c.v.sky["fog-color"]), "fog-ground-blend": new c.D(c.v.sky["fog-ground-blend"]), "horizon-fog-blend": new c.D(c.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new c.D(c.v.sky["sky-horizon-blend"]), "atmosphere-blend": new c.D(c.v.sky["atmosphere-blend"]) });
      class K extends c.E {
        constructor(t) {
          super(), this._transitionable = new c.T(Se), this.setSky(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.z(0));
        }
        setSky(t, r = {}) {
          if (!this._validate(c.B, t, r)) {
            t || (t = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
            for (const s in t) {
              const l = t[s];
              s.endsWith("-transition") ? this._transitionable.setTransition(s.slice(0, -11), l) : this._transitionable.setValue(s, l);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, r, s = {}) {
          return (s == null ? void 0 : s.validate) !== !1 && c.t(this, t.call(c.u, c.e({ value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v })));
        }
        calculateFogBlendOpacity(t) {
          return t < 60 ? 0 : t < 70 ? (t - 60) / 10 : 1;
        }
      }
      class pt {
        constructor(t, r) {
          this.width = t, this.height = r, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(t, r) {
          const s = t.join(",") + String(r);
          return this.dashEntry[s] || (this.dashEntry[s] = this.addDash(t, r)), this.dashEntry[s];
        }
        getDashRanges(t, r, s) {
          const l = [];
          let h = t.length % 2 == 1 ? -t[t.length - 1] * s : 0, g = t[0] * s, _ = !0;
          l.push({ left: h, right: g, isDash: _, zeroLength: t[0] === 0 });
          let A = t[0];
          for (let L = 1; L < t.length; L++) {
            _ = !_;
            const E = t[L];
            h = A * s, A += E, g = A * s, l.push({ left: h, right: g, isDash: _, zeroLength: E === 0 });
          }
          return l;
        }
        addRoundDash(t, r, s) {
          const l = r / 2;
          for (let h = -s; h <= s; h++) {
            const g = this.width * (this.nextRow + s + h);
            let _ = 0, A = t[_];
            for (let L = 0; L < this.width; L++) {
              L / A.right > 1 && (A = t[++_]);
              const E = Math.abs(L - A.left), M = Math.abs(L - A.right), R = Math.min(E, M);
              let q;
              const B = h / s * (l + 1);
              if (A.isDash) {
                const $ = l - Math.abs(B);
                q = Math.sqrt(R * R + $ * $);
              } else q = l - Math.sqrt(R * R + B * B);
              this.data[g + L] = Math.max(0, Math.min(255, q + 128));
            }
          }
        }
        addRegularDash(t) {
          for (let _ = t.length - 1; _ >= 0; --_) {
            const A = t[_], L = t[_ + 1];
            A.zeroLength ? t.splice(_, 1) : L && L.isDash === A.isDash && (L.left = A.left, t.splice(_, 1));
          }
          const r = t[0], s = t[t.length - 1];
          r.isDash === s.isDash && (r.left = s.left - this.width, s.right = r.right + this.width);
          const l = this.width * this.nextRow;
          let h = 0, g = t[h];
          for (let _ = 0; _ < this.width; _++) {
            _ / g.right > 1 && (g = t[++h]);
            const A = Math.abs(_ - g.left), L = Math.abs(_ - g.right), E = Math.min(A, L);
            this.data[l + _] = Math.max(0, Math.min(255, (g.isDash ? E : -E) + 128));
          }
        }
        addDash(t, r) {
          const s = r ? 7 : 0, l = 2 * s + 1;
          if (this.nextRow + l > this.height) return c.w("LineAtlas out of space"), null;
          let h = 0;
          for (let _ = 0; _ < t.length; _++) h += t[_];
          if (h !== 0) {
            const _ = this.width / h, A = this.getDashRanges(t, this.width, _);
            r ? this.addRoundDash(A, _, s) : this.addRegularDash(A);
          }
          const g = { y: (this.nextRow + s + 0.5) / this.height, height: 2 * s / this.height, width: h };
          return this.nextRow += l, this.dirty = !0, g;
        }
        bind(t) {
          const r = t.gl;
          this.texture ? (r.bindTexture(r.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this.width, this.height, r.ALPHA, r.UNSIGNED_BYTE, this.data))) : (this.texture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this.texture), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.REPEAT), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texImage2D(r.TEXTURE_2D, 0, r.ALPHA, this.width, this.height, 0, r.ALPHA, r.UNSIGNED_BYTE, this.data));
        }
      }
      const xt = "maplibre_preloaded_worker_pool";
      class Tt {
        constructor() {
          this.active = {};
        }
        acquire(t) {
          if (!this.workers) for (this.workers = []; this.workers.length < Tt.workerCount; ) this.workers.push(new Worker(c.a.WORKER_URL));
          return this.active[t] = !0, this.workers.slice();
        }
        release(t) {
          delete this.active[t], this.numActive() === 0 && (this.workers.forEach((r) => {
            r.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[xt];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const Et = Math.floor(O.hardwareConcurrency / 2);
      let Rt, qt;
      function Gt() {
        return Rt || (Rt = new Tt()), Rt;
      }
      Tt.workerCount = c.C(globalThis) ? Math.max(Math.min(Et, 3), 1) : 1;
      class we {
        constructor(t, r) {
          this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = r;
          const s = this.workerPool.acquire(r);
          for (let l = 0; l < s.length; l++) {
            const h = new c.F(s[l], r);
            h.name = `Worker ${l}`, this.actors.push(h);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(t, r) {
          const s = [];
          for (const l of this.actors) s.push(l.sendAsync({ type: t, data: r }));
          return Promise.all(s);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(t = !0) {
          this.actors.forEach((r) => {
            r.remove();
          }), this.actors = [], t && this.workerPool.release(this.id);
        }
        registerMessageHandler(t, r) {
          for (const s of this.actors) s.registerMessageHandler(t, r);
        }
      }
      function be() {
        return qt || (qt = new we(Gt(), c.G), qt.registerMessageHandler("GR", (o, t, r) => c.m(t, r))), qt;
      }
      function Ie(o, t) {
        const r = c.H();
        return c.J(r, r, [1, 1, 0]), c.K(r, r, [0.5 * o.width, 0.5 * o.height, 1]), c.L(r, r, o.calculatePosMatrix(t.toUnwrapped()));
      }
      function Pe(o, t, r, s, l, h) {
        const g = function(M, R, q) {
          if (M) for (const B of M) {
            const $ = R[B];
            if ($ && $.source === q && $.type === "fill-extrusion") return !0;
          }
          else for (const B in R) {
            const $ = R[B];
            if ($.source === q && $.type === "fill-extrusion") return !0;
          }
          return !1;
        }(l && l.layers, t, o.id), _ = h.maxPitchScaleFactor(), A = o.tilesIn(s, _, g);
        A.sort(ti);
        const L = [];
        for (const M of A) L.push({ wrappedTileID: M.tileID.wrapped().key, queryResults: M.tile.queryRenderedFeatures(t, r, o._state, M.queryGeometry, M.cameraQueryGeometry, M.scale, l, h, _, Ie(o.transform, M.tileID)) });
        const E = function(M) {
          const R = {}, q = {};
          for (const B of M) {
            const $ = B.queryResults, Q = B.wrappedTileID, tt = q[Q] = q[Q] || {};
            for (const nt in $) {
              const it = $[nt], ht = tt[nt] = tt[nt] || {}, wt = R[nt] = R[nt] || [];
              for (const _t of it) ht[_t.featureIndex] || (ht[_t.featureIndex] = !0, wt.push(_t));
            }
          }
          return R;
        }(L);
        for (const M in E) E[M].forEach((R) => {
          const q = R.feature, B = o.getFeatureState(q.layer["source-layer"], q.id);
          q.source = q.layer.source, q.layer["source-layer"] && (q.sourceLayer = q.layer["source-layer"]), q.state = B;
        });
        return E;
      }
      function ti(o, t) {
        const r = o.tileID, s = t.tileID;
        return r.overscaledZ - s.overscaledZ || r.canonical.y - s.canonical.y || r.wrap - s.wrap || r.canonical.x - s.canonical.x;
      }
      function Qt(o, t, r) {
        return c._(this, void 0, void 0, function* () {
          let s = o;
          if (o.url ? s = (yield c.h(t.transformRequest(o.url, "Source"), r)).data : yield O.frameAsync(r), !s) return null;
          const l = c.M(c.e(s, o), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in s && s.vector_layers && (l.vectorLayerIds = s.vector_layers.map((h) => h.id)), l;
        });
      }
      class Y {
        constructor(t, r) {
          t && (r ? this.setSouthWest(t).setNorthEast(r) : Array.isArray(t) && (t.length === 4 ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1])));
        }
        setNorthEast(t) {
          return this._ne = t instanceof c.N ? new c.N(t.lng, t.lat) : c.N.convert(t), this;
        }
        setSouthWest(t) {
          return this._sw = t instanceof c.N ? new c.N(t.lng, t.lat) : c.N.convert(t), this;
        }
        extend(t) {
          const r = this._sw, s = this._ne;
          let l, h;
          if (t instanceof c.N) l = t, h = t;
          else {
            if (!(t instanceof Y)) return Array.isArray(t) ? t.length === 4 || t.every(Array.isArray) ? this.extend(Y.convert(t)) : this.extend(c.N.convert(t)) : t && ("lng" in t || "lon" in t) && "lat" in t ? this.extend(c.N.convert(t)) : this;
            if (l = t._sw, h = t._ne, !l || !h) return this;
          }
          return r || s ? (r.lng = Math.min(l.lng, r.lng), r.lat = Math.min(l.lat, r.lat), s.lng = Math.max(h.lng, s.lng), s.lat = Math.max(h.lat, s.lat)) : (this._sw = new c.N(l.lng, l.lat), this._ne = new c.N(h.lng, h.lat)), this;
        }
        getCenter() {
          return new c.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new c.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new c.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t) {
          const { lng: r, lat: s } = c.N.convert(t);
          let l = this._sw.lng <= r && r <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (l = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= s && s <= this._ne.lat && l;
        }
        static convert(t) {
          return t instanceof Y ? t : t && new Y(t);
        }
        static fromLngLat(t, r = 0) {
          const s = 360 * r / 40075017, l = s / Math.cos(Math.PI / 180 * t.lat);
          return new Y(new c.N(t.lng - l, t.lat - s), new c.N(t.lng + l, t.lat + s));
        }
        adjustAntiMeridian() {
          const t = new c.N(this._sw.lng, this._sw.lat), r = new c.N(this._ne.lng, this._ne.lat);
          return new Y(t, t.lng > r.lng ? new c.N(r.lng + 360, r.lat) : r);
        }
      }
      class ui {
        constructor(t, r, s) {
          this.bounds = Y.convert(this.validateBounds(t)), this.minzoom = r || 0, this.maxzoom = s || 24;
        }
        validateBounds(t) {
          return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
        }
        contains(t) {
          const r = Math.pow(2, t.z), s = Math.floor(c.O(this.bounds.getWest()) * r), l = Math.floor(c.Q(this.bounds.getNorth()) * r), h = Math.ceil(c.O(this.bounds.getEast()) * r), g = Math.ceil(c.Q(this.bounds.getSouth()) * r);
          return t.x >= s && t.x < h && t.y >= l && t.y < g;
        }
      }
      class Ge extends c.E {
        constructor(t, r, s, l) {
          if (super(), this.id = t, this.dispatcher = s, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, c.e(this, c.M(r, ["url", "scheme", "tileSize", "promoteId"])), this._options = c.e({ type: "vector" }, r), this._collectResourceTiming = r.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(l);
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new c.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const t = yield Qt(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), t && (c.e(this, t), t.bounds && (this.tileBounds = new ui(t.bounds, this.minzoom, this.maxzoom)), this.fire(new c.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t) {
              this._tileJSONRequest = null, this.fire(new c.j(t));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        setSourceProperty(t) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), t(), this.load();
        }
        setTiles(t) {
          return this.setSourceProperty(() => {
            this._options.tiles = t;
          }), this;
        }
        setUrl(t) {
          return this.setSourceProperty(() => {
            this.url = t, this._options.url = t;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return c.e({}, this._options);
        }
        loadTile(t) {
          return c._(this, void 0, void 0, function* () {
            const r = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s = { request: this.map._requestManager.transformRequest(r, "Tile"), uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            s.request.collectResourceTiming = this._collectResourceTiming;
            let l = "RT";
            if (t.actor && t.state !== "expired") {
              if (t.state === "loading") return new Promise((h, g) => {
                t.reloadPromise = { resolve: h, reject: g };
              });
            } else t.actor = this.dispatcher.getActor(), l = "LT";
            t.abortController = new AbortController();
            try {
              const h = yield t.actor.sendAsync({ type: l, data: s }, t.abortController);
              if (delete t.abortController, t.aborted) return;
              this._afterTileLoadWorkerResponse(t, h);
            } catch (h) {
              if (delete t.abortController, t.aborted) return;
              if (h && h.status !== 404) throw h;
              this._afterTileLoadWorkerResponse(t, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(t, r) {
          if (r && r.resourceTiming && (t.resourceTiming = r.resourceTiming), r && this.map._refreshExpiredTiles && t.setExpiryData(r), t.loadVectorData(r, this.map.painter), t.reloadPromise) {
            const s = t.reloadPromise;
            t.reloadPromise = null, this.loadTile(t).then(s.resolve).catch(s.reject);
          }
        }
        abortTile(t) {
          return c._(this, void 0, void 0, function* () {
            t.abortController && (t.abortController.abort(), delete t.abortController), t.actor && (yield t.actor.sendAsync({ type: "AT", data: { uid: t.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(t) {
          return c._(this, void 0, void 0, function* () {
            t.unloadVectorData(), t.actor && (yield t.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class se extends c.E {
        constructor(t, r, s, l) {
          super(), this.id = t, this.dispatcher = s, this.setEventedParent(l), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = c.e({ type: "raster" }, r), c.e(this, c.M(r, ["url", "scheme", "tileSize"]));
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new c.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const t = yield Qt(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, t && (c.e(this, t), t.bounds && (this.tileBounds = new ui(t.bounds, this.minzoom, this.maxzoom)), this.fire(new c.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t) {
              this._tileJSONRequest = null, this.fire(new c.j(t));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(t) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t(), this.load();
        }
        setTiles(t) {
          return this.setSourceProperty(() => {
            this._options.tiles = t;
          }), this;
        }
        setUrl(t) {
          return this.setSourceProperty(() => {
            this.url = t, this._options.url = t;
          }), this;
        }
        serialize() {
          return c.e({}, this._options);
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        loadTile(t) {
          return c._(this, void 0, void 0, function* () {
            const r = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            t.abortController = new AbortController();
            try {
              const s = yield zt.getImage(this.map._requestManager.transformRequest(r, "Tile"), t.abortController, this.map._refreshExpiredTiles);
              if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
              if (s && s.data) {
                this.map._refreshExpiredTiles && s.cacheControl && s.expires && t.setExpiryData({ cacheControl: s.cacheControl, expires: s.expires });
                const l = this.map.painter.context, h = l.gl, g = s.data;
                t.texture = this.map.painter.getTileTexture(g.width), t.texture ? t.texture.update(g, { useMipmap: !0 }) : (t.texture = new at(l, g, h.RGBA, { useMipmap: !0 }), t.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE, h.LINEAR_MIPMAP_NEAREST)), t.state = "loaded";
              }
            } catch (s) {
              if (delete t.abortController, t.aborted) t.state = "unloaded";
              else if (s) throw t.state = "errored", s;
            }
          });
        }
        abortTile(t) {
          return c._(this, void 0, void 0, function* () {
            t.abortController && (t.abortController.abort(), delete t.abortController);
          });
        }
        unloadTile(t) {
          return c._(this, void 0, void 0, function* () {
            t.texture && this.map.painter.saveTileTexture(t.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class _e extends se {
        constructor(t, r, s, l) {
          super(t, r, s, l), this.type = "raster-dem", this.maxzoom = 22, this._options = c.e({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox", this.redFactor = r.redFactor, this.greenFactor = r.greenFactor, this.blueFactor = r.blueFactor, this.baseShift = r.baseShift;
        }
        loadTile(t) {
          return c._(this, void 0, void 0, function* () {
            const r = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s = this.map._requestManager.transformRequest(r, "Tile");
            t.neighboringTiles = this._getNeighboringTiles(t.tileID), t.abortController = new AbortController();
            try {
              const l = yield zt.getImage(s, t.abortController, this.map._refreshExpiredTiles);
              if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
              if (l && l.data) {
                const h = l.data;
                this.map._refreshExpiredTiles && l.cacheControl && l.expires && t.setExpiryData({ cacheControl: l.cacheControl, expires: l.expires });
                const g = c.b(h) && c.U() ? h : yield this.readImageNow(h), _ = { type: this.type, uid: t.uid, source: this.id, rawImageData: g, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!t.actor || t.state === "expired") {
                  t.actor = this.dispatcher.getActor();
                  const A = yield t.actor.sendAsync({ type: "LDT", data: _ });
                  t.dem = A, t.needsHillshadePrepare = !0, t.needsTerrainPrepare = !0, t.state = "loaded";
                }
              }
            } catch (l) {
              if (delete t.abortController, t.aborted) t.state = "unloaded";
              else if (l) throw t.state = "errored", l;
            }
          });
        }
        readImageNow(t) {
          return c._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && c.V()) {
              const r = t.width + 2, s = t.height + 2;
              try {
                return new c.R({ width: r, height: s }, yield c.W(t, -1, -1, r, s));
              } catch {
              }
            }
            return O.getImageData(t, 1);
          });
        }
        _getNeighboringTiles(t) {
          const r = t.canonical, s = Math.pow(2, r.z), l = (r.x - 1 + s) % s, h = r.x === 0 ? t.wrap - 1 : t.wrap, g = (r.x + 1 + s) % s, _ = r.x + 1 === s ? t.wrap + 1 : t.wrap, A = {};
          return A[new c.S(t.overscaledZ, h, r.z, l, r.y).key] = { backfilled: !1 }, A[new c.S(t.overscaledZ, _, r.z, g, r.y).key] = { backfilled: !1 }, r.y > 0 && (A[new c.S(t.overscaledZ, h, r.z, l, r.y - 1).key] = { backfilled: !1 }, A[new c.S(t.overscaledZ, t.wrap, r.z, r.x, r.y - 1).key] = { backfilled: !1 }, A[new c.S(t.overscaledZ, _, r.z, g, r.y - 1).key] = { backfilled: !1 }), r.y + 1 < s && (A[new c.S(t.overscaledZ, h, r.z, l, r.y + 1).key] = { backfilled: !1 }, A[new c.S(t.overscaledZ, t.wrap, r.z, r.x, r.y + 1).key] = { backfilled: !1 }, A[new c.S(t.overscaledZ, _, r.z, g, r.y + 1).key] = { backfilled: !1 }), A;
        }
        unloadTile(t) {
          return c._(this, void 0, void 0, function* () {
            t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && (yield t.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t.uid, source: this.id } }));
          });
        }
      }
      class ze extends c.E {
        constructor(t, r, s, l) {
          super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = s.getActor(), this.setEventedParent(l), this._data = r.data, this._options = c.e({}, r), this._collectResourceTiming = r.collectResourceTiming, r.maxzoom !== void 0 && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId;
          const h = c.X / this.tileSize;
          r.clusterMaxZoom !== void 0 && this.maxzoom <= r.clusterMaxZoom && c.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${r.clusterMaxZoom}".`), this.workerOptions = c.e({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: (r.buffer !== void 0 ? r.buffer : 128) * h, tolerance: (r.tolerance !== void 0 ? r.tolerance : 0.375) * h, extent: c.X, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: r.clusterMaxZoom !== void 0 ? r.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, r.clusterMinPoints || 2), extent: c.X, radius: (r.clusterRadius || 50) * h, log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        setData(t) {
          return this._data = t, this._updateWorkerData(), this;
        }
        updateData(t) {
          return this._updateWorkerData(t), this;
        }
        getData() {
          return c._(this, void 0, void 0, function* () {
            const t = c.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: t });
          });
        }
        setClusterOptions(t) {
          return this.workerOptions.cluster = t.cluster, t && (t.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = t.clusterRadius), t.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = t.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(t) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t, source: this.id } });
        }
        getClusterChildren(t) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t, source: this.id } });
        }
        getClusterLeaves(t, r, s) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t, limit: r, offset: s } });
        }
        _updateWorkerData(t) {
          return c._(this, void 0, void 0, function* () {
            const r = c.e({ type: this.type }, this.workerOptions);
            t ? r.dataDiff = t : typeof this._data == "string" ? (r.request = this.map._requestManager.transformRequest(O.resolveURL(this._data), "Source"), r.request.collectResourceTiming = this._collectResourceTiming) : r.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new c.k("dataloading", { dataType: "source" }));
            try {
              const s = yield this.actor.sendAsync({ type: "LD", data: r });
              if (this._pendingLoads--, this._removed || s.abandoned) return void this.fire(new c.k("dataabort", { dataType: "source" }));
              let l = null;
              s.resourceTiming && s.resourceTiming[this.id] && (l = s.resourceTiming[this.id].slice(0));
              const h = { dataType: "source" };
              this._collectResourceTiming && l && l.length > 0 && c.e(h, { resourceTiming: l }), this.fire(new c.k("data", Object.assign(Object.assign({}, h), { sourceDataType: "metadata" }))), this.fire(new c.k("data", Object.assign(Object.assign({}, h), { sourceDataType: "content" })));
            } catch (s) {
              if (this._pendingLoads--, this._removed) return void this.fire(new c.k("dataabort", { dataType: "source" }));
              this.fire(new c.j(s));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(t) {
          return c._(this, void 0, void 0, function* () {
            const r = t.actor ? "RT" : "LT";
            t.actor = this.actor;
            const s = { type: this.type, uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            t.abortController = new AbortController();
            const l = yield this.actor.sendAsync({ type: r, data: s }, t.abortController);
            delete t.abortController, t.unloadVectorData(), t.aborted || t.loadVectorData(l, this.map.painter, r === "RT");
          });
        }
        abortTile(t) {
          return c._(this, void 0, void 0, function* () {
            t.abortController && (t.abortController.abort(), delete t.abortController), t.aborted = !0;
          });
        }
        unloadTile(t) {
          return c._(this, void 0, void 0, function* () {
            t.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return c.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      var ke = c.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class Ze extends c.E {
        constructor(t, r, s, l) {
          super(), this.id = t, this.dispatcher = s, this.coordinates = r.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(l), this.options = r;
        }
        load(t) {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new c.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const r = yield zt.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, r && r.data && (this.image = r.data, t && (this.coordinates = t), this._finishLoading());
            } catch (r) {
              this._request = null, this._loaded = !0, this.fire(new c.j(r));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t) {
          return t.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t.url, this.load(t.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new c.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(t) {
          this.coordinates = t;
          const r = t.map(c.Z.fromLngLat);
          this.tileID = function(l) {
            let h = 1 / 0, g = 1 / 0, _ = -1 / 0, A = -1 / 0;
            for (const R of l) h = Math.min(h, R.x), g = Math.min(g, R.y), _ = Math.max(_, R.x), A = Math.max(A, R.y);
            const L = Math.max(_ - h, A - g), E = Math.max(0, Math.floor(-Math.log(L) / Math.LN2)), M = Math.pow(2, E);
            return new c.a1(E, Math.floor((h + _) / 2 * M), Math.floor((g + A) / 2 * M));
          }(r), this.minzoom = this.maxzoom = this.tileID.z;
          const s = r.map((l) => this.tileID.getTilePoint(l)._round());
          return this._boundsArray = new c.$(), this._boundsArray.emplaceBack(s[0].x, s[0].y, 0, 0), this._boundsArray.emplaceBack(s[1].x, s[1].y, c.X, 0), this._boundsArray.emplaceBack(s[3].x, s[3].y, 0, c.X), this._boundsArray.emplaceBack(s[2].x, s[2].y, c.X, c.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new c.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const t = this.map.painter.context, r = t.gl;
          this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, ke.members)), this.boundsSegments || (this.boundsSegments = c.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new at(t, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
          let s = !1;
          for (const l in this.tiles) {
            const h = this.tiles[l];
            h.state !== "loaded" && (h.state = "loaded", h.texture = this.texture, s = !0);
          }
          s && this.fire(new c.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(t) {
          return c._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}) : t.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class di extends Ze {
        constructor(t, r, s, l) {
          super(t, r, s, l), this.roundZoom = !0, this.type = "video", this.options = r;
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const t = this.options;
            this.urls = [];
            for (const r of t.urls) this.urls.push(this.map._requestManager.transformRequest(r, "Source").url);
            try {
              const r = yield c.a3(this.urls);
              if (this._loaded = !0, !r) return;
              this.video = r, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (r) {
              this.fire(new c.j(r));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t) {
          if (this.video) {
            const r = this.video.seekable;
            t < r.start(0) || t > r.end(0) ? this.fire(new c.j(new c.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = t;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(t) {
          this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const t = this.map.painter.context, r = t.gl;
          this.boundsBuffer || (this.boundsBuffer = t.createVertexBuffer(this._boundsArray, ke.members)), this.boundsSegments || (this.boundsSegments = c.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new at(t, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE));
          let s = !1;
          for (const l in this.tiles) {
            const h = this.tiles[l];
            h.state !== "loaded" && (h.state = "loaded", h.texture = this.texture, s = !0);
          }
          s && this.fire(new c.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class ai extends Ze {
        constructor(t, r, s, l) {
          super(t, r, s, l), r.coordinates ? Array.isArray(r.coordinates) && r.coordinates.length === 4 && !r.coordinates.some((h) => !Array.isArray(h) || h.length !== 2 || h.some((g) => typeof g != "number")) || this.fire(new c.j(new c.a2(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new c.j(new c.a2(`sources.${t}`, null, 'missing required property "coordinates"'))), r.animate && typeof r.animate != "boolean" && this.fire(new c.j(new c.a2(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? typeof r.canvas == "string" || r.canvas instanceof HTMLCanvasElement || this.fire(new c.j(new c.a2(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new c.j(new c.a2(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = r.animate === void 0 || r.animate;
        }
        load() {
          return c._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new c.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(t) {
          this.map = t, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const r = this.map.painter.context, s = r.gl;
          this.boundsBuffer || (this.boundsBuffer = r.createVertexBuffer(this._boundsArray, ke.members)), this.boundsSegments || (this.boundsSegments = c.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (t || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new at(r, this.canvas, s.RGBA, { premultiply: !0 });
          let l = !1;
          for (const h in this.tiles) {
            const g = this.tiles[h];
            g.state !== "loaded" && (g.state = "loaded", g.texture = this.texture, l = !0);
          }
          l && this.fire(new c.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const t of [this.canvas.width, this.canvas.height]) if (isNaN(t) || t <= 0) return !0;
          return !1;
        }
      }
      const wi = {}, Ei = (o) => {
        switch (o) {
          case "geojson":
            return ze;
          case "image":
            return Ze;
          case "raster":
            return se;
          case "raster-dem":
            return _e;
          case "vector":
            return Ge;
          case "video":
            return di;
          case "canvas":
            return ai;
        }
        return wi[o];
      }, oe = "RTLPluginLoaded";
      class ei extends c.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = be();
        }
        _syncState(t) {
          return this.status = t, this.dispatcher.broadcast("SRPS", { pluginStatus: t, pluginURL: this.url }).catch((r) => {
            throw this.status = "error", r;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(t) {
          return c._(this, arguments, void 0, function* (r, s = !1) {
            if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = O.resolveURL(r), !this.url) throw new Error(`requested url ${r} is invalid`);
            if (this.status === "unavailable") {
              if (!s) return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested") return this._requestImport();
          });
        }
        _requestImport() {
          return c._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new c.k(oe));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let oi = null;
      function Te() {
        return oi || (oi = new ei()), oi;
      }
      class cr {
        constructor(t, r) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = t, this.uid = c.a4(), this.uses = 0, this.tileSize = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(t) {
          const r = t + this.timeAdded;
          r < this.fadeEndTime || (this.fadeEndTime = r);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(t) {
          this.demTexture && t.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(t, r, s) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) {
            t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function(l, h) {
              const g = {};
              if (!h) return g;
              for (const _ of l) {
                const A = _.layerIds.map((L) => h.getLayer(L)).filter(Boolean);
                if (A.length !== 0) {
                  _.layers = A, _.stateDependentLayerIds && (_.stateDependentLayers = _.stateDependentLayerIds.map((L) => A.filter((E) => E.id === L)[0]));
                  for (const L of A) g[L.id] = _;
                }
              }
              return g;
            }(t.buckets, r.style), this.hasSymbolBuckets = !1;
            for (const l in this.buckets) {
              const h = this.buckets[l];
              if (h instanceof c.a6) {
                if (this.hasSymbolBuckets = !0, !s) break;
                h.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const l in this.buckets) {
              const h = this.buckets[l];
              if (h instanceof c.a6 && h.hasRTLText) {
                this.hasRTLText = !0, Te().lazyLoad();
                break;
              }
            }
            this.queryPadding = 0;
            for (const l in this.buckets) {
              const h = this.buckets[l];
              this.queryPadding = Math.max(this.queryPadding, r.style.getLayer(l).queryRadius(h));
            }
            t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage);
          } else this.collisionBoxArray = new c.a5();
        }
        unloadVectorData() {
          for (const t in this.buckets) this.buckets[t].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(t) {
          return this.buckets[t.id];
        }
        upload(t) {
          for (const s in this.buckets) {
            const l = this.buckets[s];
            l.uploadPending() && l.upload(t);
          }
          const r = t.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new at(t, this.imageAtlas.image, r.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new at(t, this.glyphAtlasImage, r.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(t) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t, r, s, l, h, g, _, A, L, E) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: l, cameraQueryGeometry: h, scale: g, tileSize: this.tileSize, pixelPosMatrix: E, transform: A, params: _, queryPadding: this.queryPadding * L }, t, r, s) : {};
        }
        querySourceFeatures(t, r) {
          const s = this.latestFeatureIndex;
          if (!s || !s.rawTileData) return;
          const l = s.loadVTLayers(), h = r && r.sourceLayer ? r.sourceLayer : "", g = l._geojsonTileLayer || l[h];
          if (!g) return;
          const _ = c.a7(r && r.filter), { z: A, x: L, y: E } = this.tileID.canonical, M = { z: A, x: L, y: E };
          for (let R = 0; R < g.length; R++) {
            const q = g.feature(R);
            if (_.needGeometry) {
              const Q = c.a8(q, !0);
              if (!_.filter(new c.z(this.tileID.overscaledZ), Q, this.tileID.canonical)) continue;
            } else if (!_.filter(new c.z(this.tileID.overscaledZ), q)) continue;
            const B = s.getId(q, h), $ = new c.a9(q, A, L, E, B);
            $.tile = M, t.push($);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t) {
          const r = this.expirationTime;
          if (t.cacheControl) {
            const s = c.aa(t.cacheControl);
            s["max-age"] && (this.expirationTime = Date.now() + 1e3 * s["max-age"]);
          } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
          if (this.expirationTime) {
            const s = Date.now();
            let l = !1;
            if (this.expirationTime > s) l = !1;
            else if (r) if (this.expirationTime < r) l = !0;
            else {
              const h = this.expirationTime - r;
              h ? this.expirationTime = s + Math.max(h, 3e4) : l = !0;
            }
            else l = !0;
            l ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t, r) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t).length === 0) return;
          const s = this.latestFeatureIndex.loadVTLayers();
          for (const l in this.buckets) {
            if (!r.style.hasLayer(l)) continue;
            const h = this.buckets[l], g = h.layers[0].sourceLayer || "_geojsonTileLayer", _ = s[g], A = t[g];
            if (!_ || !A || Object.keys(A).length === 0) continue;
            h.update(A, _, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const L = r && r.style && r.style.getLayer(l);
            L && (this.queryPadding = Math.max(this.queryPadding, L.queryRadius(h)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < O.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t) {
          this.symbolFadeHoldUntil = O.now() + t;
        }
        setDependencies(t, r) {
          const s = {};
          for (const l of r) s[l] = !0;
          this.dependencies[t] = s;
        }
        hasDependency(t, r) {
          for (const s of t) {
            const l = this.dependencies[s];
            if (l) {
              for (const h of r) if (l[h]) return !0;
            }
          }
          return !1;
        }
      }
      class le {
        constructor(t, r) {
          this.max = t, this.onRemove = r, this.reset();
        }
        reset() {
          for (const t in this.data) for (const r of this.data[t]) r.timeout && clearTimeout(r.timeout), this.onRemove(r.value);
          return this.data = {}, this.order = [], this;
        }
        add(t, r, s) {
          const l = t.wrapped().key;
          this.data[l] === void 0 && (this.data[l] = []);
          const h = { value: r, timeout: void 0 };
          if (s !== void 0 && (h.timeout = setTimeout(() => {
            this.remove(t, h);
          }, s)), this.data[l].push(h), this.order.push(l), this.order.length > this.max) {
            const g = this._getAndRemoveByKey(this.order[0]);
            g && this.onRemove(g);
          }
          return this;
        }
        has(t) {
          return t.wrapped().key in this.data;
        }
        getAndRemove(t) {
          return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
        }
        _getAndRemoveByKey(t) {
          const r = this.data[t].shift();
          return r.timeout && clearTimeout(r.timeout), this.data[t].length === 0 && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), r.value;
        }
        getByKey(t) {
          const r = this.data[t];
          return r ? r[0].value : null;
        }
        get(t) {
          return this.has(t) ? this.data[t.wrapped().key][0].value : null;
        }
        remove(t, r) {
          if (!this.has(t)) return this;
          const s = t.wrapped().key, l = r === void 0 ? 0 : this.data[s].indexOf(r), h = this.data[s][l];
          return this.data[s].splice(l, 1), h.timeout && clearTimeout(h.timeout), this.data[s].length === 0 && delete this.data[s], this.onRemove(h.value), this.order.splice(this.order.indexOf(s), 1), this;
        }
        setMaxSize(t) {
          for (this.max = t; this.order.length > this.max; ) {
            const r = this._getAndRemoveByKey(this.order[0]);
            r && this.onRemove(r);
          }
          return this;
        }
        filter(t) {
          const r = [];
          for (const s in this.data) for (const l of this.data[s]) t(l.value) || r.push(l);
          for (const s of r) this.remove(s.value.tileID, s);
        }
      }
      class si {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t, r, s) {
          const l = String(r);
          if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][l] = this.stateChanges[t][l] || {}, c.e(this.stateChanges[t][l], s), this.deletedStates[t] === null) {
            this.deletedStates[t] = {};
            for (const h in this.state[t]) h !== l && (this.deletedStates[t][h] = null);
          } else if (this.deletedStates[t] && this.deletedStates[t][l] === null) {
            this.deletedStates[t][l] = {};
            for (const h in this.state[t][l]) s[h] || (this.deletedStates[t][l][h] = null);
          } else for (const h in s) this.deletedStates[t] && this.deletedStates[t][l] && this.deletedStates[t][l][h] === null && delete this.deletedStates[t][l][h];
        }
        removeFeatureState(t, r, s) {
          if (this.deletedStates[t] === null) return;
          const l = String(r);
          if (this.deletedStates[t] = this.deletedStates[t] || {}, s && r !== void 0) this.deletedStates[t][l] !== null && (this.deletedStates[t][l] = this.deletedStates[t][l] || {}, this.deletedStates[t][l][s] = null);
          else if (r !== void 0) if (this.stateChanges[t] && this.stateChanges[t][l]) for (s in this.deletedStates[t][l] = {}, this.stateChanges[t][l]) this.deletedStates[t][l][s] = null;
          else this.deletedStates[t][l] = null;
          else this.deletedStates[t] = null;
        }
        getState(t, r) {
          const s = String(r), l = c.e({}, (this.state[t] || {})[s], (this.stateChanges[t] || {})[s]);
          if (this.deletedStates[t] === null) return {};
          if (this.deletedStates[t]) {
            const h = this.deletedStates[t][r];
            if (h === null) return {};
            for (const g in h) delete l[g];
          }
          return l;
        }
        initializeTileState(t, r) {
          t.setFeatureState(this.state, r);
        }
        coalesceChanges(t, r) {
          const s = {};
          for (const l in this.stateChanges) {
            this.state[l] = this.state[l] || {};
            const h = {};
            for (const g in this.stateChanges[l]) this.state[l][g] || (this.state[l][g] = {}), c.e(this.state[l][g], this.stateChanges[l][g]), h[g] = this.state[l][g];
            s[l] = h;
          }
          for (const l in this.deletedStates) {
            this.state[l] = this.state[l] || {};
            const h = {};
            if (this.deletedStates[l] === null) for (const g in this.state[l]) h[g] = {}, this.state[l][g] = {};
            else for (const g in this.deletedStates[l]) {
              if (this.deletedStates[l][g] === null) this.state[l][g] = {};
              else for (const _ of Object.keys(this.deletedStates[l][g])) delete this.state[l][g][_];
              h[g] = this.state[l][g];
            }
            s[l] = s[l] || {}, c.e(s[l], h);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(s).length !== 0) for (const l in t) t[l].setFeatureState(s, r);
        }
      }
      class Ce extends c.E {
        constructor(t, r, s) {
          super(), this.id = t, this.dispatcher = s, this.on("data", (l) => this._dataHandler(l)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((l, h, g, _) => {
            const A = new (Ei(h.type))(l, h, g, _);
            if (A.id !== l) throw new Error(`Expected Source id to be ${l} instead of ${A.id}`);
            return A;
          })(t, r, s, this), this._tiles = {}, this._cache = new le(0, (l) => this._unloadTile(l)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new si(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(t) {
          this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t ? t._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t);
        }
        onRemove(t) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
          if (!this._updated) return !1;
          for (const t in this._tiles) {
            const r = this._tiles[t];
            if (r.state !== "loaded" && r.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const t = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(t, r, s) {
          return c._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(t), this._tileLoaded(t, r, s);
            } catch (l) {
              t.state = "errored", l.status !== 404 ? this._source.fire(new c.j(l, { tile: t })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(t) {
          this._source.unloadTile && this._source.unloadTile(t);
        }
        _abortTile(t) {
          this._source.abortTile && this._source.abortTile(t), this._source.fire(new c.k("dataabort", { tile: t, coord: t.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const r in this._tiles) {
            const s = this._tiles[r];
            s.upload(t), s.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((t) => t.tileID).sort(zi).map((t) => t.key);
        }
        getRenderableIds(t) {
          const r = [];
          for (const s in this._tiles) this._isIdRenderable(s, t) && r.push(this._tiles[s]);
          return t ? r.sort((s, l) => {
            const h = s.tileID, g = l.tileID, _ = new c.P(h.canonical.x, h.canonical.y)._rotate(this.transform.angle), A = new c.P(g.canonical.x, g.canonical.y)._rotate(this.transform.angle);
            return h.overscaledZ - g.overscaledZ || A.y - _.y || A.x - _.x;
          }).map((s) => s.tileID.key) : r.map((s) => s.tileID).sort(zi).map((s) => s.key);
        }
        hasRenderableParent(t) {
          const r = this.findLoadedParent(t, 0);
          return !!r && this._isIdRenderable(r.tileID.key);
        }
        _isIdRenderable(t, r) {
          return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (r || !this._tiles[t].holdingForFade());
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const t in this._tiles) this._tiles[t].state !== "errored" && this._reloadTile(t, "reloading");
          }
        }
        _reloadTile(t, r) {
          return c._(this, void 0, void 0, function* () {
            const s = this._tiles[t];
            s && (s.state !== "loading" && (s.state = r), yield this._loadTile(s, t, r));
          });
        }
        _tileLoaded(t, r, s) {
          t.timeAdded = O.now(), s === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(r, t), this.getSource().type === "raster-dem" && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), t.aborted || this._source.fire(new c.k("data", { dataType: "source", tile: t, coord: t.tileID }));
        }
        _backfillDEM(t) {
          const r = this.getRenderableIds();
          for (let l = 0; l < r.length; l++) {
            const h = r[l];
            if (t.neighboringTiles && t.neighboringTiles[h]) {
              const g = this.getTileByID(h);
              s(t, g), s(g, t);
            }
          }
          function s(l, h) {
            l.needsHillshadePrepare = !0, l.needsTerrainPrepare = !0;
            let g = h.tileID.canonical.x - l.tileID.canonical.x;
            const _ = h.tileID.canonical.y - l.tileID.canonical.y, A = Math.pow(2, l.tileID.canonical.z), L = h.tileID.key;
            g === 0 && _ === 0 || Math.abs(_) > 1 || (Math.abs(g) > 1 && (Math.abs(g + A) === 1 ? g += A : Math.abs(g - A) === 1 && (g -= A)), h.dem && l.dem && (l.dem.backfillBorder(h.dem, g, _), l.neighboringTiles && l.neighboringTiles[L] && (l.neighboringTiles[L].backfilled = !0)));
          }
        }
        getTile(t) {
          return this.getTileByID(t.key);
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        _retainLoadedChildren(t, r, s, l) {
          for (const h in this._tiles) {
            let g = this._tiles[h];
            if (l[h] || !g.hasData() || g.tileID.overscaledZ <= r || g.tileID.overscaledZ > s) continue;
            let _ = g.tileID;
            for (; g && g.tileID.overscaledZ > r + 1; ) {
              const L = g.tileID.scaledTo(g.tileID.overscaledZ - 1);
              g = this._tiles[L.key], g && g.hasData() && (_ = L);
            }
            let A = _;
            for (; A.overscaledZ > r; ) if (A = A.scaledTo(A.overscaledZ - 1), t[A.key]) {
              l[_.key] = _;
              break;
            }
          }
        }
        findLoadedParent(t, r) {
          if (t.key in this._loadedParentTiles) {
            const s = this._loadedParentTiles[t.key];
            return s && s.tileID.overscaledZ >= r ? s : null;
          }
          for (let s = t.overscaledZ - 1; s >= r; s--) {
            const l = t.scaledTo(s), h = this._getLoadedTile(l);
            if (h) return h;
          }
        }
        findLoadedSibling(t) {
          return this._getLoadedTile(t);
        }
        _getLoadedTile(t) {
          const r = this._tiles[t.key];
          return r && r.hasData() ? r : this._cache.getByKey(t.wrapped().key);
        }
        updateCacheSize(t) {
          const r = Math.ceil(t.width / this._source.tileSize) + 1, s = Math.ceil(t.height / this._source.tileSize) + 1, l = Math.floor(r * s * (this._maxTileCacheZoomLevels === null ? c.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), h = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, l) : l;
          this._cache.setMaxSize(h);
        }
        handleWrapJump(t) {
          const r = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
          if (this._prevLng = t, r) {
            const s = {};
            for (const l in this._tiles) {
              const h = this._tiles[l];
              h.tileID = h.tileID.unwrapTo(h.tileID.wrap + r), s[h.tileID.key] = h;
            }
            this._tiles = s;
            for (const l in this._timers) clearTimeout(this._timers[l]), delete this._timers[l];
            for (const l in this._tiles) this._setTileReloadTimer(l, this._tiles[l]);
          }
        }
        _updateCoveredAndRetainedTiles(t, r, s, l, h, g) {
          const _ = {}, A = {}, L = Object.keys(t), E = O.now();
          for (const M of L) {
            const R = t[M], q = this._tiles[M];
            if (!q || q.fadeEndTime !== 0 && q.fadeEndTime <= E) continue;
            const B = this.findLoadedParent(R, r), $ = this.findLoadedSibling(R), Q = B || $ || null;
            Q && (this._addTile(Q.tileID), _[Q.tileID.key] = Q.tileID), A[M] = R;
          }
          this._retainLoadedChildren(A, l, s, t);
          for (const M in _) t[M] || (this._coveredTiles[M] = !0, t[M] = _[M]);
          if (g) {
            const M = {}, R = {};
            for (const q of h) this._tiles[q.key].hasData() ? M[q.key] = q : R[q.key] = q;
            for (const q in R) {
              const B = R[q].children(this._source.maxzoom);
              this._tiles[B[0].key] && this._tiles[B[1].key] && this._tiles[B[2].key] && this._tiles[B[3].key] && (M[B[0].key] = t[B[0].key] = B[0], M[B[1].key] = t[B[1].key] = B[1], M[B[2].key] = t[B[2].key] = B[2], M[B[3].key] = t[B[3].key] = B[3], delete R[q]);
            }
            for (const q in R) {
              const B = R[q], $ = this.findLoadedParent(B, this._source.minzoom), Q = this.findLoadedSibling(B), tt = $ || Q || null;
              if (tt) {
                M[tt.tileID.key] = t[tt.tileID.key] = tt.tileID;
                for (const nt in M) M[nt].isChildOf(tt.tileID) && delete M[nt];
              }
            }
            for (const q in this._tiles) M[q] || (this._coveredTiles[q] = !0);
          }
        }
        update(t, r) {
          if (!this._sourceLoaded || this._paused) return;
          let s;
          this.transform = t, this.terrain = r, this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((E) => new c.S(E.canonical.z, E.wrap, E.canonical.z, E.canonical.x, E.canonical.y)) : (s = t.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: r }), this._source.hasTile && (s = s.filter((E) => this._source.hasTile(E)))) : s = [];
          const l = t.coveringZoomLevel(this._source), h = Math.max(l - Ce.maxOverzooming, this._source.minzoom), g = Math.max(l + Ce.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const E = {};
            for (const M of s) if (M.canonical.z > this._source.minzoom) {
              const R = M.scaledTo(M.canonical.z - 1);
              E[R.key] = R;
              const q = M.scaledTo(Math.max(this._source.minzoom, Math.min(M.canonical.z, 5)));
              E[q.key] = q;
            }
            s = s.concat(Object.values(E));
          }
          const _ = s.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, _ && this.fire(new c.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const A = this._updateRetainedTiles(s, l);
          Sr(this._source.type) && this._updateCoveredAndRetainedTiles(A, h, g, l, s, r);
          for (const E in A) this._tiles[E].clearFadeHold();
          const L = c.ab(this._tiles, A);
          for (const E of L) {
            const M = this._tiles[E];
            M.hasSymbolBuckets && !M.holdingForFade() ? M.setHoldDuration(this.map._fadeDuration) : M.hasSymbolBuckets && !M.symbolFadeFinished() || this._removeTile(E);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(t);
        }
        _updateRetainedTiles(t, r) {
          var s;
          const l = {}, h = {}, g = Math.max(r - Ce.maxOverzooming, this._source.minzoom), _ = Math.max(r + Ce.maxUnderzooming, this._source.minzoom), A = {};
          for (const L of t) {
            const E = this._addTile(L);
            l[L.key] = L, E.hasData() || r < this._source.maxzoom && (A[L.key] = L);
          }
          this._retainLoadedChildren(A, r, _, l);
          for (const L of t) {
            let E = this._tiles[L.key];
            if (E.hasData()) continue;
            if (r + 1 > this._source.maxzoom) {
              const R = L.children(this._source.maxzoom)[0], q = this.getTile(R);
              if (q && q.hasData()) {
                l[R.key] = R;
                continue;
              }
            } else {
              const R = L.children(this._source.maxzoom);
              if (l[R[0].key] && l[R[1].key] && l[R[2].key] && l[R[3].key]) continue;
            }
            let M = E.wasRequested();
            for (let R = L.overscaledZ - 1; R >= g; --R) {
              const q = L.scaledTo(R);
              if (h[q.key]) break;
              if (h[q.key] = !0, E = this.getTile(q), !E && M && (E = this._addTile(q)), E) {
                const B = E.hasData();
                if ((B || !(!((s = this.map) === null || s === void 0) && s.cancelPendingTileRequestsWhileZooming) || M) && (l[q.key] = q), M = E.wasRequested(), B) break;
              }
            }
          }
          return l;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t in this._tiles) {
            const r = [];
            let s, l = this._tiles[t].tileID;
            for (; l.overscaledZ > 0; ) {
              if (l.key in this._loadedParentTiles) {
                s = this._loadedParentTiles[l.key];
                break;
              }
              r.push(l.key);
              const h = l.scaledTo(l.overscaledZ - 1);
              if (s = this._getLoadedTile(h), s) break;
              l = h;
            }
            for (const h of r) this._loadedParentTiles[h] = s;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const t in this._tiles) {
            const r = this._tiles[t].tileID, s = this._getLoadedTile(r);
            this._loadedSiblingTiles[r.key] = s;
          }
        }
        _addTile(t) {
          let r = this._tiles[t.key];
          if (r) return r;
          r = this._cache.getAndRemove(t), r && (this._setTileReloadTimer(t.key, r), r.tileID = t, this._state.initializeTileState(r, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, r)));
          const s = r;
          return r || (r = new cr(t, this._source.tileSize * t.overscaleFactor()), this._loadTile(r, t.key, r.state)), r.uses++, this._tiles[t.key] = r, s || this._source.fire(new c.k("dataloading", { tile: r, coord: r.tileID, dataType: "source" })), r;
        }
        _setTileReloadTimer(t, r) {
          t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
          const s = r.getExpiryTimeout();
          s && (this._timers[t] = setTimeout(() => {
            this._reloadTile(t, "expired"), delete this._timers[t];
          }, s));
        }
        _removeTile(t) {
          const r = this._tiles[t];
          r && (r.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), r.uses > 0 || (r.hasData() && r.state !== "reloading" ? this._cache.add(r.tileID, r, r.getExpiryTimeout()) : (r.aborted = !0, this._abortTile(r), this._unloadTile(r))));
        }
        _dataHandler(t) {
          const r = t.sourceDataType;
          t.dataType === "source" && r === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && t.dataType === "source" && r === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const t in this._tiles) this._removeTile(t);
          this._cache.reset();
        }
        tilesIn(t, r, s) {
          const l = [], h = this.transform;
          if (!h) return l;
          const g = s ? h.getCameraQueryGeometry(t) : t, _ = t.map((B) => h.pointCoordinate(B, this.terrain)), A = g.map((B) => h.pointCoordinate(B, this.terrain)), L = this.getIds();
          let E = 1 / 0, M = 1 / 0, R = -1 / 0, q = -1 / 0;
          for (const B of A) E = Math.min(E, B.x), M = Math.min(M, B.y), R = Math.max(R, B.x), q = Math.max(q, B.y);
          for (let B = 0; B < L.length; B++) {
            const $ = this._tiles[L[B]];
            if ($.holdingForFade()) continue;
            const Q = $.tileID, tt = Math.pow(2, h.zoom - $.tileID.overscaledZ), nt = r * $.queryPadding * c.X / $.tileSize / tt, it = [Q.getTilePoint(new c.Z(E, M)), Q.getTilePoint(new c.Z(R, q))];
            if (it[0].x - nt < c.X && it[0].y - nt < c.X && it[1].x + nt >= 0 && it[1].y + nt >= 0) {
              const ht = _.map((_t) => Q.getTilePoint(_t)), wt = A.map((_t) => Q.getTilePoint(_t));
              l.push({ tile: $, tileID: Q, queryGeometry: ht, cameraQueryGeometry: wt, scale: tt });
            }
          }
          return l;
        }
        getVisibleCoordinates(t) {
          const r = this.getRenderableIds(t).map((s) => this._tiles[s].tileID);
          for (const s of r) s.posMatrix = this.transform.calculatePosMatrix(s.toUnwrapped());
          return r;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Sr(this._source.type)) {
            const t = O.now();
            for (const r in this._tiles) if (this._tiles[r].fadeEndTime >= t) return !0;
          }
          return !1;
        }
        setFeatureState(t, r, s) {
          this._state.updateState(t = t || "_geojsonTileLayer", r, s);
        }
        removeFeatureState(t, r, s) {
          this._state.removeFeatureState(t = t || "_geojsonTileLayer", r, s);
        }
        getFeatureState(t, r) {
          return this._state.getState(t = t || "_geojsonTileLayer", r);
        }
        setDependencies(t, r, s) {
          const l = this._tiles[t];
          l && l.setDependencies(r, s);
        }
        reloadTilesForDependencies(t, r) {
          for (const s in this._tiles) this._tiles[s].hasDependency(t, r) && this._reloadTile(s, "reloading");
          this._cache.filter((s) => !s.hasDependency(t, r));
        }
      }
      function zi(o, t) {
        const r = Math.abs(2 * o.wrap) - +(o.wrap < 0), s = Math.abs(2 * t.wrap) - +(t.wrap < 0);
        return o.overscaledZ - t.overscaledZ || s - r || t.canonical.y - o.canonical.y || t.canonical.x - o.canonical.x;
      }
      function Sr(o) {
        return o === "raster" || o === "image" || o === "video";
      }
      Ce.maxOverzooming = 10, Ce.maxUnderzooming = 3;
      class Ee {
        constructor(t, r) {
          this.reset(t, r);
        }
        reset(t, r) {
          this.points = t || [], this._distances = [0];
          for (let s = 1; s < this.points.length; s++) this._distances[s] = this._distances[s - 1] + this.points[s].dist(this.points[s - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(r || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t) {
          if (this.points.length === 1) return this.points[0];
          t = c.ac(t, 0, 1);
          let r = 1, s = this._distances[r];
          const l = t * this.paddedLength + this.padding;
          for (; s < l && r < this._distances.length; ) s = this._distances[++r];
          const h = r - 1, g = this._distances[h], _ = s - g, A = _ > 0 ? (l - g) / _ : 0;
          return this.points[h].mult(1 - A).add(this.points[r].mult(A));
        }
      }
      function Xr(o, t) {
        let r = !0;
        return o === "always" || o !== "never" && t !== "never" || (r = !1), r;
      }
      class Vi {
        constructor(t, r, s) {
          const l = this.boxCells = [], h = this.circleCells = [];
          this.xCellCount = Math.ceil(t / s), this.yCellCount = Math.ceil(r / s);
          for (let g = 0; g < this.xCellCount * this.yCellCount; g++) l.push([]), h.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = r, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / r, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t, r, s, l, h) {
          this._forEachCell(r, s, l, h, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(r), this.bboxes.push(s), this.bboxes.push(l), this.bboxes.push(h);
        }
        insertCircle(t, r, s, l) {
          this._forEachCell(r - l, s - l, r + l, s + l, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(r), this.circles.push(s), this.circles.push(l);
        }
        _insertBoxCell(t, r, s, l, h, g) {
          this.boxCells[h].push(g);
        }
        _insertCircleCell(t, r, s, l, h, g) {
          this.circleCells[h].push(g);
        }
        _query(t, r, s, l, h, g, _) {
          if (s < 0 || t > this.width || l < 0 || r > this.height) return [];
          const A = [];
          if (t <= 0 && r <= 0 && this.width <= s && this.height <= l) {
            if (h) return [{ key: null, x1: t, y1: r, x2: s, y2: l }];
            for (let L = 0; L < this.boxKeys.length; L++) A.push({ key: this.boxKeys[L], x1: this.bboxes[4 * L], y1: this.bboxes[4 * L + 1], x2: this.bboxes[4 * L + 2], y2: this.bboxes[4 * L + 3] });
            for (let L = 0; L < this.circleKeys.length; L++) {
              const E = this.circles[3 * L], M = this.circles[3 * L + 1], R = this.circles[3 * L + 2];
              A.push({ key: this.circleKeys[L], x1: E - R, y1: M - R, x2: E + R, y2: M + R });
            }
          } else this._forEachCell(t, r, s, l, this._queryCell, A, { hitTest: h, overlapMode: g, seenUids: { box: {}, circle: {} } }, _);
          return A;
        }
        query(t, r, s, l) {
          return this._query(t, r, s, l, !1, null);
        }
        hitTest(t, r, s, l, h, g) {
          return this._query(t, r, s, l, !0, h, g).length > 0;
        }
        hitTestCircle(t, r, s, l, h) {
          const g = t - s, _ = t + s, A = r - s, L = r + s;
          if (_ < 0 || g > this.width || L < 0 || A > this.height) return !1;
          const E = [];
          return this._forEachCell(g, A, _, L, this._queryCellCircle, E, { hitTest: !0, overlapMode: l, circle: { x: t, y: r, radius: s }, seenUids: { box: {}, circle: {} } }, h), E.length > 0;
        }
        _queryCell(t, r, s, l, h, g, _, A) {
          const { seenUids: L, hitTest: E, overlapMode: M } = _, R = this.boxCells[h];
          if (R !== null) {
            const B = this.bboxes;
            for (const $ of R) if (!L.box[$]) {
              L.box[$] = !0;
              const Q = 4 * $, tt = this.boxKeys[$];
              if (t <= B[Q + 2] && r <= B[Q + 3] && s >= B[Q + 0] && l >= B[Q + 1] && (!A || A(tt)) && (!E || !Xr(M, tt.overlapMode)) && (g.push({ key: tt, x1: B[Q], y1: B[Q + 1], x2: B[Q + 2], y2: B[Q + 3] }), E)) return !0;
            }
          }
          const q = this.circleCells[h];
          if (q !== null) {
            const B = this.circles;
            for (const $ of q) if (!L.circle[$]) {
              L.circle[$] = !0;
              const Q = 3 * $, tt = this.circleKeys[$];
              if (this._circleAndRectCollide(B[Q], B[Q + 1], B[Q + 2], t, r, s, l) && (!A || A(tt)) && (!E || !Xr(M, tt.overlapMode))) {
                const nt = B[Q], it = B[Q + 1], ht = B[Q + 2];
                if (g.push({ key: tt, x1: nt - ht, y1: it - ht, x2: nt + ht, y2: it + ht }), E) return !0;
              }
            }
          }
          return !1;
        }
        _queryCellCircle(t, r, s, l, h, g, _, A) {
          const { circle: L, seenUids: E, overlapMode: M } = _, R = this.boxCells[h];
          if (R !== null) {
            const B = this.bboxes;
            for (const $ of R) if (!E.box[$]) {
              E.box[$] = !0;
              const Q = 4 * $, tt = this.boxKeys[$];
              if (this._circleAndRectCollide(L.x, L.y, L.radius, B[Q + 0], B[Q + 1], B[Q + 2], B[Q + 3]) && (!A || A(tt)) && !Xr(M, tt.overlapMode)) return g.push(!0), !0;
            }
          }
          const q = this.circleCells[h];
          if (q !== null) {
            const B = this.circles;
            for (const $ of q) if (!E.circle[$]) {
              E.circle[$] = !0;
              const Q = 3 * $, tt = this.circleKeys[$];
              if (this._circlesCollide(B[Q], B[Q + 1], B[Q + 2], L.x, L.y, L.radius) && (!A || A(tt)) && !Xr(M, tt.overlapMode)) return g.push(!0), !0;
            }
          }
        }
        _forEachCell(t, r, s, l, h, g, _, A) {
          const L = this._convertToXCellCoord(t), E = this._convertToYCellCoord(r), M = this._convertToXCellCoord(s), R = this._convertToYCellCoord(l);
          for (let q = L; q <= M; q++) for (let B = E; B <= R; B++) if (h.call(this, t, r, s, l, this.xCellCount * B + q, g, _, A)) return;
        }
        _convertToXCellCoord(t) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
        }
        _convertToYCellCoord(t) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
        }
        _circlesCollide(t, r, s, l, h, g) {
          const _ = l - t, A = h - r, L = s + g;
          return L * L > _ * _ + A * A;
        }
        _circleAndRectCollide(t, r, s, l, h, g, _) {
          const A = (g - l) / 2, L = Math.abs(t - (l + A));
          if (L > A + s) return !1;
          const E = (_ - h) / 2, M = Math.abs(r - (h + E));
          if (M > E + s) return !1;
          if (L <= A || M <= E) return !0;
          const R = L - A, q = M - E;
          return R * R + q * q <= s * s;
        }
      }
      function Mr(o, t, r, s, l) {
        const h = c.H();
        return t ? (c.K(h, h, [1 / l, 1 / l, 1]), r || c.ad(h, h, s.angle)) : c.L(h, s.labelPlaneMatrix, o), h;
      }
      function Er(o, t, r, s, l) {
        if (t) {
          const h = c.ae(o);
          return c.K(h, h, [l, l, 1]), r || c.ad(h, h, -s.angle), h;
        }
        return s.glCoordMatrix;
      }
      function ut(o, t, r, s) {
        let l;
        s ? (l = [o, t, s(o, t), 1], c.af(l, l, r)) : (l = [o, t, 0, 1], xi(l, l, r));
        const h = l[3];
        return { point: new c.P(l[0] / h, l[1] / h), signedDistanceFromCamera: h, isOccluded: !1 };
      }
      function V(o, t) {
        return 0.5 + o / t * 0.5;
      }
      function Z(o, t) {
        return o.x >= -t[0] && o.x <= t[0] && o.y >= -t[1] && o.y <= t[1];
      }
      function et(o, t, r, s, l, h, g, _, A, L, E, M, R, q, B) {
        const $ = s ? o.textSizeData : o.iconSizeData, Q = c.ag($, r.transform.zoom), tt = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1], nt = s ? o.text.dynamicLayoutVertexArray : o.icon.dynamicLayoutVertexArray;
        nt.clear();
        const it = o.lineVertexArray, ht = s ? o.text.placedSymbolArray : o.icon.placedSymbolArray, wt = r.transform.width / r.transform.height;
        let _t = !1;
        for (let Vt = 0; Vt < ht.length; Vt++) {
          const re = ht.get(Vt);
          if (re.hidden || re.writingMode === c.ah.vertical && !_t) {
            $e(re.numGlyphs, nt);
            continue;
          }
          _t = !1;
          const ce = ut(re.anchorX, re.anchorY, t, B);
          if (!Z(ce.point, tt)) {
            $e(re.numGlyphs, nt);
            continue;
          }
          const de = V(r.transform.cameraToCenterDistance, ce.signedDistanceFromCamera), ue = c.ai($, Q, re), he = g ? ue / de : ue * de, fe = { getElevation: B, labelPlaneMatrix: l, lineVertexArray: it, pitchWithMap: g, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: L, tileAnchorPoint: new c.P(re.anchorX, re.anchorY), unwrappedTileID: E, width: M, height: R, translation: q }, Oe = Mt(fe, re, he, !1, _, t, h, o.glyphOffsetArray, nt, wt, A);
          _t = Oe.useVertical, (Oe.notEnoughRoom || _t || Oe.needsFlipping && Mt(fe, re, he, !0, _, t, h, o.glyphOffsetArray, nt, wt, A).notEnoughRoom) && $e(re.numGlyphs, nt);
        }
        s ? o.text.dynamicLayoutVertexBuffer.updateData(nt) : o.icon.dynamicLayoutVertexBuffer.updateData(nt);
      }
      function ct(o, t, r, s, l, h, g, _) {
        const A = h.glyphStartIndex + h.numGlyphs, L = h.lineStartIndex, E = h.lineStartIndex + h.lineLength, M = t.getoffsetX(h.glyphStartIndex), R = t.getoffsetX(A - 1), q = me(o * M, r, s, l, h.segment, L, E, _, g);
        if (!q) return null;
        const B = me(o * R, r, s, l, h.segment, L, E, _, g);
        return B ? _.projectionCache.anyProjectionOccluded ? null : { first: q, last: B } : null;
      }
      function Pt(o, t, r, s) {
        return o === c.ah.horizontal && Math.abs(r.y - t.y) > Math.abs(r.x - t.x) * s ? { useVertical: !0 } : (o === c.ah.vertical ? t.y < r.y : t.x > r.x) ? { needsFlipping: !0 } : null;
      }
      function Mt(o, t, r, s, l, h, g, _, A, L, E) {
        const M = r / 24, R = t.lineOffsetX * M, q = t.lineOffsetY * M;
        let B;
        if (t.numGlyphs > 1) {
          const $ = t.glyphStartIndex + t.numGlyphs, Q = t.lineStartIndex, tt = t.lineStartIndex + t.lineLength, nt = ct(M, _, R, q, s, t, E, o);
          if (!nt) return { notEnoughRoom: !0 };
          const it = ut(nt.first.point.x, nt.first.point.y, g, o.getElevation).point, ht = ut(nt.last.point.x, nt.last.point.y, g, o.getElevation).point;
          if (l && !s) {
            const wt = Pt(t.writingMode, it, ht, L);
            if (wt) return wt;
          }
          B = [nt.first];
          for (let wt = t.glyphStartIndex + 1; wt < $ - 1; wt++) B.push(me(M * _.getoffsetX(wt), R, q, s, t.segment, Q, tt, o, E));
          B.push(nt.last);
        } else {
          if (l && !s) {
            const Q = ut(o.tileAnchorPoint.x, o.tileAnchorPoint.y, h, o.getElevation).point, tt = t.lineStartIndex + t.segment + 1, nt = new c.P(o.lineVertexArray.getx(tt), o.lineVertexArray.gety(tt)), it = ut(nt.x, nt.y, h, o.getElevation), ht = it.signedDistanceFromCamera > 0 ? it.point : function(_t, Vt, re, ce, de, ue) {
              return At(_t, Vt, re, 1, de, ue);
            }(o.tileAnchorPoint, nt, Q, 0, h, o), wt = Pt(t.writingMode, Q, ht, L);
            if (wt) return wt;
          }
          const $ = me(M * _.getoffsetX(t.glyphStartIndex), R, q, s, t.segment, t.lineStartIndex, t.lineStartIndex + t.lineLength, o, E);
          if (!$ || o.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
          B = [$];
        }
        for (const $ of B) c.aj(A, $.point, $.angle);
        return {};
      }
      function At(o, t, r, s, l, h) {
        const g = o.add(o.sub(t)._unit()), _ = l !== void 0 ? ut(g.x, g.y, l, h.getElevation).point : Ut(g.x, g.y, h).point, A = r.sub(_);
        return r.add(A._mult(s / A.mag()));
      }
      function bt(o, t, r) {
        const s = t.projectionCache;
        if (s.projections[o]) return s.projections[o];
        const l = new c.P(t.lineVertexArray.getx(o), t.lineVertexArray.gety(o)), h = Ut(l.x, l.y, t);
        if (h.signedDistanceFromCamera > 0) return s.projections[o] = h.point, s.anyProjectionOccluded = s.anyProjectionOccluded || h.isOccluded, h.point;
        const g = o - r.direction;
        return function(_, A, L, E, M) {
          return At(_, A, L, E, void 0, M);
        }(r.distanceFromAnchor === 0 ? t.tileAnchorPoint : new c.P(t.lineVertexArray.getx(g), t.lineVertexArray.gety(g)), l, r.previousVertex, r.absOffsetX - r.distanceFromAnchor + 1, t);
      }
      function Ut(o, t, r) {
        const s = o + r.translation[0], l = t + r.translation[1];
        let h;
        return !r.pitchWithMap && r.projection.useSpecialProjectionForSymbols ? (h = r.projection.projectTileCoordinates(s, l, r.unwrappedTileID, r.getElevation), h.point.x = (0.5 * h.point.x + 0.5) * r.width, h.point.y = (0.5 * -h.point.y + 0.5) * r.height) : (h = ut(s, l, r.labelPlaneMatrix, r.getElevation), h.isOccluded = !1), h;
      }
      function te(o, t, r) {
        return o._unit()._perp()._mult(t * r);
      }
      function Bt(o, t, r, s, l, h, g, _, A) {
        if (_.projectionCache.offsets[o]) return _.projectionCache.offsets[o];
        const L = r.add(t);
        if (o + A.direction < s || o + A.direction >= l) return _.projectionCache.offsets[o] = L, L;
        const E = bt(o + A.direction, _, A), M = te(E.sub(r), g, A.direction), R = r.add(M), q = E.add(M);
        return _.projectionCache.offsets[o] = c.ak(h, L, R, q) || L, _.projectionCache.offsets[o];
      }
      function me(o, t, r, s, l, h, g, _, A) {
        const L = s ? o - t : o + t;
        let E = L > 0 ? 1 : -1, M = 0;
        s && (E *= -1, M = Math.PI), E < 0 && (M += Math.PI);
        let R, q = E > 0 ? h + l : h + l + 1;
        _.projectionCache.cachedAnchorPoint ? R = _.projectionCache.cachedAnchorPoint : (R = Ut(_.tileAnchorPoint.x, _.tileAnchorPoint.y, _).point, _.projectionCache.cachedAnchorPoint = R);
        let B, $, Q = R, tt = R, nt = 0, it = 0;
        const ht = Math.abs(L), wt = [];
        let _t;
        for (; nt + it <= ht; ) {
          if (q += E, q < h || q >= g) return null;
          nt += it, tt = Q, $ = B;
          const ce = { absOffsetX: ht, direction: E, distanceFromAnchor: nt, previousVertex: tt };
          if (Q = bt(q, _, ce), r === 0) wt.push(tt), _t = Q.sub(tt);
          else {
            let de;
            const ue = Q.sub(tt);
            de = ue.mag() === 0 ? te(bt(q + E, _, ce).sub(Q), r, E) : te(ue, r, E), $ || ($ = tt.add(de)), B = Bt(q, de, Q, h, g, $, r, _, ce), wt.push($), _t = B.sub($);
          }
          it = _t.mag();
        }
        const Vt = _t._mult((ht - nt) / it)._add($ || tt), re = M + Math.atan2(Q.y - tt.y, Q.x - tt.x);
        return wt.push(Vt), { point: Vt, angle: A ? re : 0, path: wt };
      }
      const Ne = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function $e(o, t) {
        for (let r = 0; r < o; r++) {
          const s = t.length;
          t.resize(s + 4), t.float32.set(Ne, 3 * s);
        }
      }
      function xi(o, t, r) {
        const s = t[0], l = t[1];
        return o[0] = r[0] * s + r[4] * l + r[12], o[1] = r[1] * s + r[5] * l + r[13], o[3] = r[3] * s + r[7] * l + r[15], o;
      }
      const Ke = 100;
      class yi {
        constructor(t, r, s = new Vi(t.width + 200, t.height + 200, 25), l = new Vi(t.width + 200, t.height + 200, 25)) {
          this.transform = t, this.mapProjection = r, this.grid = s, this.ignoredGrid = l, this.pitchFactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + Ke, this.screenBottomBoundary = t.height + Ke, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(t, r, s, l, h, g, _, A, L, E, M) {
          const R = t.anchorPointX + A[0], q = t.anchorPointY + A[1], B = this.projectAndGetPerspectiveRatio(l, R, q, h, E), $ = s * B.perspectiveRatio;
          let Q;
          if (g || _) Q = this._projectCollisionBox(t, $, l, h, g, _, A, B, E, M);
          else {
            const wt = B.point.x + (M ? M.x * $ : 0), _t = B.point.y + (M ? M.y * $ : 0);
            Q = { allPointsOccluded: !1, box: [wt + t.x1 * $, _t + t.y1 * $, wt + t.x2 * $, _t + t.y2 * $] };
          }
          const [tt, nt, it, ht] = Q.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (g ? Q.allPointsOccluded : this.mapProjection.isOccluded(R, q, h)) || B.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(tt, nt, it, ht) || r !== "always" && this.grid.hitTest(tt, nt, it, ht, r, L) ? { box: [tt, nt, it, ht], placeable: !1, offscreen: !1 } : { box: [tt, nt, it, ht], placeable: !0, offscreen: this.isOffscreen(tt, nt, it, ht) };
        }
        placeCollisionCircles(t, r, s, l, h, g, _, A, L, E, M, R, q, B, $, Q) {
          const tt = [], nt = new c.P(r.anchorX, r.anchorY), it = this.getPerspectiveRatio(g, nt.x, nt.y, _, Q), ht = (M ? h / it : h * it) / c.ap, wt = { getElevation: Q, labelPlaneMatrix: A, lineVertexArray: s, pitchWithMap: M, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, projection: this.mapProjection, tileAnchorPoint: nt, unwrappedTileID: _, width: this.transform.width, height: this.transform.height, translation: $ }, _t = ct(ht, l, r.lineOffsetX * ht, r.lineOffsetY * ht, !1, r, !1, wt);
          let Vt = !1, re = !1, ce = !0;
          if (_t) {
            const de = 0.5 * q * it + B, ue = new c.P(-100, -100), he = new c.P(this.screenRightBoundary, this.screenBottomBoundary), fe = new Ee(), Oe = _t.first, ve = _t.last;
            let xe = [];
            for (let ii = Oe.path.length - 1; ii >= 1; ii--) xe.push(Oe.path[ii]);
            for (let ii = 1; ii < ve.path.length; ii++) xe.push(ve.path[ii]);
            const Ue = 2.5 * de;
            if (L) {
              const ii = this.projectPathToScreenSpace(xe, wt, L);
              xe = ii.some((ci) => ci.signedDistanceFromCamera <= 0) ? [] : ii.map((ci) => ci.point);
            }
            let ni = [];
            if (xe.length > 0) {
              const ii = xe[0].clone(), ci = xe[0].clone();
              for (let bi = 1; bi < xe.length; bi++) ii.x = Math.min(ii.x, xe[bi].x), ii.y = Math.min(ii.y, xe[bi].y), ci.x = Math.max(ci.x, xe[bi].x), ci.y = Math.max(ci.y, xe[bi].y);
              ni = ii.x >= ue.x && ci.x <= he.x && ii.y >= ue.y && ci.y <= he.y ? [xe] : ci.x < ue.x || ii.x > he.x || ci.y < ue.y || ii.y > he.y ? [] : c.al([xe], ue.x, ue.y, he.x, he.y);
            }
            for (const ii of ni) {
              fe.reset(ii, 0.25 * de);
              let ci = 0;
              ci = fe.length <= 0.5 * de ? 1 : Math.ceil(fe.paddedLength / Ue) + 1;
              for (let bi = 0; bi < ci; bi++) {
                const ji = bi / Math.max(ci - 1, 1), tr = fe.lerp(ji), Ni = tr.x + Ke, ur = tr.y + Ke;
                tt.push(Ni, ur, de, 0);
                const qi = Ni - de, or = ur - de, xr = Ni + de, dn = ur + de;
                if (ce = ce && this.isOffscreen(qi, or, xr, dn), re = re || this.isInsideGrid(qi, or, xr, dn), t !== "always" && this.grid.hitTestCircle(Ni, ur, de, t, R) && (Vt = !0, !E)) return { circles: [], offscreen: !1, collisionDetected: Vt };
              }
            }
          }
          return { circles: !E && Vt || !re || it < this.perspectiveRatioCutoff ? [] : tt, offscreen: ce, collisionDetected: Vt };
        }
        projectPathToScreenSpace(t, r, s) {
          return t.map((l) => ut(l.x, l.y, s, r.getElevation));
        }
        queryRenderedSymbols(t) {
          if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const r = [];
          let s = 1 / 0, l = 1 / 0, h = -1 / 0, g = -1 / 0;
          for (const E of t) {
            const M = new c.P(E.x + Ke, E.y + Ke);
            s = Math.min(s, M.x), l = Math.min(l, M.y), h = Math.max(h, M.x), g = Math.max(g, M.y), r.push(M);
          }
          const _ = this.grid.query(s, l, h, g).concat(this.ignoredGrid.query(s, l, h, g)), A = {}, L = {};
          for (const E of _) {
            const M = E.key;
            if (A[M.bucketInstanceId] === void 0 && (A[M.bucketInstanceId] = {}), A[M.bucketInstanceId][M.featureIndex]) continue;
            const R = [new c.P(E.x1, E.y1), new c.P(E.x2, E.y1), new c.P(E.x2, E.y2), new c.P(E.x1, E.y2)];
            c.am(r, R) && (A[M.bucketInstanceId][M.featureIndex] = !0, L[M.bucketInstanceId] === void 0 && (L[M.bucketInstanceId] = []), L[M.bucketInstanceId].push(M.featureIndex));
          }
          return L;
        }
        insertCollisionBox(t, r, s, l, h, g) {
          (s ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: l, featureIndex: h, collisionGroupID: g, overlapMode: r }, t[0], t[1], t[2], t[3]);
        }
        insertCollisionCircles(t, r, s, l, h, g) {
          const _ = s ? this.ignoredGrid : this.grid, A = { bucketInstanceId: l, featureIndex: h, collisionGroupID: g, overlapMode: r };
          for (let L = 0; L < t.length; L += 4) _.insertCircle(A, t[L], t[L + 1], t[L + 2]);
        }
        projectAndGetPerspectiveRatio(t, r, s, l, h) {
          let g;
          h ? (g = [r, s, h(r, s), 1], c.af(g, g, t)) : (g = [r, s, 0, 1], xi(g, g, t));
          const _ = g[3];
          return { point: new c.P((g[0] / _ + 1) / 2 * this.transform.width + Ke, (-g[1] / _ + 1) / 2 * this.transform.height + Ke), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / _ * 0.5, isOccluded: !1, signedDistanceFromCamera: _ };
        }
        getPerspectiveRatio(t, r, s, l, h) {
          const g = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(r, s, l, h) : ut(r, s, t, h);
          return 0.5 + this.transform.cameraToCenterDistance / g.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(t, r, s, l) {
          return s < Ke || t >= this.screenRightBoundary || l < Ke || r > this.screenBottomBoundary;
        }
        isInsideGrid(t, r, s, l) {
          return s >= 0 && t < this.gridRightBoundary && l >= 0 && r < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t = c.an([]);
          return c.J(t, t, [-100, -100, 0]), t;
        }
        _projectCollisionBox(t, r, s, l, h, g, _, A, L, E) {
          let M = new c.P(1, 0), R = new c.P(0, 1);
          const q = new c.P(t.anchorPointX + _[0], t.anchorPointY + _[1]);
          if (g && !h) {
            const ce = this.projectAndGetPerspectiveRatio(s, q.x + 1, q.y, l, L).point.sub(A.point).unit(), de = Math.atan(ce.y / ce.x) + (ce.x < 0 ? Math.PI : 0), ue = Math.sin(de), he = Math.cos(de);
            M = new c.P(he, ue), R = new c.P(-ue, he);
          } else if (!g && h) {
            const ce = -this.transform.angle, de = Math.sin(ce), ue = Math.cos(ce);
            M = new c.P(ue, de), R = new c.P(-de, ue);
          }
          let B = A.point, $ = r;
          if (h) {
            B = q;
            const ce = this.transform.zoom - Math.floor(this.transform.zoom);
            $ = Math.pow(2, -ce), $ *= this.mapProjection.getPitchedTextCorrection(this.transform, q, l), E || ($ *= c.ac(0.5 + A.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          E && (B = B.add(M.mult(E.x * $)).add(R.mult(E.y * $)));
          const Q = t.x1 * $, tt = t.x2 * $, nt = (Q + tt) / 2, it = t.y1 * $, ht = t.y2 * $, wt = (it + ht) / 2, _t = [{ offsetX: Q, offsetY: it }, { offsetX: nt, offsetY: it }, { offsetX: tt, offsetY: it }, { offsetX: tt, offsetY: wt }, { offsetX: tt, offsetY: ht }, { offsetX: nt, offsetY: ht }, { offsetX: Q, offsetY: ht }, { offsetX: Q, offsetY: wt }];
          let Vt = [];
          for (const { offsetX: ce, offsetY: de } of _t) Vt.push(new c.P(B.x + M.x * ce + R.x * de, B.y + M.y * ce + R.y * de));
          let re = !1;
          if (h) {
            const ce = Vt.map((de) => this.projectAndGetPerspectiveRatio(s, de.x, de.y, l, L));
            re = ce.some((de) => !de.isOccluded), Vt = ce.map((de) => de.point);
          } else re = !0;
          return { box: c.ao(Vt), allPointsOccluded: !re };
        }
      }
      function pi(o, t, r) {
        return t * (c.X / (o.tileSize * Math.pow(2, r - o.tileID.overscaledZ)));
      }
      class Zi {
        constructor(t, r, s, l) {
          this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? r : -r))) : l && s ? 1 : 0, this.placed = s;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Bi {
        constructor(t, r, s, l, h) {
          this.text = new Zi(t ? t.text : null, r, s, h), this.icon = new Zi(t ? t.icon : null, r, l, h);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class li {
        constructor(t, r, s) {
          this.text = t, this.icon = r, this.skipFade = s;
        }
      }
      class Di {
        constructor() {
          this.invProjMatrix = c.H(), this.viewportMatrix = c.H(), this.circles = [];
        }
      }
      class Gi {
        constructor(t, r, s, l, h) {
          this.bucketInstanceId = t, this.featureIndex = r, this.sourceLayerIndex = s, this.bucketIndex = l, this.tileID = h;
        }
      }
      class hr {
        constructor(t) {
          this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(t) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[t]) {
            const r = ++this.maxGroupID;
            this.collisionGroups[t] = { ID: r, predicate: (s) => s.collisionGroupID === r };
          }
          return this.collisionGroups[t];
        }
      }
      function pr(o, t, r, s, l) {
        const { horizontalAlign: h, verticalAlign: g } = c.au(o);
        return new c.P(-(h - 0.5) * t + s[0] * l, -(g - 0.5) * r + s[1] * l);
      }
      class Ar {
        constructor(t, r, s, l, h, g) {
          this.transform = t.clone(), this.terrain = s, this.collisionIndex = new yi(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = l, this.retainedQueryData = {}, this.collisionGroups = new hr(h), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = g, g && (g.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(t) {
          const r = this.terrain;
          return r ? (s, l) => r.getElevation(t, s, l) : null;
        }
        getBucketParts(t, r, s, l) {
          const h = s.getBucket(r), g = s.latestFeatureIndex;
          if (!h || !g || r.id !== h.layerIds[0]) return;
          const _ = s.collisionBoxArray, A = h.layers[0].layout, L = h.layers[0].paint, E = Math.pow(2, this.transform.zoom - s.tileID.overscaledZ), M = s.tileSize / c.X, R = s.tileID.toUnwrapped(), q = this.transform.calculatePosMatrix(R), B = A.get("text-pitch-alignment") === "map", $ = A.get("text-rotation-alignment") === "map", Q = pi(s, 1, this.transform.zoom), tt = this.collisionIndex.mapProjection.translatePosition(this.transform, s, L.get("text-translate"), L.get("text-translate-anchor")), nt = this.collisionIndex.mapProjection.translatePosition(this.transform, s, L.get("icon-translate"), L.get("icon-translate-anchor")), it = Mr(q, B, $, this.transform, Q);
          let ht = null;
          if (B) {
            const _t = Er(q, B, $, this.transform, Q);
            ht = c.L([], this.transform.labelPlaneMatrix, _t);
          }
          this.retainedQueryData[h.bucketInstanceId] = new Gi(h.bucketInstanceId, g, h.sourceLayerIndex, h.index, s.tileID);
          const wt = { bucket: h, layout: A, translationText: tt, translationIcon: nt, posMatrix: q, unwrappedTileID: R, textLabelPlaneMatrix: it, labelToScreenMatrix: ht, scale: E, textPixelRatio: M, holdingForFade: s.holdingForFade(), collisionBoxArray: _, partiallyEvaluatedTextSize: c.ag(h.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(h.sourceID) };
          if (l) for (const _t of h.sortKeyRanges) {
            const { sortKey: Vt, symbolInstanceStart: re, symbolInstanceEnd: ce } = _t;
            t.push({ sortKey: Vt, symbolInstanceStart: re, symbolInstanceEnd: ce, parameters: wt });
          }
          else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: h.symbolInstances.length, parameters: wt });
        }
        attemptAnchorPlacement(t, r, s, l, h, g, _, A, L, E, M, R, q, B, $, Q, tt, nt, it) {
          const ht = c.aq[t.textAnchor], wt = [t.textOffset0, t.textOffset1], _t = pr(ht, s, l, wt, h), Vt = this.collisionIndex.placeCollisionBox(r, R, A, L, E, _, g, Q, M.predicate, it, _t);
          if ((!nt || this.collisionIndex.placeCollisionBox(nt, R, A, L, E, _, g, tt, M.predicate, it, _t).placeable) && Vt.placeable) {
            let re;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[q.crossTileID] && this.prevPlacement.placements[q.crossTileID] && this.prevPlacement.placements[q.crossTileID].text && (re = this.prevPlacement.variableOffsets[q.crossTileID].anchor), q.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[q.crossTileID] = { textOffset: wt, width: s, height: l, anchor: ht, textBoxScale: h, prevAnchor: re }, this.markUsedJustification(B, ht, q, $), B.allowVerticalPlacement && (this.markUsedOrientation(B, $, q), this.placedOrientations[q.crossTileID] = $), { shift: _t, placedGlyphBoxes: Vt };
          }
        }
        placeLayerBucketPart(t, r, s) {
          const { bucket: l, layout: h, translationText: g, translationIcon: _, posMatrix: A, unwrappedTileID: L, textLabelPlaneMatrix: E, labelToScreenMatrix: M, textPixelRatio: R, holdingForFade: q, collisionBoxArray: B, partiallyEvaluatedTextSize: $, collisionGroup: Q } = t.parameters, tt = h.get("text-optional"), nt = h.get("icon-optional"), it = c.ar(h, "text-overlap", "text-allow-overlap"), ht = it === "always", wt = c.ar(h, "icon-overlap", "icon-allow-overlap"), _t = wt === "always", Vt = h.get("text-rotation-alignment") === "map", re = h.get("text-pitch-alignment") === "map", ce = h.get("icon-text-fit") !== "none", de = h.get("symbol-z-order") === "viewport-y", ue = ht && (_t || !l.hasIconData() || nt), he = _t && (ht || !l.hasTextData() || tt);
          !l.collisionArrays && B && l.deserializeCollisionBoxes(B);
          const fe = this._getTerrainElevationFunc(this.retainedQueryData[l.bucketInstanceId].tileID), Oe = (ve, xe, Ue) => {
            var ni, ii;
            if (r[ve.crossTileID]) return;
            if (q) return void (this.placements[ve.crossTileID] = new li(!1, !1, !1));
            let ci = !1, bi = !1, ji = !0, tr = null, Ni = { box: null, placeable: !1, offscreen: null }, ur = { box: null, placeable: !1, offscreen: null }, qi = null, or = null, xr = null, dn = 0, Cn = 0, er = 0;
            xe.textFeatureIndex ? dn = xe.textFeatureIndex : ve.useRuntimeCollisionCircles && (dn = ve.featureIndex), xe.verticalTextFeatureIndex && (Cn = xe.verticalTextFeatureIndex);
            const da = xe.textBox;
            if (da) {
              const en = (yr) => {
                let Vr = c.ah.horizontal;
                if (l.allowVerticalPlacement && !yr && this.prevPlacement) {
                  const nn = this.prevPlacement.placedOrientations[ve.crossTileID];
                  nn && (this.placedOrientations[ve.crossTileID] = nn, Vr = nn, this.markUsedOrientation(l, Vr, ve));
                }
                return Vr;
              }, pn = (yr, Vr) => {
                if (l.allowVerticalPlacement && ve.numVerticalGlyphVertices > 0 && xe.verticalTextBox) {
                  for (const nn of l.writingModes) if (nn === c.ah.vertical ? (Ni = Vr(), ur = Ni) : Ni = yr(), Ni && Ni.placeable) break;
                } else Ni = yr();
              }, Fr = ve.textAnchorOffsetStartIndex, rn = ve.textAnchorOffsetEndIndex;
              if (rn === Fr) {
                const yr = (Vr, nn) => {
                  const Li = this.collisionIndex.placeCollisionBox(Vr, it, R, A, L, re, Vt, g, Q.predicate, fe);
                  return Li && Li.placeable && (this.markUsedOrientation(l, nn, ve), this.placedOrientations[ve.crossTileID] = nn), Li;
                };
                pn(() => yr(da, c.ah.horizontal), () => {
                  const Vr = xe.verticalTextBox;
                  return l.allowVerticalPlacement && ve.numVerticalGlyphVertices > 0 && Vr ? yr(Vr, c.ah.vertical) : { box: null, offscreen: null };
                }), en(Ni && Ni.placeable);
              } else {
                let yr = c.aq[(ii = (ni = this.prevPlacement) === null || ni === void 0 ? void 0 : ni.variableOffsets[ve.crossTileID]) === null || ii === void 0 ? void 0 : ii.anchor];
                const Vr = (Li, Ts, pa) => {
                  const Us = Li.x2 - Li.x1, xo = Li.y2 - Li.y1, Bc = ve.textBoxScale, cc = ce && wt === "never" ? Ts : null;
                  let Ls = null, Vs = it === "never" ? 1 : 2, vl = "never";
                  yr && Vs++;
                  for (let el = 0; el < Vs; el++) {
                    for (let xl = Fr; xl < rn; xl++) {
                      const il = l.textAnchorOffsets.get(xl);
                      if (yr && il.textAnchor !== yr) continue;
                      const Gs = this.attemptAnchorPlacement(il, Li, Us, xo, Bc, Vt, re, R, A, L, Q, vl, ve, l, pa, g, _, cc, fe);
                      if (Gs && (Ls = Gs.placedGlyphBoxes, Ls && Ls.placeable)) return ci = !0, tr = Gs.shift, Ls;
                    }
                    yr ? yr = null : vl = it;
                  }
                  return s && !Ls && (Ls = { box: this.collisionIndex.placeCollisionBox(da, "always", R, A, L, re, Vt, g, Q.predicate, fe, new c.P(0, 0)).box, offscreen: !1, placeable: !1 }), Ls;
                };
                pn(() => Vr(da, xe.iconBox, c.ah.horizontal), () => {
                  const Li = xe.verticalTextBox;
                  return l.allowVerticalPlacement && (!Ni || !Ni.placeable) && ve.numVerticalGlyphVertices > 0 && Li ? Vr(Li, xe.verticalIconBox, c.ah.vertical) : { box: null, occluded: !0, offscreen: null };
                }), Ni && (ci = Ni.placeable, ji = Ni.offscreen);
                const nn = en(Ni && Ni.placeable);
                if (!ci && this.prevPlacement) {
                  const Li = this.prevPlacement.variableOffsets[ve.crossTileID];
                  Li && (this.variableOffsets[ve.crossTileID] = Li, this.markUsedJustification(l, Li.anchor, ve, nn));
                }
              }
            }
            if (qi = Ni, ci = qi && qi.placeable, ji = qi && qi.offscreen, ve.useRuntimeCollisionCircles) {
              const en = l.text.placedSymbolArray.get(ve.centerJustifiedTextSymbolIndex), pn = c.ai(l.textSizeData, $, en), Fr = h.get("text-padding");
              or = this.collisionIndex.placeCollisionCircles(it, en, l.lineVertexArray, l.glyphOffsetArray, pn, A, L, E, M, s, re, Q.predicate, ve.collisionCircleDiameter, Fr, g, fe), or.circles.length && or.collisionDetected && !s && c.w("Collisions detected, but collision boxes are not shown"), ci = ht || or.circles.length > 0 && !or.collisionDetected, ji = ji && or.offscreen;
            }
            if (xe.iconFeatureIndex && (er = xe.iconFeatureIndex), xe.iconBox) {
              const en = (pn) => this.collisionIndex.placeCollisionBox(pn, wt, R, A, L, re, Vt, _, Q.predicate, fe, ce && tr ? tr : void 0);
              ur && ur.placeable && xe.verticalIconBox ? (xr = en(xe.verticalIconBox), bi = xr.placeable) : (xr = en(xe.iconBox), bi = xr.placeable), ji = ji && xr.offscreen;
            }
            const Mn = tt || ve.numHorizontalGlyphVertices === 0 && ve.numVerticalGlyphVertices === 0, tl = nt || ve.numIconVertices === 0;
            Mn || tl ? tl ? Mn || (bi = bi && ci) : ci = bi && ci : bi = ci = bi && ci;
            const vo = bi && xr.placeable;
            if (ci && qi.placeable && this.collisionIndex.insertCollisionBox(qi.box, it, h.get("text-ignore-placement"), l.bucketInstanceId, ur && ur.placeable && Cn ? Cn : dn, Q.ID), vo && this.collisionIndex.insertCollisionBox(xr.box, wt, h.get("icon-ignore-placement"), l.bucketInstanceId, er, Q.ID), or && ci && this.collisionIndex.insertCollisionCircles(or.circles, it, h.get("text-ignore-placement"), l.bucketInstanceId, dn, Q.ID), s && this.storeCollisionData(l.bucketInstanceId, Ue, xe, qi, xr, or), ve.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            if (l.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[ve.crossTileID] = new li(ci || ue, bi || he, ji || l.justReloaded), r[ve.crossTileID] = !0;
          };
          if (de) {
            if (t.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
            const ve = l.getSortedSymbolIndexes(this.transform.angle);
            for (let xe = ve.length - 1; xe >= 0; --xe) {
              const Ue = ve[xe];
              Oe(l.symbolInstances.get(Ue), l.collisionArrays[Ue], Ue);
            }
          } else for (let ve = t.symbolInstanceStart; ve < t.symbolInstanceEnd; ve++) Oe(l.symbolInstances.get(ve), l.collisionArrays[ve], ve);
          if (s && l.bucketInstanceId in this.collisionCircleArrays) {
            const ve = this.collisionCircleArrays[l.bucketInstanceId];
            c.as(ve.invProjMatrix, A), ve.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          l.justReloaded = !1;
        }
        storeCollisionData(t, r, s, l, h, g) {
          if (s.textBox || s.iconBox) {
            let _, A;
            this.collisionBoxArrays.has(t) ? _ = this.collisionBoxArrays.get(t) : (_ = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(t, _)), _.has(r) ? A = _.get(r) : (A = { text: null, icon: null }, _.set(r, A)), s.textBox && (A.text = l.box), s.iconBox && (A.icon = h.box);
          }
          if (g) {
            let _ = this.collisionCircleArrays[t];
            _ === void 0 && (_ = this.collisionCircleArrays[t] = new Di());
            for (let A = 0; A < g.circles.length; A += 4) _.circles.push(g.circles[A + 0]), _.circles.push(g.circles[A + 1]), _.circles.push(g.circles[A + 2]), _.circles.push(g.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(t, r, s, l) {
          let h;
          h = l === c.ah.vertical ? s.verticalPlacedTextSymbolIndex : { left: s.leftJustifiedTextSymbolIndex, center: s.centerJustifiedTextSymbolIndex, right: s.rightJustifiedTextSymbolIndex }[c.at(r)];
          const g = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex, s.verticalPlacedTextSymbolIndex];
          for (const _ of g) _ >= 0 && (t.text.placedSymbolArray.get(_).crossTileID = h >= 0 && _ !== h ? 0 : s.crossTileID);
        }
        markUsedOrientation(t, r, s) {
          const l = r === c.ah.horizontal || r === c.ah.horizontalOnly ? r : 0, h = r === c.ah.vertical ? r : 0, g = [s.leftJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.rightJustifiedTextSymbolIndex];
          for (const _ of g) t.text.placedSymbolArray.get(_).placedOrientation = l;
          s.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(s.verticalPlacedTextSymbolIndex).placedOrientation = h);
        }
        commit(t) {
          this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const r = this.prevPlacement;
          let s = !1;
          this.prevZoomAdjustment = r ? r.zoomAdjustment(this.transform.zoom) : 0;
          const l = r ? r.symbolFadeChange(t) : 1, h = r ? r.opacities : {}, g = r ? r.variableOffsets : {}, _ = r ? r.placedOrientations : {};
          for (const A in this.placements) {
            const L = this.placements[A], E = h[A];
            E ? (this.opacities[A] = new Bi(E, l, L.text, L.icon), s = s || L.text !== E.text.placed || L.icon !== E.icon.placed) : (this.opacities[A] = new Bi(null, l, L.text, L.icon, L.skipFade), s = s || L.text || L.icon);
          }
          for (const A in h) {
            const L = h[A];
            if (!this.opacities[A]) {
              const E = new Bi(L, l, !1, !1);
              E.isHidden() || (this.opacities[A] = E, s = s || L.text.placed || L.icon.placed);
            }
          }
          for (const A in g) this.variableOffsets[A] || !this.opacities[A] || this.opacities[A].isHidden() || (this.variableOffsets[A] = g[A]);
          for (const A in _) this.placedOrientations[A] || !this.opacities[A] || this.opacities[A].isHidden() || (this.placedOrientations[A] = _[A]);
          if (r && r.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
          s ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = r ? r.lastPlacementChangeTime : t);
        }
        updateLayerOpacities(t, r) {
          const s = {};
          for (const l of r) {
            const h = l.getBucket(t);
            h && l.latestFeatureIndex && t.id === h.layerIds[0] && this.updateBucketOpacities(h, l.tileID, s, l.collisionBoxArray);
          }
        }
        updateBucketOpacities(t, r, s, l) {
          t.hasTextData() && (t.text.opacityVertexArray.clear(), t.text.hasVisibleVertices = !1), t.hasIconData() && (t.icon.opacityVertexArray.clear(), t.icon.hasVisibleVertices = !1), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
          const h = t.layers[0], g = h.layout, _ = new Bi(null, 0, !1, !1, !0), A = g.get("text-allow-overlap"), L = g.get("icon-allow-overlap"), E = h._unevaluatedLayout.hasValue("text-variable-anchor") || h._unevaluatedLayout.hasValue("text-variable-anchor-offset"), M = g.get("text-rotation-alignment") === "map", R = g.get("text-pitch-alignment") === "map", q = g.get("icon-text-fit") !== "none", B = new Bi(null, 0, A && (L || !t.hasIconData() || g.get("icon-optional")), L && (A || !t.hasTextData() || g.get("text-optional")), !0);
          !t.collisionArrays && l && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(l);
          const $ = (tt, nt, it) => {
            for (let ht = 0; ht < nt / 4; ht++) tt.opacityVertexArray.emplaceBack(it);
            tt.hasVisibleVertices = tt.hasVisibleVertices || it !== Js;
          }, Q = this.collisionBoxArrays.get(t.bucketInstanceId);
          for (let tt = 0; tt < t.symbolInstances.length; tt++) {
            const nt = t.symbolInstances.get(tt), { numHorizontalGlyphVertices: it, numVerticalGlyphVertices: ht, crossTileID: wt } = nt;
            let _t = this.opacities[wt];
            s[wt] ? _t = _ : _t || (_t = B, this.opacities[wt] = _t), s[wt] = !0;
            const Vt = nt.numIconVertices > 0, re = this.placedOrientations[nt.crossTileID], ce = re === c.ah.vertical, de = re === c.ah.horizontal || re === c.ah.horizontalOnly;
            if (it > 0 || ht > 0) {
              const he = Yr(_t.text);
              $(t.text, it, ce ? Js : he), $(t.text, ht, de ? Js : he);
              const fe = _t.text.isHidden();
              [nt.rightJustifiedTextSymbolIndex, nt.centerJustifiedTextSymbolIndex, nt.leftJustifiedTextSymbolIndex].forEach((xe) => {
                xe >= 0 && (t.text.placedSymbolArray.get(xe).hidden = fe || ce ? 1 : 0);
              }), nt.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(nt.verticalPlacedTextSymbolIndex).hidden = fe || de ? 1 : 0);
              const Oe = this.variableOffsets[nt.crossTileID];
              Oe && this.markUsedJustification(t, Oe.anchor, nt, re);
              const ve = this.placedOrientations[nt.crossTileID];
              ve && (this.markUsedJustification(t, "left", nt, ve), this.markUsedOrientation(t, ve, nt));
            }
            if (Vt) {
              const he = Yr(_t.icon), fe = !(q && nt.verticalPlacedIconSymbolIndex && ce);
              nt.placedIconSymbolIndex >= 0 && ($(t.icon, nt.numIconVertices, fe ? he : Js), t.icon.placedSymbolArray.get(nt.placedIconSymbolIndex).hidden = _t.icon.isHidden()), nt.verticalPlacedIconSymbolIndex >= 0 && ($(t.icon, nt.numVerticalIconVertices, fe ? Js : he), t.icon.placedSymbolArray.get(nt.verticalPlacedIconSymbolIndex).hidden = _t.icon.isHidden());
            }
            const ue = Q && Q.has(tt) ? Q.get(tt) : { text: null, icon: null };
            if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
              const he = t.collisionArrays[tt];
              if (he) {
                let fe = new c.P(0, 0);
                if (he.textBox || he.verticalTextBox) {
                  let Oe = !0;
                  if (E) {
                    const ve = this.variableOffsets[wt];
                    ve ? (fe = pr(ve.anchor, ve.width, ve.height, ve.textOffset, ve.textBoxScale), M && fe._rotate(R ? this.transform.angle : -this.transform.angle)) : Oe = !1;
                  }
                  if (he.textBox || he.verticalTextBox) {
                    let ve;
                    he.textBox && (ve = ce), he.verticalTextBox && (ve = de), Es(t.textCollisionBox.collisionVertexArray, _t.text.placed, !Oe || ve, ue.text, fe.x, fe.y);
                  }
                }
                if (he.iconBox || he.verticalIconBox) {
                  const Oe = !!(!de && he.verticalIconBox);
                  let ve;
                  he.iconBox && (ve = Oe), he.verticalIconBox && (ve = !Oe), Es(t.iconCollisionBox.collisionVertexArray, _t.icon.placed, ve, ue.icon, q ? fe.x : 0, q ? fe.y : 0);
                }
              }
            }
          }
          if (t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.text.opacityVertexArray.length !== t.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${t.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t.text.layoutVertexArray.length}) / 4`);
          if (t.icon.opacityVertexArray.length !== t.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${t.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t.icon.layoutVertexArray.length}) / 4`);
          if (t.bucketInstanceId in this.collisionCircleArrays) {
            const tt = this.collisionCircleArrays[t.bucketInstanceId];
            t.placementInvProjMatrix = tt.invProjMatrix, t.placementViewportMatrix = tt.viewportMatrix, t.collisionCircleArray = tt.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
          }
        }
        symbolFadeChange(t) {
          return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(t) {
          return Math.max(0, (this.transform.zoom - t) / 1.5);
        }
        hasTransitions(t) {
          return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(t, r) {
          const s = this.zoomAtLastRecencyCheck === r ? 1 - this.zoomAdjustment(r) : 1;
          return this.zoomAtLastRecencyCheck = r, this.commitTime + this.fadeDuration * s > t;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function Es(o, t, r, s, l, h) {
        s && s.length !== 0 || (s = [0, 0, 0, 0]);
        const g = s[0] - Ke, _ = s[1] - Ke, A = s[2] - Ke, L = s[3] - Ke;
        o.emplaceBack(t ? 1 : 0, r ? 1 : 0, l || 0, h || 0, g, _), o.emplaceBack(t ? 1 : 0, r ? 1 : 0, l || 0, h || 0, A, _), o.emplaceBack(t ? 1 : 0, r ? 1 : 0, l || 0, h || 0, A, L), o.emplaceBack(t ? 1 : 0, r ? 1 : 0, l || 0, h || 0, g, L);
      }
      const Ri = Math.pow(2, 25), No = Math.pow(2, 24), Ks = Math.pow(2, 17), Hr = Math.pow(2, 16), ln = Math.pow(2, 9), Do = Math.pow(2, 8), mn = Math.pow(2, 1);
      function Yr(o) {
        if (o.opacity === 0 && !o.placed) return 0;
        if (o.opacity === 1 && o.placed) return 4294967295;
        const t = o.placed ? 1 : 0, r = Math.floor(127 * o.opacity);
        return r * Ri + t * No + r * Ks + t * Hr + r * ln + t * Do + r * mn + t;
      }
      const Js = 0;
      function Dn() {
        return { isOccluded: (o, t, r) => !1, getPitchedTextCorrection: (o, t, r) => 1, get useSpecialProjectionForSymbols() {
          return !1;
        }, projectTileCoordinates(o, t, r, s) {
          throw new Error("Not implemented.");
        }, translatePosition: (o, t, r, s) => function(l, h, g, _, A = !1) {
          if (!g[0] && !g[1]) return [0, 0];
          const L = A ? _ === "map" ? l.angle : 0 : _ === "viewport" ? -l.angle : 0;
          if (L) {
            const E = Math.sin(L), M = Math.cos(L);
            g = [g[0] * M - g[1] * E, g[0] * E + g[1] * M];
          }
          return [A ? g[0] : pi(h, g[0], l.zoom), A ? g[1] : pi(h, g[1], l.zoom)];
        }(o, t, r, s), getCircleRadiusCorrection: (o) => 1 };
      }
      class fr {
        constructor(t) {
          this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && !t.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(t, r, s, l, h) {
          const g = this._bucketParts;
          for (; this._currentTileIndex < t.length; ) if (r.getBucketParts(g, l, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, h()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, g.sort((_, A) => _.sortKey - A.sortKey)); this._currentPartIndex < g.length; ) if (r.placeLayerBucketPart(g[this._currentPartIndex], this._seenCrossTileIDs, s), this._currentPartIndex++, h()) return !0;
          return !1;
        }
      }
      class Ji {
        constructor(t, r, s, l, h, g, _, A) {
          this.placement = new Ar(t, Dn(), r, g, _, A), this._currentPlacementIndex = s.length - 1, this._forceFullPlacement = l, this._showCollisionBoxes = h, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t, r, s) {
          const l = O.now(), h = () => !this._forceFullPlacement && O.now() - l > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const g = r[t[this._currentPlacementIndex]], _ = this.placement.collisionIndex.transform.zoom;
            if (g.type === "symbol" && (!g.minzoom || g.minzoom <= _) && (!g.maxzoom || g.maxzoom > _)) {
              if (this._inProgressLayer || (this._inProgressLayer = new fr(g)), this._inProgressLayer.continuePlacement(s[g.source], this.placement, this._showCollisionBoxes, g, h)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(t) {
          return this.placement.commit(t), this.placement;
        }
      }
      const gn = 512 / c.X / 2;
      class sr {
        constructor(t, r, s) {
          this.tileID = t, this.bucketInstanceId = s, this._symbolsByKey = {};
          const l = /* @__PURE__ */ new Map();
          for (let h = 0; h < r.length; h++) {
            const g = r.get(h), _ = g.key, A = l.get(_);
            A ? A.push(g) : l.set(_, [g]);
          }
          for (const [h, g] of l) {
            const _ = { positions: g.map((A) => ({ x: Math.floor(A.anchorX * gn), y: Math.floor(A.anchorY * gn) })), crossTileIDs: g.map((A) => A.crossTileID) };
            if (_.positions.length > 128) {
              const A = new c.av(_.positions.length, 16, Uint16Array);
              for (const { x: L, y: E } of _.positions) A.add(L, E);
              A.finish(), delete _.positions, _.index = A;
            }
            this._symbolsByKey[h] = _;
          }
        }
        getScaledCoordinates(t, r) {
          const { x: s, y: l, z: h } = this.tileID.canonical, { x: g, y: _, z: A } = r.canonical, L = gn / Math.pow(2, A - h), E = (_ * c.X + t.anchorY) * L, M = l * c.X * gn;
          return { x: Math.floor((g * c.X + t.anchorX) * L - s * c.X * gn), y: Math.floor(E - M) };
        }
        findMatches(t, r, s) {
          const l = this.tileID.canonical.z < r.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - r.canonical.z);
          for (let h = 0; h < t.length; h++) {
            const g = t.get(h);
            if (g.crossTileID) continue;
            const _ = this._symbolsByKey[g.key];
            if (!_) continue;
            const A = this.getScaledCoordinates(g, r);
            if (_.index) {
              const L = _.index.range(A.x - l, A.y - l, A.x + l, A.y + l).sort();
              for (const E of L) {
                const M = _.crossTileIDs[E];
                if (!s[M]) {
                  s[M] = !0, g.crossTileID = M;
                  break;
                }
              }
            } else if (_.positions) for (let L = 0; L < _.positions.length; L++) {
              const E = _.positions[L], M = _.crossTileIDs[L];
              if (Math.abs(E.x - A.x) <= l && Math.abs(E.y - A.y) <= l && !s[M]) {
                s[M] = !0, g.crossTileID = M;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: t }) => t);
        }
      }
      class va {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class cn {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(t) {
          const r = Math.round((t - this.lng) / 360);
          if (r !== 0) for (const s in this.indexes) {
            const l = this.indexes[s], h = {};
            for (const g in l) {
              const _ = l[g];
              _.tileID = _.tileID.unwrapTo(_.tileID.wrap + r), h[_.tileID.key] = _;
            }
            this.indexes[s] = h;
          }
          this.lng = t;
        }
        addBucket(t, r, s) {
          if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
            if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === r.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
          }
          for (let h = 0; h < r.symbolInstances.length; h++) r.symbolInstances.get(h).crossTileID = 0;
          this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});
          const l = this.usedCrossTileIDs[t.overscaledZ];
          for (const h in this.indexes) {
            const g = this.indexes[h];
            if (Number(h) > t.overscaledZ) for (const _ in g) {
              const A = g[_];
              A.tileID.isChildOf(t) && A.findMatches(r.symbolInstances, t, l);
            }
            else {
              const _ = g[t.scaledTo(Number(h)).key];
              _ && _.findMatches(r.symbolInstances, t, l);
            }
          }
          for (let h = 0; h < r.symbolInstances.length; h++) {
            const g = r.symbolInstances.get(h);
            g.crossTileID || (g.crossTileID = s.generate(), l[g.crossTileID] = !0);
          }
          return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new sr(t, r.symbolInstances, r.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(t, r) {
          for (const s of r.getCrossTileIDsLists()) for (const l of s) delete this.usedCrossTileIDs[t][l];
        }
        removeStaleBuckets(t) {
          let r = !1;
          for (const s in this.indexes) {
            const l = this.indexes[s];
            for (const h in l) t[l[h].bucketInstanceId] || (this.removeBucketCrossTileIDs(s, l[h]), delete l[h], r = !0);
          }
          return r;
        }
      }
      class Fo {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new va(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(t, r, s) {
          let l = this.layerIndexes[t.id];
          l === void 0 && (l = this.layerIndexes[t.id] = new cn());
          let h = !1;
          const g = {};
          l.handleWrapJump(s);
          for (const _ of r) {
            const A = _.getBucket(t);
            A && t.id === A.layerIds[0] && (A.bucketInstanceId || (A.bucketInstanceId = ++this.maxBucketInstanceId), l.addBucket(_.tileID, A, this.crossTileIDs) && (h = !0), g[A.bucketInstanceId] = !0);
          }
          return l.removeStaleBuckets(g) && (h = !0), h;
        }
        pruneUnusedLayers(t) {
          const r = {};
          t.forEach((s) => {
            r[s] = !0;
          });
          for (const s in this.layerIndexes) r[s] || delete this.layerIndexes[s];
        }
      }
      const _r = (o, t) => c.t(o, t && t.filter((r) => r.identifier !== "source.canvas")), Ga = c.aw();
      class Rr extends c.E {
        constructor(t, r = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const s in this.sourceCaches) {
              const l = this.sourceCaches[s].getSource().type;
              l !== "vector" && l !== "geojson" || this.sourceCaches[s].reload();
            }
          }, this.map = t, this.dispatcher = new we(Gt(), t._getMapId()), this.dispatcher.registerMessageHandler("GG", (s, l) => this.getGlyphs(s, l)), this.dispatcher.registerMessageHandler("GI", (s, l) => this.getImages(s, l)), this.imageManager = new It(), this.imageManager.setEventedParent(this), this.glyphManager = new Ht(t._requestManager, r.localIdeographFontFamily), this.lineAtlas = new pt(256, 512), this.crossTileSymbolIndex = new Fo(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new c.ax(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", c.ay()), Te().on(oe, this._rtlPluginLoaded), this.on("data", (s) => {
            if (s.dataType !== "source" || s.sourceDataType !== "metadata") return;
            const l = this.sourceCaches[s.sourceId];
            if (!l) return;
            const h = l.getSource();
            if (h && h.vectorLayerIds) for (const g in this._layers) {
              const _ = this._layers[g];
              _.source === h.id && this._validateLayer(_);
            }
          });
        }
        loadURL(t, r = {}, s) {
          this.fire(new c.k("dataloading", { dataType: "style" })), r.validate = typeof r.validate != "boolean" || r.validate;
          const l = this.map._requestManager.transformRequest(t, "Style");
          this._loadStyleRequest = new AbortController();
          const h = this._loadStyleRequest;
          c.h(l, this._loadStyleRequest).then((g) => {
            this._loadStyleRequest = null, this._load(g.data, r, s);
          }).catch((g) => {
            this._loadStyleRequest = null, g && !h.signal.aborted && this.fire(new c.j(g));
          });
        }
        loadJSON(t, r = {}, s) {
          this.fire(new c.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), O.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, r.validate = r.validate !== !1, this._load(t, r, s);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new c.k("dataloading", { dataType: "style" })), this._load(Ga, { validate: !1 });
        }
        _load(t, r, s) {
          var l;
          const h = r.transformStyle ? r.transformStyle(s, t) : t;
          if (!r.validate || !_r(this, c.u(h))) {
            this._loaded = !0, this.stylesheet = h;
            for (const g in h.sources) this.addSource(g, h.sources[g], { validate: !1 });
            h.sprite ? this._loadSprite(h.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(h.glyphs), this._createLayers(), this.light = new ie(this.stylesheet.light), this.sky = new K(this.stylesheet.sky), this.map.setTerrain((l = this.stylesheet.terrain) !== null && l !== void 0 ? l : null), this.fire(new c.k("data", { dataType: "style" })), this.fire(new c.k("style.load"));
          }
        }
        _createLayers() {
          const t = c.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", t), this._order = t.map((r) => r.id), this._layers = {}, this._serializedLayers = null;
          for (const r of t) {
            const s = c.aA(r);
            s.setEventedParent(this, { layer: { id: r.id } }), this._layers[r.id] = s;
          }
        }
        _loadSprite(t, r = !1, s = void 0) {
          let l;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(h, g, _, A) {
            return c._(this, void 0, void 0, function* () {
              const L = $t(h), E = _ > 1 ? "@2x" : "", M = {}, R = {};
              for (const { id: q, url: B } of L) {
                const $ = g.transformRequest(ae(B, E, ".json"), "SpriteJSON");
                M[q] = c.h($, A);
                const Q = g.transformRequest(ae(B, E, ".png"), "SpriteImage");
                R[q] = zt.getImage(Q, A);
              }
              return yield Promise.all([...Object.values(M), ...Object.values(R)]), function(q, B) {
                return c._(this, void 0, void 0, function* () {
                  const $ = {};
                  for (const Q in q) {
                    $[Q] = {};
                    const tt = O.getImageCanvasContext((yield B[Q]).data), nt = (yield q[Q]).data;
                    for (const it in nt) {
                      const { width: ht, height: wt, x: _t, y: Vt, sdf: re, pixelRatio: ce, stretchX: de, stretchY: ue, content: he, textFitWidth: fe, textFitHeight: Oe } = nt[it];
                      $[Q][it] = { data: null, pixelRatio: ce, sdf: re, stretchX: de, stretchY: ue, content: he, textFitWidth: fe, textFitHeight: Oe, spriteData: { width: ht, height: wt, x: _t, y: Vt, context: tt } };
                    }
                  }
                  return $;
                });
              }(M, R);
            });
          }(t, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((h) => {
            if (this._spriteRequest = null, h) for (const g in h) {
              this._spritesImagesIds[g] = [];
              const _ = this._spritesImagesIds[g] ? this._spritesImagesIds[g].filter((A) => !(A in h)) : [];
              for (const A of _) this.imageManager.removeImage(A), this._changedImages[A] = !0;
              for (const A in h[g]) {
                const L = g === "default" ? A : `${g}:${A}`;
                this._spritesImagesIds[g].push(L), L in this.imageManager.images ? this.imageManager.updateImage(L, h[g][A], !1) : this.imageManager.addImage(L, h[g][A]), r && (this._changedImages[L] = !0);
              }
            }
          }).catch((h) => {
            this._spriteRequest = null, l = h, this.fire(new c.j(l));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), r && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" })), s && s(l);
          });
        }
        _unloadSprite() {
          for (const t of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t), this._changedImages[t] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" }));
        }
        _validateLayer(t) {
          const r = this.sourceCaches[t.source];
          if (!r) return;
          const s = t.sourceLayer;
          if (!s) return;
          const l = r.getSource();
          (l.type === "geojson" || l.vectorLayerIds && l.vectorLayerIds.indexOf(s) === -1) && this.fire(new c.j(new Error(`Source layer "${s}" does not exist on source "${l.id}" as specified by style layer "${t.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const t in this.sourceCaches) if (!this.sourceCaches[t].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(t, r = !1) {
          const s = this._serializedAllLayers();
          if (!t || t.length === 0) return Object.values(r ? c.aB(s) : s);
          const l = [];
          for (const h of t) if (s[h]) {
            const g = r ? c.aB(s[h]) : s[h];
            l.push(g);
          }
          return l;
        }
        _serializedAllLayers() {
          let t = this._serializedLayers;
          if (t) return t;
          t = this._serializedLayers = {};
          const r = Object.keys(this._layers);
          for (const s of r) {
            const l = this._layers[s];
            l.type !== "custom" && (t[s] = l.serialize());
          }
          return t;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition() || this.sky && this.sky.hasTransition()) return !0;
          for (const t in this.sourceCaches) if (this.sourceCaches[t].hasTransition()) return !0;
          for (const t in this._layers) if (this._layers[t].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(t) {
          if (!this._loaded) return;
          const r = this._changed;
          if (r) {
            const l = Object.keys(this._updatedLayers), h = Object.keys(this._removedLayers);
            (l.length || h.length) && this._updateWorkerLayers(l, h);
            for (const g in this._updatedSources) {
              const _ = this._updatedSources[g];
              if (_ === "reload") this._reloadSource(g);
              else {
                if (_ !== "clear") throw new Error(`Invalid action ${_}`);
                this._clearSource(g);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const g in this._updatedPaintProps) this._layers[g].updateTransitions(t);
            this.light.updateTransitions(t), this.sky.updateTransitions(t), this._resetUpdates();
          }
          const s = {};
          for (const l in this.sourceCaches) {
            const h = this.sourceCaches[l];
            s[l] = h.used, h.used = !1;
          }
          for (const l of this._order) {
            const h = this._layers[l];
            h.recalculate(t, this._availableImages), !h.isHidden(t.zoom) && h.source && (this.sourceCaches[h.source].used = !0);
          }
          for (const l in s) {
            const h = this.sourceCaches[l];
            !!s[l] != !!h.used && h.fire(new c.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: l }));
          }
          this.light.recalculate(t), this.sky.recalculate(t), this.z = t.zoom, r && this.fire(new c.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const t = Object.keys(this._changedImages);
          if (t.length) {
            for (const r in this.sourceCaches) this.sourceCaches[r].reloadTilesForDependencies(["icons", "patterns"], t);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const t in this.sourceCaches) this.sourceCaches[t].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(t, r) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t, !1), removedIds: r });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(t, r = {}) {
          var s;
          this._checkLoaded();
          const l = this.serialize();
          if (t = r.transformStyle ? r.transformStyle(l, t) : t, ((s = r.validate) === null || s === void 0 || s) && _r(this, c.u(t))) return !1;
          (t = c.aB(t)).layers = c.az(t.layers);
          const h = c.aC(l, t), g = this._getOperationsToPerform(h);
          if (g.unimplemented.length > 0) throw new Error(`Unimplemented: ${g.unimplemented.join(", ")}.`);
          if (g.operations.length === 0) return !1;
          for (const _ of g.operations) _();
          return this.stylesheet = t, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(t) {
          const r = [], s = [];
          for (const l of t) switch (l.command) {
            case "setCenter":
            case "setZoom":
            case "setBearing":
            case "setPitch":
              continue;
            case "addLayer":
              r.push(() => this.addLayer.apply(this, l.args));
              break;
            case "removeLayer":
              r.push(() => this.removeLayer.apply(this, l.args));
              break;
            case "setPaintProperty":
              r.push(() => this.setPaintProperty.apply(this, l.args));
              break;
            case "setLayoutProperty":
              r.push(() => this.setLayoutProperty.apply(this, l.args));
              break;
            case "setFilter":
              r.push(() => this.setFilter.apply(this, l.args));
              break;
            case "addSource":
              r.push(() => this.addSource.apply(this, l.args));
              break;
            case "removeSource":
              r.push(() => this.removeSource.apply(this, l.args));
              break;
            case "setLayerZoomRange":
              r.push(() => this.setLayerZoomRange.apply(this, l.args));
              break;
            case "setLight":
              r.push(() => this.setLight.apply(this, l.args));
              break;
            case "setGeoJSONSourceData":
              r.push(() => this.setGeoJSONSourceData.apply(this, l.args));
              break;
            case "setGlyphs":
              r.push(() => this.setGlyphs.apply(this, l.args));
              break;
            case "setSprite":
              r.push(() => this.setSprite.apply(this, l.args));
              break;
            case "setSky":
              r.push(() => this.setSky.apply(this, l.args));
              break;
            case "setTerrain":
              r.push(() => this.map.setTerrain.apply(this, l.args));
              break;
            case "setTransition":
              r.push(() => {
              });
              break;
            default:
              s.push(l.command);
          }
          return { operations: r, unimplemented: s };
        }
        addImage(t, r) {
          if (this.getImage(t)) return this.fire(new c.j(new Error(`An image named "${t}" already exists.`)));
          this.imageManager.addImage(t, r), this._afterImageUpdated(t);
        }
        updateImage(t, r) {
          this.imageManager.updateImage(t, r);
        }
        getImage(t) {
          return this.imageManager.getImage(t);
        }
        removeImage(t) {
          if (!this.getImage(t)) return this.fire(new c.j(new Error(`An image named "${t}" does not exist.`)));
          this.imageManager.removeImage(t), this._afterImageUpdated(t);
        }
        _afterImageUpdated(t) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(t, r, s = {}) {
          if (this._checkLoaded(), this.sourceCaches[t] !== void 0) throw new Error(`Source "${t}" already exists.`);
          if (!r.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(r).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(r.type) >= 0 && this._validate(c.u.source, `sources.${t}`, r, null, s)) return;
          this.map && this.map._collectResourceTiming && (r.collectResourceTiming = !0);
          const l = this.sourceCaches[t] = new Ce(t, r, this.dispatcher);
          l.style = this, l.setEventedParent(this, () => ({ isSourceLoaded: l.loaded(), source: l.serialize(), sourceId: t })), l.onAdd(this.map), this._changed = !0;
        }
        removeSource(t) {
          if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error("There is no source with this ID");
          for (const s in this._layers) if (this._layers[s].source === t) return this.fire(new c.j(new Error(`Source "${t}" cannot be removed while layer "${s}" is using it.`)));
          const r = this.sourceCaches[t];
          delete this.sourceCaches[t], delete this._updatedSources[t], r.fire(new c.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), r.setEventedParent(null), r.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(t, r) {
          if (this._checkLoaded(), this.sourceCaches[t] === void 0) throw new Error(`There is no source with this ID=${t}`);
          const s = this.sourceCaches[t].getSource();
          if (s.type !== "geojson") throw new Error(`geojsonSource.type is ${s.type}, which is !== 'geojson`);
          s.setData(r), this._changed = !0;
        }
        getSource(t) {
          return this.sourceCaches[t] && this.sourceCaches[t].getSource();
        }
        addLayer(t, r, s = {}) {
          this._checkLoaded();
          const l = t.id;
          if (this.getLayer(l)) return void this.fire(new c.j(new Error(`Layer "${l}" already exists on this map.`)));
          let h;
          if (t.type === "custom") {
            if (_r(this, c.aD(t))) return;
            h = c.aA(t);
          } else {
            if ("source" in t && typeof t.source == "object" && (this.addSource(l, t.source), t = c.aB(t), t = c.e(t, { source: l })), this._validate(c.u.layer, `layers.${l}`, t, { arrayIndex: -1 }, s)) return;
            h = c.aA(t), this._validateLayer(h), h.setEventedParent(this, { layer: { id: l } });
          }
          const g = r ? this._order.indexOf(r) : this._order.length;
          if (r && g === -1) this.fire(new c.j(new Error(`Cannot add layer "${l}" before non-existing layer "${r}".`)));
          else {
            if (this._order.splice(g, 0, l), this._layerOrderChanged = !0, this._layers[l] = h, this._removedLayers[l] && h.source && h.type !== "custom") {
              const _ = this._removedLayers[l];
              delete this._removedLayers[l], _.type !== h.type ? this._updatedSources[h.source] = "clear" : (this._updatedSources[h.source] = "reload", this.sourceCaches[h.source].pause());
            }
            this._updateLayer(h), h.onAdd && h.onAdd(this.map);
          }
        }
        moveLayer(t, r) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new c.j(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
          if (t === r) return;
          const s = this._order.indexOf(t);
          this._order.splice(s, 1);
          const l = r ? this._order.indexOf(r) : this._order.length;
          r && l === -1 ? this.fire(new c.j(new Error(`Cannot move layer "${t}" before non-existing layer "${r}".`))) : (this._order.splice(l, 0, t), this._layerOrderChanged = !0);
        }
        removeLayer(t) {
          this._checkLoaded();
          const r = this._layers[t];
          if (!r) return void this.fire(new c.j(new Error(`Cannot remove non-existing layer "${t}".`)));
          r.setEventedParent(null);
          const s = this._order.indexOf(t);
          this._order.splice(s, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = r, delete this._layers[t], this._serializedLayers && delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], r.onRemove && r.onRemove(this.map);
        }
        getLayer(t) {
          return this._layers[t];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(t) {
          return t in this._layers;
        }
        setLayerZoomRange(t, r, s) {
          this._checkLoaded();
          const l = this.getLayer(t);
          l ? l.minzoom === r && l.maxzoom === s || (r != null && (l.minzoom = r), s != null && (l.maxzoom = s), this._updateLayer(l)) : this.fire(new c.j(new Error(`Cannot set the zoom range of non-existing layer "${t}".`)));
        }
        setFilter(t, r, s = {}) {
          this._checkLoaded();
          const l = this.getLayer(t);
          if (l) {
            if (!c.aE(l.filter, r)) return r == null ? (l.filter = void 0, void this._updateLayer(l)) : void (this._validate(c.u.filter, `layers.${l.id}.filter`, r, null, s) || (l.filter = c.aB(r), this._updateLayer(l)));
          } else this.fire(new c.j(new Error(`Cannot filter non-existing layer "${t}".`)));
        }
        getFilter(t) {
          return c.aB(this.getLayer(t).filter);
        }
        setLayoutProperty(t, r, s, l = {}) {
          this._checkLoaded();
          const h = this.getLayer(t);
          h ? c.aE(h.getLayoutProperty(r), s) || (h.setLayoutProperty(r, s, l), this._updateLayer(h)) : this.fire(new c.j(new Error(`Cannot style non-existing layer "${t}".`)));
        }
        getLayoutProperty(t, r) {
          const s = this.getLayer(t);
          if (s) return s.getLayoutProperty(r);
          this.fire(new c.j(new Error(`Cannot get style of non-existing layer "${t}".`)));
        }
        setPaintProperty(t, r, s, l = {}) {
          this._checkLoaded();
          const h = this.getLayer(t);
          h ? c.aE(h.getPaintProperty(r), s) || (h.setPaintProperty(r, s, l) && this._updateLayer(h), this._changed = !0, this._updatedPaintProps[t] = !0, this._serializedLayers = null) : this.fire(new c.j(new Error(`Cannot style non-existing layer "${t}".`)));
        }
        getPaintProperty(t, r) {
          return this.getLayer(t).getPaintProperty(r);
        }
        setFeatureState(t, r) {
          this._checkLoaded();
          const s = t.source, l = t.sourceLayer, h = this.sourceCaches[s];
          if (h === void 0) return void this.fire(new c.j(new Error(`The source '${s}' does not exist in the map's style.`)));
          const g = h.getSource().type;
          g === "geojson" && l ? this.fire(new c.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : g !== "vector" || l ? (t.id === void 0 && this.fire(new c.j(new Error("The feature id parameter must be provided."))), h.setFeatureState(l, t.id, r)) : this.fire(new c.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(t, r) {
          this._checkLoaded();
          const s = t.source, l = this.sourceCaches[s];
          if (l === void 0) return void this.fire(new c.j(new Error(`The source '${s}' does not exist in the map's style.`)));
          const h = l.getSource().type, g = h === "vector" ? t.sourceLayer : void 0;
          h !== "vector" || g ? r && typeof t.id != "string" && typeof t.id != "number" ? this.fire(new c.j(new Error("A feature id is required to remove its specific state property."))) : l.removeFeatureState(g, t.id, r) : this.fire(new c.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(t) {
          this._checkLoaded();
          const r = t.source, s = t.sourceLayer, l = this.sourceCaches[r];
          if (l !== void 0) return l.getSource().type !== "vector" || s ? (t.id === void 0 && this.fire(new c.j(new Error("The feature id parameter must be provided."))), l.getFeatureState(s, t.id)) : void this.fire(new c.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new c.j(new Error(`The source '${r}' does not exist in the map's style.`)));
        }
        getTransition() {
          return c.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const t = c.aF(this.sourceCaches, (h) => h.serialize()), r = this._serializeByIds(this._order, !0), s = this.map.getTerrain() || void 0, l = this.stylesheet;
          return c.aG({ version: l.version, name: l.name, metadata: l.metadata, light: l.light, sky: l.sky, center: l.center, zoom: l.zoom, bearing: l.bearing, pitch: l.pitch, sprite: l.sprite, glyphs: l.glyphs, transition: l.transition, sources: t, layers: r, terrain: s }, (h) => h !== void 0);
        }
        _updateLayer(t) {
          this._updatedLayers[t.id] = !0, t.source && !this._updatedSources[t.source] && this.sourceCaches[t.source].getSource().type !== "raster" && (this._updatedSources[t.source] = "reload", this.sourceCaches[t.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(t) {
          const r = (g) => this._layers[g].type === "fill-extrusion", s = {}, l = [];
          for (let g = this._order.length - 1; g >= 0; g--) {
            const _ = this._order[g];
            if (r(_)) {
              s[_] = g;
              for (const A of t) {
                const L = A[_];
                if (L) for (const E of L) l.push(E);
              }
            }
          }
          l.sort((g, _) => _.intersectionZ - g.intersectionZ);
          const h = [];
          for (let g = this._order.length - 1; g >= 0; g--) {
            const _ = this._order[g];
            if (r(_)) for (let A = l.length - 1; A >= 0; A--) {
              const L = l[A].feature;
              if (s[L.layer.id] < g) break;
              h.push(L), l.pop();
            }
            else for (const A of t) {
              const L = A[_];
              if (L) for (const E of L) h.push(E.feature);
            }
          }
          return h;
        }
        queryRenderedFeatures(t, r, s) {
          r && r.filter && this._validate(c.u.filter, "queryRenderedFeatures.filter", r.filter, null, r);
          const l = {};
          if (r && r.layers) {
            if (!Array.isArray(r.layers)) return this.fire(new c.j(new Error("parameters.layers must be an Array."))), [];
            for (const _ of r.layers) {
              const A = this._layers[_];
              if (!A) return this.fire(new c.j(new Error(`The layer '${_}' does not exist in the map's style and cannot be queried for features.`))), [];
              l[A.source] = !0;
            }
          }
          const h = [];
          r.availableImages = this._availableImages;
          const g = this._serializedAllLayers();
          for (const _ in this.sourceCaches) r.layers && !l[_] || h.push(Pe(this.sourceCaches[_], this._layers, g, t, r, s));
          return this.placement && h.push(function(_, A, L, E, M, R, q) {
            const B = {}, $ = R.queryRenderedSymbols(E), Q = [];
            for (const tt of Object.keys($).map(Number)) Q.push(q[tt]);
            Q.sort(ti);
            for (const tt of Q) {
              const nt = tt.featureIndex.lookupSymbolFeatures($[tt.bucketInstanceId], A, tt.bucketIndex, tt.sourceLayerIndex, M.filter, M.layers, M.availableImages, _);
              for (const it in nt) {
                const ht = B[it] = B[it] || [], wt = nt[it];
                wt.sort((_t, Vt) => {
                  const re = tt.featureSortOrder;
                  if (re) {
                    const ce = re.indexOf(_t.featureIndex);
                    return re.indexOf(Vt.featureIndex) - ce;
                  }
                  return Vt.featureIndex - _t.featureIndex;
                });
                for (const _t of wt) ht.push(_t);
              }
            }
            for (const tt in B) B[tt].forEach((nt) => {
              const it = nt.feature, ht = L[_[tt].source].getFeatureState(it.layer["source-layer"], it.id);
              it.source = it.layer.source, it.layer["source-layer"] && (it.sourceLayer = it.layer["source-layer"]), it.state = ht;
            });
            return B;
          }(this._layers, g, this.sourceCaches, t, r, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(h);
        }
        querySourceFeatures(t, r) {
          r && r.filter && this._validate(c.u.filter, "querySourceFeatures.filter", r.filter, null, r);
          const s = this.sourceCaches[t];
          return s ? function(l, h) {
            const g = l.getRenderableIds().map((L) => l.getTileByID(L)), _ = [], A = {};
            for (let L = 0; L < g.length; L++) {
              const E = g[L], M = E.tileID.canonical.key;
              A[M] || (A[M] = !0, E.querySourceFeatures(_, h));
            }
            return _;
          }(s, r) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(t, r = {}) {
          this._checkLoaded();
          const s = this.light.getLight();
          let l = !1;
          for (const g in t) if (!c.aE(t[g], s[g])) {
            l = !0;
            break;
          }
          if (!l) return;
          const h = { now: O.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(t, r), this.light.updateTransitions(h);
        }
        getSky() {
          var t;
          return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.sky;
        }
        setSky(t, r = {}) {
          const s = this.getSky();
          let l = !1;
          if (!t && !s) return;
          if (t && !s) l = !0;
          else if (!t && s) l = !0;
          else for (const g in t) if (!c.aE(t[g], s[g])) {
            l = !0;
            break;
          }
          if (!l) return;
          const h = { now: O.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = t, this.sky.setSky(t, r), this.sky.updateTransitions(h);
        }
        _validate(t, r, s, l, h = {}) {
          return (!h || h.validate !== !1) && _r(this, t.call(c.u, c.e({ key: r, style: this.serialize(), value: s, styleSpec: c.v }, l)));
        }
        _remove(t = !0) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Te().off(oe, this._rtlPluginLoaded);
          for (const r in this._layers) this._layers[r].setEventedParent(null);
          for (const r in this.sourceCaches) {
            const s = this.sourceCaches[r];
            s.setEventedParent(null), s.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), t && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t);
        }
        _clearSource(t) {
          this.sourceCaches[t].clearTiles();
        }
        _reloadSource(t) {
          this.sourceCaches[t].resume(), this.sourceCaches[t].reload();
        }
        _updateSources(t) {
          for (const r in this.sourceCaches) this.sourceCaches[r].update(t, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const t in this.sourceCaches) this._reloadSource(t);
        }
        _updatePlacement(t, r, s, l, h = !1) {
          let g = !1, _ = !1;
          const A = {};
          for (const L of this._order) {
            const E = this._layers[L];
            if (E.type !== "symbol") continue;
            if (!A[E.source]) {
              const R = this.sourceCaches[E.source];
              A[E.source] = R.getRenderableIds(!0).map((q) => R.getTileByID(q)).sort((q, B) => B.tileID.overscaledZ - q.tileID.overscaledZ || (q.tileID.isLessThan(B.tileID) ? -1 : 1));
            }
            const M = this.crossTileSymbolIndex.addLayer(E, A[E.source], t.center.lng);
            g = g || M;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((h = h || this._layerOrderChanged || s === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(O.now(), t.zoom)) && (this.pauseablePlacement = new Ji(t, this.map.terrain, this._order, h, r, s, l, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, A), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(O.now()), _ = !0), g && this.pauseablePlacement.placement.setStale()), _ || g) for (const L of this._order) {
            const E = this._layers[L];
            E.type === "symbol" && this.placement.updateLayerOpacities(E, A[E.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(O.now());
        }
        _releaseSymbolFadeTiles() {
          for (const t in this.sourceCaches) this.sourceCaches[t].releaseSymbolFadeTiles();
        }
        getImages(t, r) {
          return c._(this, void 0, void 0, function* () {
            const s = yield this.imageManager.getImages(r.icons);
            this._updateTilesForChangedImages();
            const l = this.sourceCaches[r.source];
            return l && l.setDependencies(r.tileID.key, r.type, r.icons), s;
          });
        }
        getGlyphs(t, r) {
          return c._(this, void 0, void 0, function* () {
            const s = yield this.glyphManager.getGlyphs(r.stacks), l = this.sourceCaches[r.source];
            return l && l.setDependencies(r.tileID.key, r.type, [""]), s;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(t, r = {}) {
          this._checkLoaded(), t && this._validate(c.u.glyphs, "glyphs", t, null, r) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = t, this.glyphManager.entries = {}, this.glyphManager.setURL(t));
        }
        addSprite(t, r, s = {}, l) {
          this._checkLoaded();
          const h = [{ id: t, url: r }], g = [...$t(this.stylesheet.sprite), ...h];
          this._validate(c.u.sprite, "sprite", g, null, s) || (this.stylesheet.sprite = g, this._loadSprite(h, !0, l));
        }
        removeSprite(t) {
          this._checkLoaded();
          const r = $t(this.stylesheet.sprite);
          if (r.find((s) => s.id === t)) {
            if (this._spritesImagesIds[t]) for (const s of this._spritesImagesIds[t]) this.imageManager.removeImage(s), this._changedImages[s] = !0;
            r.splice(r.findIndex((s) => s.id === t), 1), this.stylesheet.sprite = r.length > 0 ? r : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.k("data", { dataType: "style" }));
          } else this.fire(new c.j(new Error(`Sprite "${t}" doesn't exists on this map.`)));
        }
        getSprite() {
          return $t(this.stylesheet.sprite);
        }
        setSprite(t, r = {}, s) {
          this._checkLoaded(), t && this._validate(c.u.sprite, "sprite", t, null, r) || (this.stylesheet.sprite = t, t ? this._loadSprite(t, !0, s) : (this._unloadSprite(), s && s(null)));
        }
      }
      var Jn = c.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const Qn = { prelude: Fi(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: Fi(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: Fi(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Fi(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Fi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Fi(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,get_elevation(floor(a_pos*0.5)),1);gl_Position=u_matrix*pos;}`), heatmapTexture: Fi(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Fi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Fi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Fi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: Fi(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: Fi(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: Fi(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: Fi(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Fi(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Fi(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Fi(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Fi(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: Fi(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Fi(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Fi(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Fi(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Fi(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: Fi(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Fi(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Fi(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Fi("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Fi("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Fi("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: Fi("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function Fi(o, t) {
        const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s = t.match(/attribute ([\w]+) ([\w]+)/g), l = o.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), h = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), g = h ? h.concat(l) : l, _ = {};
        return { fragmentSource: o = o.replace(r, (A, L, E, M, R) => (_[R] = !0, L === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
varying ${E} ${M} ${R};
#else
uniform ${E} ${M} u_${R};
#endif
` : `
#ifdef HAS_UNIFORM_u_${R}
    ${E} ${M} ${R} = u_${R};
#endif
`)), vertexSource: t = t.replace(r, (A, L, E, M, R) => {
          const q = M === "float" ? "vec2" : "vec4", B = R.match(/color/) ? "color" : q;
          return _[R] ? L === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
attribute ${E} ${q} a_${R};
varying ${E} ${M} ${R};
#else
uniform ${E} ${M} u_${R};
#endif
` : B === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = a_${R};
#else
    ${E} ${M} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${R} = unpack_mix_${B}(a_${R}, u_${R}_t);
#else
    ${E} ${M} ${R} = u_${R};
#endif
` : L === "define" ? `
#ifndef HAS_UNIFORM_u_${R}
uniform lowp float u_${R}_t;
attribute ${E} ${q} a_${R};
#else
uniform ${E} ${M} u_${R};
#endif
` : B === "vec4" ? `
#ifndef HAS_UNIFORM_u_${R}
    ${E} ${M} ${R} = a_${R};
#else
    ${E} ${M} ${R} = u_${R};
#endif
` : `
#ifndef HAS_UNIFORM_u_${R}
    ${E} ${M} ${R} = unpack_mix_${B}(a_${R}, u_${R}_t);
#else
    ${E} ${M} ${R} = u_${R};
#endif
`;
        }), staticAttributes: s, staticUniforms: g };
      }
      class $a {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(t, r, s, l, h, g, _, A, L) {
          this.context = t;
          let E = this.boundPaintVertexBuffers.length !== l.length;
          for (let M = 0; !E && M < l.length; M++) this.boundPaintVertexBuffers[M] !== l[M] && (E = !0);
          !this.vao || this.boundProgram !== r || this.boundLayoutVertexBuffer !== s || E || this.boundIndexBuffer !== h || this.boundVertexOffset !== g || this.boundDynamicVertexBuffer !== _ || this.boundDynamicVertexBuffer2 !== A || this.boundDynamicVertexBuffer3 !== L ? this.freshBind(r, s, l, h, g, _, A, L) : (t.bindVertexArray.set(this.vao), _ && _.bind(), h && h.dynamicDraw && h.bind(), A && A.bind(), L && L.bind());
        }
        freshBind(t, r, s, l, h, g, _, A) {
          const L = t.numAttributes, E = this.context, M = E.gl;
          this.vao && this.destroy(), this.vao = E.createVertexArray(), E.bindVertexArray.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = r, this.boundPaintVertexBuffers = s, this.boundIndexBuffer = l, this.boundVertexOffset = h, this.boundDynamicVertexBuffer = g, this.boundDynamicVertexBuffer2 = _, this.boundDynamicVertexBuffer3 = A, r.enableAttributes(M, t);
          for (const R of s) R.enableAttributes(M, t);
          g && g.enableAttributes(M, t), _ && _.enableAttributes(M, t), A && A.enableAttributes(M, t), r.bind(), r.setVertexAttribPointers(M, t, h);
          for (const R of s) R.bind(), R.setVertexAttribPointers(M, t, h);
          g && (g.bind(), g.setVertexAttribPointers(M, t, h)), l && l.bind(), _ && (_.bind(), _.setVertexAttribPointers(M, t, h)), A && (A.bind(), A.setVertexAttribPointers(M, t, h)), E.currentNumAttributes = L;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const Bo = (o, t, r, s, l) => ({ u_matrix: o, u_texture: 0, u_ele_delta: t, u_fog_matrix: r, u_fog_color: s ? s.properties.get("fog-color") : c.aM.white, u_fog_ground_blend: s ? s.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: s ? s.calculateFogBlendOpacity(l) : 0, u_horizon_color: s ? s.properties.get("horizon-color") : c.aM.white, u_horizon_fog_blend: s ? s.properties.get("horizon-fog-blend") : 1 });
      function zs(o) {
        const t = [];
        for (let r = 0; r < o.length; r++) {
          if (o[r] === null) continue;
          const s = o[r].split(" ");
          t.push(s.pop());
        }
        return t;
      }
      class Ro {
        constructor(t, r, s, l, h, g) {
          const _ = t.gl;
          this.program = _.createProgram();
          const A = zs(r.staticAttributes), L = s ? s.getBinderAttributes() : [], E = A.concat(L), M = Qn.prelude.staticUniforms ? zs(Qn.prelude.staticUniforms) : [], R = r.staticUniforms ? zs(r.staticUniforms) : [], q = s ? s.getBinderUniforms() : [], B = M.concat(R).concat(q), $ = [];
          for (const _t of B) $.indexOf(_t) < 0 && $.push(_t);
          const Q = s ? s.defines() : [];
          h && Q.push("#define OVERDRAW_INSPECTOR;"), g && Q.push("#define TERRAIN3D;");
          const tt = Q.concat(Qn.prelude.fragmentSource, r.fragmentSource).join(`
`), nt = Q.concat(Qn.prelude.vertexSource, r.vertexSource).join(`
`), it = _.createShader(_.FRAGMENT_SHADER);
          if (_.isContextLost()) return void (this.failedToCreate = !0);
          if (_.shaderSource(it, tt), _.compileShader(it), !_.getShaderParameter(it, _.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${_.getShaderInfoLog(it)}`);
          _.attachShader(this.program, it);
          const ht = _.createShader(_.VERTEX_SHADER);
          if (_.isContextLost()) return void (this.failedToCreate = !0);
          if (_.shaderSource(ht, nt), _.compileShader(ht), !_.getShaderParameter(ht, _.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${_.getShaderInfoLog(ht)}`);
          _.attachShader(this.program, ht), this.attributes = {};
          const wt = {};
          this.numAttributes = E.length;
          for (let _t = 0; _t < this.numAttributes; _t++) E[_t] && (_.bindAttribLocation(this.program, _t, E[_t]), this.attributes[E[_t]] = _t);
          if (_.linkProgram(this.program), !_.getProgramParameter(this.program, _.LINK_STATUS)) throw new Error(`Program failed to link: ${_.getProgramInfoLog(this.program)}`);
          _.deleteShader(ht), _.deleteShader(it);
          for (let _t = 0; _t < $.length; _t++) {
            const Vt = $[_t];
            if (Vt && !wt[Vt]) {
              const re = _.getUniformLocation(this.program, Vt);
              re && (wt[Vt] = re);
            }
          }
          this.fixedUniforms = l(t, wt), this.terrainUniforms = ((_t, Vt) => ({ u_depth: new c.aH(_t, Vt.u_depth), u_terrain: new c.aH(_t, Vt.u_terrain), u_terrain_dim: new c.aI(_t, Vt.u_terrain_dim), u_terrain_matrix: new c.aJ(_t, Vt.u_terrain_matrix), u_terrain_unpack: new c.aK(_t, Vt.u_terrain_unpack), u_terrain_exaggeration: new c.aI(_t, Vt.u_terrain_exaggeration) }))(t, wt), this.binderUniforms = s ? s.getUniforms(t, wt) : [];
        }
        draw(t, r, s, l, h, g, _, A, L, E, M, R, q, B, $, Q, tt, nt) {
          const it = t.gl;
          if (this.failedToCreate) return;
          if (t.program.set(this.program), t.setDepthMode(s), t.setStencilMode(l), t.setColorMode(h), t.setCullFace(g), A) {
            t.activeTexture.set(it.TEXTURE2), it.bindTexture(it.TEXTURE_2D, A.depthTexture), t.activeTexture.set(it.TEXTURE3), it.bindTexture(it.TEXTURE_2D, A.texture);
            for (const wt in this.terrainUniforms) this.terrainUniforms[wt].set(A[wt]);
          }
          for (const wt in this.fixedUniforms) this.fixedUniforms[wt].set(_[wt]);
          $ && $.setUniforms(t, this.binderUniforms, q, { zoom: B });
          let ht = 0;
          switch (r) {
            case it.LINES:
              ht = 2;
              break;
            case it.TRIANGLES:
              ht = 3;
              break;
            case it.LINE_STRIP:
              ht = 1;
          }
          for (const wt of R.get()) {
            const _t = wt.vaos || (wt.vaos = {});
            (_t[L] || (_t[L] = new $a())).bind(t, this, E, $ ? $.getPaintVertexBuffers() : [], M, wt.vertexOffset, Q, tt, nt), it.drawElements(r, wt.primitiveLength * ht, it.UNSIGNED_SHORT, wt.primitiveOffset * ht * 2);
          }
        }
      }
      function Qs(o, t, r) {
        const s = 1 / pi(r, 1, t.transform.tileZoom), l = Math.pow(2, r.tileID.overscaledZ), h = r.tileSize * Math.pow(2, t.transform.tileZoom) / l, g = h * (r.tileID.canonical.x + r.tileID.wrap * l), _ = h * r.tileID.canonical.y;
        return { u_image: 0, u_texsize: r.imageAtlasTexture.size, u_scale: [s, o.fromScale, o.toScale], u_fade: o.t, u_pixel_coord_upper: [g >> 16, _ >> 16], u_pixel_coord_lower: [65535 & g, 65535 & _] };
      }
      const xa = (o, t, r, s) => {
        const l = t.style.light, h = l.properties.get("position"), g = [h.x, h.y, h.z], _ = function() {
          var L = new c.A(9);
          return c.A != Float32Array && (L[1] = 0, L[2] = 0, L[3] = 0, L[5] = 0, L[6] = 0, L[7] = 0), L[0] = 1, L[4] = 1, L[8] = 1, L;
        }();
        l.properties.get("anchor") === "viewport" && function(L, E) {
          var M = Math.sin(E), R = Math.cos(E);
          L[0] = R, L[1] = M, L[2] = 0, L[3] = -M, L[4] = R, L[5] = 0, L[6] = 0, L[7] = 0, L[8] = 1;
        }(_, -t.transform.angle), function(L, E, M) {
          var R = E[0], q = E[1], B = E[2];
          L[0] = R * M[0] + q * M[3] + B * M[6], L[1] = R * M[1] + q * M[4] + B * M[7], L[2] = R * M[2] + q * M[5] + B * M[8];
        }(g, g, _);
        const A = l.properties.get("color");
        return { u_matrix: o, u_lightpos: g, u_lightintensity: l.properties.get("intensity"), u_lightcolor: [A.r, A.g, A.b], u_vertical_gradient: +r, u_opacity: s };
      }, Za = (o, t, r, s, l, h, g) => c.e(xa(o, t, r, s), Qs(h, t, g), { u_height_factor: -Math.pow(2, l.overscaledZ) / g.tileSize / 8 }), ta = (o) => ({ u_matrix: o }), fs = (o, t, r, s) => c.e(ta(o), Qs(r, t, s)), Wa = (o, t) => ({ u_matrix: o, u_world: t }), ba = (o, t, r, s, l) => c.e(fs(o, t, r, s), { u_world: l }), cl = (o, t, r, s) => {
        const l = o.transform;
        let h, g;
        if (s.paint.get("circle-pitch-alignment") === "map") {
          const _ = pi(r, 1, l.zoom);
          h = !0, g = [_, _];
        } else h = !1, g = l.pixelsToGLUnits;
        return { u_camera_to_center_distance: l.cameraToCenterDistance, u_scale_with_map: +(s.paint.get("circle-pitch-scale") === "map"), u_matrix: o.translatePosMatrix(t.posMatrix, r, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")), u_pitch_with_map: +h, u_device_pixel_ratio: o.pixelRatio, u_extrude_scale: g };
      }, mr = (o, t, r) => ({ u_matrix: o, u_inv_matrix: t, u_camera_to_center_distance: r.cameraToCenterDistance, u_viewport_size: [r.width, r.height] }), wa = (o, t, r = 1) => ({ u_matrix: o, u_color: t, u_overlay: 0, u_overlay_scale: r }), Or = (o) => ({ u_matrix: o }), He = (o, t, r, s) => ({ u_matrix: o, u_extrude_scale: pi(t, 1, r), u_intensity: s }), Xa = (o, t, r, s) => {
        const l = c.H();
        c.aP(l, 0, o.width, o.height, 0, 0, 1);
        const h = o.context.gl;
        return { u_matrix: l, u_world: [h.drawingBufferWidth, h.drawingBufferHeight], u_image: r, u_color_ramp: s, u_opacity: t.paint.get("heatmap-opacity") };
      };
      function Ha(o, t) {
        const r = Math.pow(2, t.canonical.z), s = t.canonical.y;
        return [new c.Z(0, s / r).toLngLat().lat, new c.Z(0, (s + 1) / r).toLngLat().lat];
      }
      const An = (o, t, r, s) => {
        const l = o.transform;
        return { u_matrix: hl(o, t, r, s), u_ratio: 1 / pi(t, 1, l.zoom), u_device_pixel_ratio: o.pixelRatio, u_units_to_pixels: [1 / l.pixelsToGLUnits[0], 1 / l.pixelsToGLUnits[1]] };
      }, Oo = (o, t, r, s, l) => c.e(An(o, t, r, l), { u_image: 0, u_image_height: s }), Ns = (o, t, r, s, l) => {
        const h = o.transform, g = Ka(t, h);
        return { u_matrix: hl(o, t, r, l), u_texsize: t.imageAtlasTexture.size, u_ratio: 1 / pi(t, 1, h.zoom), u_device_pixel_ratio: o.pixelRatio, u_image: 0, u_scale: [g, s.fromScale, s.toScale], u_fade: s.t, u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]] };
      }, Ya = (o, t, r, s, l, h) => {
        const g = o.lineAtlas, _ = Ka(t, o.transform), A = r.layout.get("line-cap") === "round", L = g.getDash(s.from, A), E = g.getDash(s.to, A), M = L.width * l.fromScale, R = E.width * l.toScale;
        return c.e(An(o, t, r, h), { u_patternscale_a: [_ / M, -L.height / 2], u_patternscale_b: [_ / R, -E.height / 2], u_sdfgamma: g.width / (256 * Math.min(M, R) * o.pixelRatio) / 2, u_image: 0, u_tex_y_a: L.y, u_tex_y_b: E.y, u_mix: l.t });
      };
      function Ka(o, t) {
        return 1 / pi(o, 1, t.tileZoom);
      }
      function hl(o, t, r, s) {
        return o.translatePosMatrix(s ? s.posMatrix : t.tileID.posMatrix, t, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
      }
      const El = (o, t, r, s, l) => {
        return { u_matrix: o, u_tl_parent: t, u_scale_parent: r, u_buffer_scale: 1, u_fade_t: s.mix, u_opacity: s.opacity * l.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: l.paint.get("raster-brightness-min"), u_brightness_high: l.paint.get("raster-brightness-max"), u_saturation_factor: (g = l.paint.get("raster-saturation"), g > 0 ? 1 - 1 / (1.001 - g) : -g), u_contrast_factor: (h = l.paint.get("raster-contrast"), h > 0 ? 1 / (1 - h) : 1 + h), u_spin_weights: zl(l.paint.get("raster-hue-rotate")) };
        var h, g;
      };
      function zl(o) {
        o *= Math.PI / 180;
        const t = Math.sin(o), r = Math.cos(o);
        return [(2 * r + 1) / 3, (-Math.sqrt(3) * t - r + 1) / 3, (Math.sqrt(3) * t - r + 1) / 3];
      }
      const Ja = (o, t, r, s, l, h, g, _, A, L, E, M, R, q) => {
        const B = g.transform;
        return { u_is_size_zoom_constant: +(o === "constant" || o === "source"), u_is_size_feature_constant: +(o === "constant" || o === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: B.cameraToCenterDistance, u_pitch: B.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +r, u_aspect_ratio: B.width / B.height, u_fade_change: g.options.fadeDuration ? g.symbolFadeChange : 1, u_matrix: _, u_label_plane_matrix: A, u_coord_matrix: L, u_is_text: +M, u_pitch_with_map: +s, u_is_along_line: l, u_is_variable_anchor: h, u_texsize: R, u_texture: 0, u_translation: E, u_pitched_scale: q };
      }, ts = (o, t, r, s, l, h, g, _, A, L, E, M, R, q, B) => {
        const $ = g.transform;
        return c.e(Ja(o, t, r, s, l, h, g, _, A, L, E, M, R, B), { u_gamma_scale: s ? Math.cos($._pitch) * $.cameraToCenterDistance : 1, u_device_pixel_ratio: g.pixelRatio, u_is_halo: +q });
      }, ms = (o, t, r, s, l, h, g, _, A, L, E, M, R, q) => c.e(ts(o, t, r, s, l, h, g, _, A, L, E, !0, M, !0, q), { u_texsize_icon: R, u_texture_icon: 1 }), Qa = (o, t, r) => ({ u_matrix: o, u_opacity: t, u_color: r }), Ds = (o, t, r, s, l, h) => c.e(function(g, _, A, L) {
        const E = A.imageManager.getPattern(g.from.toString()), M = A.imageManager.getPattern(g.to.toString()), { width: R, height: q } = A.imageManager.getPixelSize(), B = Math.pow(2, L.tileID.overscaledZ), $ = L.tileSize * Math.pow(2, A.transform.tileZoom) / B, Q = $ * (L.tileID.canonical.x + L.tileID.wrap * B), tt = $ * L.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: E.tl, u_pattern_br_a: E.br, u_pattern_tl_b: M.tl, u_pattern_br_b: M.br, u_texsize: [R, q], u_mix: _.t, u_pattern_size_a: E.displaySize, u_pattern_size_b: M.displaySize, u_scale_a: _.fromScale, u_scale_b: _.toScale, u_tile_units_to_pixels: 1 / pi(L, 1, A.transform.tileZoom), u_pixel_coord_upper: [Q >> 16, tt >> 16], u_pixel_coord_lower: [65535 & Q, 65535 & tt] };
      }(s, h, r, l), { u_matrix: o, u_opacity: t }), Sa = { fillExtrusion: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_lightpos: new c.aN(o, t.u_lightpos), u_lightintensity: new c.aI(o, t.u_lightintensity), u_lightcolor: new c.aN(o, t.u_lightcolor), u_vertical_gradient: new c.aI(o, t.u_vertical_gradient), u_opacity: new c.aI(o, t.u_opacity) }), fillExtrusionPattern: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_lightpos: new c.aN(o, t.u_lightpos), u_lightintensity: new c.aI(o, t.u_lightintensity), u_lightcolor: new c.aN(o, t.u_lightcolor), u_vertical_gradient: new c.aI(o, t.u_vertical_gradient), u_height_factor: new c.aI(o, t.u_height_factor), u_image: new c.aH(o, t.u_image), u_texsize: new c.aO(o, t.u_texsize), u_pixel_coord_upper: new c.aO(o, t.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(o, t.u_pixel_coord_lower), u_scale: new c.aN(o, t.u_scale), u_fade: new c.aI(o, t.u_fade), u_opacity: new c.aI(o, t.u_opacity) }), fill: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix) }), fillPattern: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_image: new c.aH(o, t.u_image), u_texsize: new c.aO(o, t.u_texsize), u_pixel_coord_upper: new c.aO(o, t.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(o, t.u_pixel_coord_lower), u_scale: new c.aN(o, t.u_scale), u_fade: new c.aI(o, t.u_fade) }), fillOutline: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_world: new c.aO(o, t.u_world) }), fillOutlinePattern: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_world: new c.aO(o, t.u_world), u_image: new c.aH(o, t.u_image), u_texsize: new c.aO(o, t.u_texsize), u_pixel_coord_upper: new c.aO(o, t.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(o, t.u_pixel_coord_lower), u_scale: new c.aN(o, t.u_scale), u_fade: new c.aI(o, t.u_fade) }), circle: (o, t) => ({ u_camera_to_center_distance: new c.aI(o, t.u_camera_to_center_distance), u_scale_with_map: new c.aH(o, t.u_scale_with_map), u_pitch_with_map: new c.aH(o, t.u_pitch_with_map), u_extrude_scale: new c.aO(o, t.u_extrude_scale), u_device_pixel_ratio: new c.aI(o, t.u_device_pixel_ratio), u_matrix: new c.aJ(o, t.u_matrix) }), collisionBox: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_pixel_extrude_scale: new c.aO(o, t.u_pixel_extrude_scale) }), collisionCircle: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_inv_matrix: new c.aJ(o, t.u_inv_matrix), u_camera_to_center_distance: new c.aI(o, t.u_camera_to_center_distance), u_viewport_size: new c.aO(o, t.u_viewport_size) }), debug: (o, t) => ({ u_color: new c.aL(o, t.u_color), u_matrix: new c.aJ(o, t.u_matrix), u_overlay: new c.aH(o, t.u_overlay), u_overlay_scale: new c.aI(o, t.u_overlay_scale) }), clippingMask: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix) }), heatmap: (o, t) => ({ u_extrude_scale: new c.aI(o, t.u_extrude_scale), u_intensity: new c.aI(o, t.u_intensity), u_matrix: new c.aJ(o, t.u_matrix) }), heatmapTexture: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_world: new c.aO(o, t.u_world), u_image: new c.aH(o, t.u_image), u_color_ramp: new c.aH(o, t.u_color_ramp), u_opacity: new c.aI(o, t.u_opacity) }), hillshade: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_image: new c.aH(o, t.u_image), u_latrange: new c.aO(o, t.u_latrange), u_light: new c.aO(o, t.u_light), u_shadow: new c.aL(o, t.u_shadow), u_highlight: new c.aL(o, t.u_highlight), u_accent: new c.aL(o, t.u_accent) }), hillshadePrepare: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_image: new c.aH(o, t.u_image), u_dimension: new c.aO(o, t.u_dimension), u_zoom: new c.aI(o, t.u_zoom), u_unpack: new c.aK(o, t.u_unpack) }), line: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_ratio: new c.aI(o, t.u_ratio), u_device_pixel_ratio: new c.aI(o, t.u_device_pixel_ratio), u_units_to_pixels: new c.aO(o, t.u_units_to_pixels) }), lineGradient: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_ratio: new c.aI(o, t.u_ratio), u_device_pixel_ratio: new c.aI(o, t.u_device_pixel_ratio), u_units_to_pixels: new c.aO(o, t.u_units_to_pixels), u_image: new c.aH(o, t.u_image), u_image_height: new c.aI(o, t.u_image_height) }), linePattern: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_texsize: new c.aO(o, t.u_texsize), u_ratio: new c.aI(o, t.u_ratio), u_device_pixel_ratio: new c.aI(o, t.u_device_pixel_ratio), u_image: new c.aH(o, t.u_image), u_units_to_pixels: new c.aO(o, t.u_units_to_pixels), u_scale: new c.aN(o, t.u_scale), u_fade: new c.aI(o, t.u_fade) }), lineSDF: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_ratio: new c.aI(o, t.u_ratio), u_device_pixel_ratio: new c.aI(o, t.u_device_pixel_ratio), u_units_to_pixels: new c.aO(o, t.u_units_to_pixels), u_patternscale_a: new c.aO(o, t.u_patternscale_a), u_patternscale_b: new c.aO(o, t.u_patternscale_b), u_sdfgamma: new c.aI(o, t.u_sdfgamma), u_image: new c.aH(o, t.u_image), u_tex_y_a: new c.aI(o, t.u_tex_y_a), u_tex_y_b: new c.aI(o, t.u_tex_y_b), u_mix: new c.aI(o, t.u_mix) }), raster: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_tl_parent: new c.aO(o, t.u_tl_parent), u_scale_parent: new c.aI(o, t.u_scale_parent), u_buffer_scale: new c.aI(o, t.u_buffer_scale), u_fade_t: new c.aI(o, t.u_fade_t), u_opacity: new c.aI(o, t.u_opacity), u_image0: new c.aH(o, t.u_image0), u_image1: new c.aH(o, t.u_image1), u_brightness_low: new c.aI(o, t.u_brightness_low), u_brightness_high: new c.aI(o, t.u_brightness_high), u_saturation_factor: new c.aI(o, t.u_saturation_factor), u_contrast_factor: new c.aI(o, t.u_contrast_factor), u_spin_weights: new c.aN(o, t.u_spin_weights) }), symbolIcon: (o, t) => ({ u_is_size_zoom_constant: new c.aH(o, t.u_is_size_zoom_constant), u_is_size_feature_constant: new c.aH(o, t.u_is_size_feature_constant), u_size_t: new c.aI(o, t.u_size_t), u_size: new c.aI(o, t.u_size), u_camera_to_center_distance: new c.aI(o, t.u_camera_to_center_distance), u_pitch: new c.aI(o, t.u_pitch), u_rotate_symbol: new c.aH(o, t.u_rotate_symbol), u_aspect_ratio: new c.aI(o, t.u_aspect_ratio), u_fade_change: new c.aI(o, t.u_fade_change), u_matrix: new c.aJ(o, t.u_matrix), u_label_plane_matrix: new c.aJ(o, t.u_label_plane_matrix), u_coord_matrix: new c.aJ(o, t.u_coord_matrix), u_is_text: new c.aH(o, t.u_is_text), u_pitch_with_map: new c.aH(o, t.u_pitch_with_map), u_is_along_line: new c.aH(o, t.u_is_along_line), u_is_variable_anchor: new c.aH(o, t.u_is_variable_anchor), u_texsize: new c.aO(o, t.u_texsize), u_texture: new c.aH(o, t.u_texture), u_translation: new c.aO(o, t.u_translation), u_pitched_scale: new c.aI(o, t.u_pitched_scale) }), symbolSDF: (o, t) => ({ u_is_size_zoom_constant: new c.aH(o, t.u_is_size_zoom_constant), u_is_size_feature_constant: new c.aH(o, t.u_is_size_feature_constant), u_size_t: new c.aI(o, t.u_size_t), u_size: new c.aI(o, t.u_size), u_camera_to_center_distance: new c.aI(o, t.u_camera_to_center_distance), u_pitch: new c.aI(o, t.u_pitch), u_rotate_symbol: new c.aH(o, t.u_rotate_symbol), u_aspect_ratio: new c.aI(o, t.u_aspect_ratio), u_fade_change: new c.aI(o, t.u_fade_change), u_matrix: new c.aJ(o, t.u_matrix), u_label_plane_matrix: new c.aJ(o, t.u_label_plane_matrix), u_coord_matrix: new c.aJ(o, t.u_coord_matrix), u_is_text: new c.aH(o, t.u_is_text), u_pitch_with_map: new c.aH(o, t.u_pitch_with_map), u_is_along_line: new c.aH(o, t.u_is_along_line), u_is_variable_anchor: new c.aH(o, t.u_is_variable_anchor), u_texsize: new c.aO(o, t.u_texsize), u_texture: new c.aH(o, t.u_texture), u_gamma_scale: new c.aI(o, t.u_gamma_scale), u_device_pixel_ratio: new c.aI(o, t.u_device_pixel_ratio), u_is_halo: new c.aH(o, t.u_is_halo), u_translation: new c.aO(o, t.u_translation), u_pitched_scale: new c.aI(o, t.u_pitched_scale) }), symbolTextAndIcon: (o, t) => ({ u_is_size_zoom_constant: new c.aH(o, t.u_is_size_zoom_constant), u_is_size_feature_constant: new c.aH(o, t.u_is_size_feature_constant), u_size_t: new c.aI(o, t.u_size_t), u_size: new c.aI(o, t.u_size), u_camera_to_center_distance: new c.aI(o, t.u_camera_to_center_distance), u_pitch: new c.aI(o, t.u_pitch), u_rotate_symbol: new c.aH(o, t.u_rotate_symbol), u_aspect_ratio: new c.aI(o, t.u_aspect_ratio), u_fade_change: new c.aI(o, t.u_fade_change), u_matrix: new c.aJ(o, t.u_matrix), u_label_plane_matrix: new c.aJ(o, t.u_label_plane_matrix), u_coord_matrix: new c.aJ(o, t.u_coord_matrix), u_is_text: new c.aH(o, t.u_is_text), u_pitch_with_map: new c.aH(o, t.u_pitch_with_map), u_is_along_line: new c.aH(o, t.u_is_along_line), u_is_variable_anchor: new c.aH(o, t.u_is_variable_anchor), u_texsize: new c.aO(o, t.u_texsize), u_texsize_icon: new c.aO(o, t.u_texsize_icon), u_texture: new c.aH(o, t.u_texture), u_texture_icon: new c.aH(o, t.u_texture_icon), u_gamma_scale: new c.aI(o, t.u_gamma_scale), u_device_pixel_ratio: new c.aI(o, t.u_device_pixel_ratio), u_is_halo: new c.aH(o, t.u_is_halo), u_translation: new c.aO(o, t.u_translation), u_pitched_scale: new c.aI(o, t.u_pitched_scale) }), background: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_opacity: new c.aI(o, t.u_opacity), u_color: new c.aL(o, t.u_color) }), backgroundPattern: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_opacity: new c.aI(o, t.u_opacity), u_image: new c.aH(o, t.u_image), u_pattern_tl_a: new c.aO(o, t.u_pattern_tl_a), u_pattern_br_a: new c.aO(o, t.u_pattern_br_a), u_pattern_tl_b: new c.aO(o, t.u_pattern_tl_b), u_pattern_br_b: new c.aO(o, t.u_pattern_br_b), u_texsize: new c.aO(o, t.u_texsize), u_mix: new c.aI(o, t.u_mix), u_pattern_size_a: new c.aO(o, t.u_pattern_size_a), u_pattern_size_b: new c.aO(o, t.u_pattern_size_b), u_scale_a: new c.aI(o, t.u_scale_a), u_scale_b: new c.aI(o, t.u_scale_b), u_pixel_coord_upper: new c.aO(o, t.u_pixel_coord_upper), u_pixel_coord_lower: new c.aO(o, t.u_pixel_coord_lower), u_tile_units_to_pixels: new c.aI(o, t.u_tile_units_to_pixels) }), terrain: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_texture: new c.aH(o, t.u_texture), u_ele_delta: new c.aI(o, t.u_ele_delta), u_fog_matrix: new c.aJ(o, t.u_fog_matrix), u_fog_color: new c.aL(o, t.u_fog_color), u_fog_ground_blend: new c.aI(o, t.u_fog_ground_blend), u_fog_ground_blend_opacity: new c.aI(o, t.u_fog_ground_blend_opacity), u_horizon_color: new c.aL(o, t.u_horizon_color), u_horizon_fog_blend: new c.aI(o, t.u_horizon_fog_blend) }), terrainDepth: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_ele_delta: new c.aI(o, t.u_ele_delta) }), terrainCoords: (o, t) => ({ u_matrix: new c.aJ(o, t.u_matrix), u_texture: new c.aH(o, t.u_texture), u_terrain_coords_id: new c.aI(o, t.u_terrain_coords_id), u_ele_delta: new c.aI(o, t.u_ele_delta) }), sky: (o, t) => ({ u_sky_color: new c.aL(o, t.u_sky_color), u_horizon_color: new c.aL(o, t.u_horizon_color), u_horizon: new c.aI(o, t.u_horizon), u_sky_horizon_blend: new c.aI(o, t.u_sky_horizon_blend) }) };
      class hn {
        constructor(t, r, s) {
          this.context = t;
          const l = t.gl;
          this.buffer = l.createBuffer(), this.dynamicDraw = !!s, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), l.bufferData(l.ELEMENT_ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? l.DYNAMIC_DRAW : l.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t) {
          const r = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), r.bufferSubData(r.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const ul = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class to {
        constructor(t, r, s, l) {
          this.length = r.length, this.attributes = s, this.itemSize = r.bytesPerElement, this.dynamicDraw = l, this.context = t;
          const h = t.gl;
          this.buffer = h.createBuffer(), t.bindVertexBuffer.set(this.buffer), h.bufferData(h.ARRAY_BUFFER, r.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW), this.dynamicDraw || delete r.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t) {
          if (t.length !== this.length) throw new Error(`Length of new data is ${t.length}, which doesn't match current length of ${this.length}`);
          const r = this.context.gl;
          this.bind(), r.bufferSubData(r.ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        enableAttributes(t, r) {
          for (let s = 0; s < this.attributes.length; s++) {
            const l = r.attributes[this.attributes[s].name];
            l !== void 0 && t.enableVertexAttribArray(l);
          }
        }
        setVertexAttribPointers(t, r, s) {
          for (let l = 0; l < this.attributes.length; l++) {
            const h = this.attributes[l], g = r.attributes[h.name];
            g !== void 0 && t.vertexAttribPointer(g, h.components, t[ul[h.type]], !1, this.itemSize, h.offset + this.itemSize * (s || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const gs = /* @__PURE__ */ new WeakMap();
      function es(o) {
        var t;
        if (gs.has(o)) return gs.get(o);
        {
          const r = (t = o.getParameter(o.VERSION)) === null || t === void 0 ? void 0 : t.startsWith("WebGL 2.0");
          return gs.set(o, r), r;
        }
      }
      class Si {
        constructor(t) {
          this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(t) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class Fn extends Si {
        getDefault() {
          return c.aM.transparent;
        }
        set(t) {
          const r = this.current;
          (t.r !== r.r || t.g !== r.g || t.b !== r.b || t.a !== r.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class Nl extends Si {
        getDefault() {
          return 1;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);
        }
      }
      class Pn extends Si {
        getDefault() {
          return 0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);
        }
      }
      class is extends Si {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(t) {
          const r = this.current;
          (t[0] !== r[0] || t[1] !== r[1] || t[2] !== r[2] || t[3] !== r[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class eo extends Si {
        getDefault() {
          return !0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);
        }
      }
      class Aa extends Si {
        getDefault() {
          return 255;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);
        }
      }
      class dl extends Si {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t) {
          const r = this.current;
          (t.func !== r.func || t.ref !== r.ref || t.mask !== r.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);
        }
      }
      class ea extends Si {
        getDefault() {
          const t = this.gl;
          return [t.KEEP, t.KEEP, t.KEEP];
        }
        set(t) {
          const r = this.current;
          (t[0] !== r[0] || t[1] !== r[1] || t[2] !== r[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);
        }
      }
      class pl extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          t ? r.enable(r.STENCIL_TEST) : r.disable(r.STENCIL_TEST), this.current = t, this.dirty = !1;
        }
      }
      class io extends Si {
        getDefault() {
          return [0, 1];
        }
        set(t) {
          const r = this.current;
          (t[0] !== r[0] || t[1] !== r[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);
        }
      }
      class ro extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          t ? r.enable(r.DEPTH_TEST) : r.disable(r.DEPTH_TEST), this.current = t, this.dirty = !1;
        }
      }
      class jo extends Si {
        getDefault() {
          return this.gl.LESS;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);
        }
      }
      class Bn extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          t ? r.enable(r.BLEND) : r.disable(r.BLEND), this.current = t, this.dirty = !1;
        }
      }
      class no extends Si {
        getDefault() {
          const t = this.gl;
          return [t.ONE, t.ZERO];
        }
        set(t) {
          const r = this.current;
          (t[0] !== r[0] || t[1] !== r[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = !1);
        }
      }
      class qo extends Si {
        getDefault() {
          return c.aM.transparent;
        }
        set(t) {
          const r = this.current;
          (t.r !== r.r || t.g !== r.g || t.b !== r.b || t.a !== r.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class Uo extends Si {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = !1);
        }
      }
      class Pa extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          t ? r.enable(r.CULL_FACE) : r.disable(r.CULL_FACE), this.current = t, this.dirty = !1;
        }
      }
      class so extends Si {
        getDefault() {
          return this.gl.BACK;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);
        }
      }
      class ys extends Si {
        getDefault() {
          return this.gl.CCW;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);
        }
      }
      class Vo extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = !1);
        }
      }
      class ia extends Si {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);
        }
      }
      class ao extends Si {
        getDefault() {
          const t = this.gl;
          return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
        }
        set(t) {
          const r = this.current;
          (t[0] !== r[0] || t[1] !== r[1] || t[2] !== r[2] || t[3] !== r[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class T extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindFramebuffer(r.FRAMEBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class H extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindRenderbuffer(r.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class ft extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindTexture(r.TEXTURE_2D, t), this.current = t, this.dirty = !1;
        }
      }
      class Ct extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          r.bindBuffer(r.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class Ft extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          const r = this.gl;
          r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class Yt extends Si {
        getDefault() {
          return null;
        }
        set(t) {
          var r;
          if (t === this.current && !this.dirty) return;
          const s = this.gl;
          es(s) ? s.bindVertexArray(t) : (r = s.getExtension("OES_vertex_array_object")) === null || r === void 0 || r.bindVertexArrayOES(t), this.current = t, this.dirty = !1;
        }
      }
      class ye extends Si {
        getDefault() {
          return 4;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;
        }
      }
      class Be extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class Je extends Si {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const r = this.gl;
          r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class mi extends Si {
        constructor(t, r) {
          super(t), this.context = t, this.parent = r;
        }
        getDefault() {
          return null;
        }
      }
      class gi extends mi {
        setDirty() {
          this.dirty = !0;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
        }
      }
      class ki extends mi {
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class Qi extends mi {
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const r = this.gl;
          r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class vr {
        constructor(t, r, s, l, h) {
          this.context = t, this.width = r, this.height = s;
          const g = t.gl, _ = this.framebuffer = g.createFramebuffer();
          if (this.colorAttachment = new gi(t, _), l) this.depthAttachment = h ? new Qi(t, _) : new ki(t, _);
          else if (h) throw new Error("Stencil cannot be set without depth");
          if (g.checkFramebufferStatus(g.FRAMEBUFFER) !== g.FRAMEBUFFER_COMPLETE) throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const t = this.context.gl, r = this.colorAttachment.get();
          if (r && t.deleteTexture(r), this.depthAttachment) {
            const s = this.depthAttachment.get();
            s && t.deleteRenderbuffer(s);
          }
          t.deleteFramebuffer(this.framebuffer);
        }
      }
      class Ai {
        constructor(t, r, s) {
          this.blendFunction = t, this.blendColor = r, this.mask = s;
        }
      }
      Ai.Replace = [1, 0], Ai.disabled = new Ai(Ai.Replace, c.aM.transparent, [!1, !1, !1, !1]), Ai.unblended = new Ai(Ai.Replace, c.aM.transparent, [!0, !0, !0, !0]), Ai.alphaBlended = new Ai([1, 771], c.aM.transparent, [!0, !0, !0, !0]);
      class Kr {
        constructor(t) {
          var r, s;
          if (this.gl = t, this.clearColor = new Fn(this), this.clearDepth = new Nl(this), this.clearStencil = new Pn(this), this.colorMask = new is(this), this.depthMask = new eo(this), this.stencilMask = new Aa(this), this.stencilFunc = new dl(this), this.stencilOp = new ea(this), this.stencilTest = new pl(this), this.depthRange = new io(this), this.depthTest = new ro(this), this.depthFunc = new jo(this), this.blend = new Bn(this), this.blendFunc = new no(this), this.blendColor = new qo(this), this.blendEquation = new Uo(this), this.cullFace = new Pa(this), this.cullFaceSide = new so(this), this.frontFace = new ys(this), this.program = new Vo(this), this.activeTexture = new ia(this), this.viewport = new ao(this), this.bindFramebuffer = new T(this), this.bindRenderbuffer = new H(this), this.bindTexture = new ft(this), this.bindVertexBuffer = new Ct(this), this.bindElementBuffer = new Ft(this), this.bindVertexArray = new Yt(this), this.pixelStoreUnpack = new ye(this), this.pixelStoreUnpackPremultiplyAlpha = new Be(this), this.pixelStoreUnpackFlipY = new Je(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), es(t)) {
            this.HALF_FLOAT = t.HALF_FLOAT;
            const l = t.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (r = t.RGBA16F) !== null && r !== void 0 ? r : l == null ? void 0 : l.RGBA16F_EXT, this.RGB16F = (s = t.RGB16F) !== null && s !== void 0 ? s : l == null ? void 0 : l.RGB16F_EXT, t.getExtension("EXT_color_buffer_float");
          } else {
            t.getExtension("EXT_color_buffer_half_float"), t.getExtension("OES_texture_half_float_linear");
            const l = t.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = l == null ? void 0 : l.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(t, r) {
          return new hn(this, t, r);
        }
        createVertexBuffer(t, r, s) {
          return new to(this, t, r, s);
        }
        createRenderbuffer(t, r, s) {
          const l = this.gl, h = l.createRenderbuffer();
          return this.bindRenderbuffer.set(h), l.renderbufferStorage(l.RENDERBUFFER, t, r, s), this.bindRenderbuffer.set(null), h;
        }
        createFramebuffer(t, r, s, l) {
          return new vr(this, t, r, s, l);
        }
        clear({ color: t, depth: r, stencil: s }) {
          const l = this.gl;
          let h = 0;
          t && (h |= l.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set([!0, !0, !0, !0])), r !== void 0 && (h |= l.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(r), this.depthMask.set(!0)), s !== void 0 && (h |= l.STENCIL_BUFFER_BIT, this.clearStencil.set(s), this.stencilMask.set(255)), l.clear(h);
        }
        setCullFace(t) {
          t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
        }
        setDepthMode(t) {
          t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
        }
        setStencilMode(t) {
          t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(t) {
          c.aE(t.blendFunction, Ai.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask);
        }
        createVertexArray() {
          var t;
          return es(this.gl) ? this.gl.createVertexArray() : (t = this.gl.getExtension("OES_vertex_array_object")) === null || t === void 0 ? void 0 : t.createVertexArrayOES();
        }
        deleteVertexArray(t) {
          var r;
          return es(this.gl) ? this.gl.deleteVertexArray(t) : (r = this.gl.getExtension("OES_vertex_array_object")) === null || r === void 0 ? void 0 : r.deleteVertexArrayOES(t);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      class Ye {
        constructor(t, r, s) {
          this.func = t, this.mask = r, this.range = s;
        }
      }
      Ye.ReadOnly = !1, Ye.ReadWrite = !0, Ye.disabled = new Ye(519, Ye.ReadOnly, [0, 1]);
      const yn = 7680;
      class Ci {
        constructor(t, r, s, l, h, g) {
          this.test = t, this.ref = r, this.mask = s, this.fail = l, this.depthFail = h, this.pass = g;
        }
      }
      Ci.disabled = new Ci({ func: 519, mask: 0 }, 0, 0, yn, yn, yn);
      class Mi {
        constructor(t, r, s) {
          this.enable = t, this.mode = r, this.frontFace = s;
        }
      }
      let _s;
      function Fs(o, t, r, s, l) {
        const h = o.context, g = h.gl, _ = o.useProgram("collisionBox"), A = [];
        let L = 0, E = 0;
        for (let tt = 0; tt < s.length; tt++) {
          const nt = s[tt], it = t.getTile(nt).getBucket(r);
          if (!it) continue;
          const ht = l ? it.textCollisionBox : it.iconCollisionBox, wt = it.collisionCircleArray;
          if (wt.length > 0) {
            const _t = c.H();
            c.aQ(_t, it.placementInvProjMatrix, o.transform.glCoordMatrix), c.aQ(_t, _t, it.placementViewportMatrix), A.push({ circleArray: wt, circleOffset: E, transform: nt.posMatrix, invTransform: _t, coord: nt }), L += wt.length / 4, E = L;
          }
          ht && _.draw(h, g.LINES, Ye.disabled, Ci.disabled, o.colorModeForRenderPass(), Mi.disabled, { u_matrix: nt.posMatrix, u_pixel_extrude_scale: [1 / (M = o.transform).width, 1 / M.height] }, o.style.map.terrain && o.style.map.terrain.getTerrainData(nt), r.id, ht.layoutVertexBuffer, ht.indexBuffer, ht.segments, null, o.transform.zoom, null, null, ht.collisionVertexBuffer);
        }
        var M;
        if (!l || !A.length) return;
        const R = o.useProgram("collisionCircle"), q = new c.aR();
        q.resize(4 * L), q._trim();
        let B = 0;
        for (const tt of A) for (let nt = 0; nt < tt.circleArray.length / 4; nt++) {
          const it = 4 * nt, ht = tt.circleArray[it + 0], wt = tt.circleArray[it + 1], _t = tt.circleArray[it + 2], Vt = tt.circleArray[it + 3];
          q.emplace(B++, ht, wt, _t, Vt, 0), q.emplace(B++, ht, wt, _t, Vt, 1), q.emplace(B++, ht, wt, _t, Vt, 2), q.emplace(B++, ht, wt, _t, Vt, 3);
        }
        (!_s || _s.length < 2 * L) && (_s = function(tt) {
          const nt = 2 * tt, it = new c.aT();
          it.resize(nt), it._trim();
          for (let ht = 0; ht < nt; ht++) {
            const wt = 6 * ht;
            it.uint16[wt + 0] = 4 * ht + 0, it.uint16[wt + 1] = 4 * ht + 1, it.uint16[wt + 2] = 4 * ht + 2, it.uint16[wt + 3] = 4 * ht + 2, it.uint16[wt + 4] = 4 * ht + 3, it.uint16[wt + 5] = 4 * ht + 0;
          }
          return it;
        }(L));
        const $ = h.createIndexBuffer(_s, !0), Q = h.createVertexBuffer(q, c.aS.members, !0);
        for (const tt of A) {
          const nt = mr(tt.transform, tt.invTransform, o.transform);
          R.draw(h, g.TRIANGLES, Ye.disabled, Ci.disabled, o.colorModeForRenderPass(), Mi.disabled, nt, o.style.map.terrain && o.style.map.terrain.getTerrainData(tt.coord), r.id, Q, $, c.a0.simpleSegment(0, 2 * tt.circleOffset, tt.circleArray.length, tt.circleArray.length / 2), null, o.transform.zoom, null, null, null);
        }
        Q.destroy(), $.destroy();
      }
      Mi.disabled = new Mi(!1, 1029, 2305), Mi.backCCW = new Mi(!0, 1029, 2305);
      const Bs = c.an(new Float32Array(16));
      function ra(o, t, r, s, l, h) {
        const { horizontalAlign: g, verticalAlign: _ } = c.au(o);
        return new c.P((-(g - 0.5) * t / l + s[0]) * h, (-(_ - 0.5) * r / l + s[1]) * h);
      }
      function rs(o, t, r, s, l, h) {
        const g = t.tileAnchorPoint.add(new c.P(t.translation[0], t.translation[1]));
        if (t.pitchWithMap) {
          let _ = s.mult(h);
          r || (_ = _.rotate(-l));
          const A = g.add(_);
          return ut(A.x, A.y, t.labelPlaneMatrix, t.getElevation).point;
        }
        if (r) {
          const _ = Ut(t.tileAnchorPoint.x + 1, t.tileAnchorPoint.y, t).point.sub(o), A = Math.atan(_.y / _.x) + (_.x < 0 ? Math.PI : 0);
          return o.add(s.rotate(A));
        }
        return o.add(s);
      }
      function vs(o, t, r, s, l, h, g, _, A, L, E, M, R, q) {
        const B = o.text.placedSymbolArray, $ = o.text.dynamicLayoutVertexArray, Q = o.icon.dynamicLayoutVertexArray, tt = {};
        $.clear();
        for (let nt = 0; nt < B.length; nt++) {
          const it = B.get(nt), ht = it.hidden || !it.crossTileID || o.allowVerticalPlacement && !it.placedOrientation ? null : s[it.crossTileID];
          if (ht) {
            const wt = new c.P(it.anchorX, it.anchorY), _t = { getElevation: q, width: l.width, height: l.height, labelPlaneMatrix: h, lineVertexArray: null, pitchWithMap: r, projection: E, projectionCache: null, tileAnchorPoint: wt, translation: M, unwrappedTileID: R }, Vt = r ? ut(wt.x, wt.y, g, q) : Ut(wt.x, wt.y, _t), re = V(l.cameraToCenterDistance, Vt.signedDistanceFromCamera);
            let ce = c.ai(o.textSizeData, A, it) * re / c.ap;
            r && (ce *= o.tilePixelRatio / _);
            const { width: de, height: ue, anchor: he, textOffset: fe, textBoxScale: Oe } = ht, ve = ra(he, de, ue, fe, Oe, ce), xe = E.getPitchedTextCorrection(l, wt.add(new c.P(M[0], M[1])), R), Ue = rs(Vt.point, _t, t, ve, l.angle, xe), ni = o.allowVerticalPlacement && it.placedOrientation === c.ah.vertical ? Math.PI / 2 : 0;
            for (let ii = 0; ii < it.numGlyphs; ii++) c.aj($, Ue, ni);
            L && it.associatedIconIndex >= 0 && (tt[it.associatedIconIndex] = { shiftedAnchor: Ue, angle: ni });
          } else $e(it.numGlyphs, $);
        }
        if (L) {
          Q.clear();
          const nt = o.icon.placedSymbolArray;
          for (let it = 0; it < nt.length; it++) {
            const ht = nt.get(it);
            if (ht.hidden) $e(ht.numGlyphs, Q);
            else {
              const wt = tt[it];
              if (wt) for (let _t = 0; _t < ht.numGlyphs; _t++) c.aj(Q, wt.shiftedAnchor, wt.angle);
              else $e(ht.numGlyphs, Q);
            }
          }
          o.icon.dynamicLayoutVertexBuffer.updateData(Q);
        }
        o.text.dynamicLayoutVertexBuffer.updateData($);
      }
      function jr(o, t, r) {
        return r.iconsInText && t ? "symbolTextAndIcon" : o ? "symbolSDF" : "symbolIcon";
      }
      function Lr(o, t, r, s, l, h, g, _, A, L, E, M) {
        const R = o.context, q = R.gl, B = o.transform, $ = Dn(), Q = _ === "map", tt = A === "map", nt = _ !== "viewport" && r.layout.get("symbol-placement") !== "point", it = Q && !tt && !nt, ht = !tt && nt, wt = !r.layout.get("symbol-sort-key").isConstant();
        let _t = !1;
        const Vt = o.depthModeForSublayer(0, Ye.ReadOnly), re = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset"), ce = [], de = $.getCircleRadiusCorrection(B);
        for (const ue of s) {
          const he = t.getTile(ue), fe = he.getBucket(r);
          if (!fe) continue;
          const Oe = l ? fe.text : fe.icon;
          if (!Oe || !Oe.segments.get().length || !Oe.hasVisibleVertices) continue;
          const ve = Oe.programConfigurations.get(r.id), xe = l || fe.sdfIcons, Ue = l ? fe.textSizeData : fe.iconSizeData, ni = tt || B.pitch !== 0, ii = o.useProgram(jr(xe, l, fe), ve), ci = c.ag(Ue, B.zoom), bi = o.style.map.terrain && o.style.map.terrain.getTerrainData(ue);
          let ji, tr, Ni, ur, qi = [0, 0], or = null;
          if (l) tr = he.glyphAtlasTexture, Ni = q.LINEAR, ji = he.glyphAtlasTexture.size, fe.iconsInText && (qi = he.imageAtlasTexture.size, or = he.imageAtlasTexture, ur = ni || o.options.rotating || o.options.zooming || Ue.kind === "composite" || Ue.kind === "camera" ? q.LINEAR : q.NEAREST);
          else {
            const Li = r.layout.get("icon-size").constantOr(0) !== 1 || fe.iconsNeedLinear;
            tr = he.imageAtlasTexture, Ni = xe || o.options.rotating || o.options.zooming || Li || ni ? q.LINEAR : q.NEAREST, ji = he.imageAtlasTexture.size;
          }
          const xr = pi(he, 1, o.transform.zoom), dn = ht ? ue.posMatrix : Bs, Cn = Mr(dn, tt, Q, o.transform, xr), er = Er(dn, tt, Q, o.transform, xr), da = Er(ue.posMatrix, tt, Q, o.transform, xr), Mn = $.translatePosition(o.transform, he, h, g), tl = re && fe.hasTextData(), vo = r.layout.get("icon-text-fit") !== "none" && tl && fe.hasIconData();
          if (nt) {
            const Li = o.style.map.terrain ? (pa, Us) => o.style.map.terrain.getElevation(ue, pa, Us) : null, Ts = r.layout.get("text-rotation-alignment") === "map";
            et(fe, ue.posMatrix, o, l, Cn, da, tt, L, Ts, $, ue.toUnwrapped(), B.width, B.height, Mn, Li);
          }
          const en = ue.posMatrix, pn = l && re || vo, Fr = nt || pn ? Bs : Cn, rn = er, yr = xe && r.paint.get(l ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let Vr;
          Vr = xe ? fe.iconsInText ? ms(Ue.kind, ci, it, tt, nt, pn, o, en, Fr, rn, Mn, ji, qi, de) : ts(Ue.kind, ci, it, tt, nt, pn, o, en, Fr, rn, Mn, l, ji, !0, de) : Ja(Ue.kind, ci, it, tt, nt, pn, o, en, Fr, rn, Mn, l, ji, de);
          const nn = { program: ii, buffers: Oe, uniformValues: Vr, atlasTexture: tr, atlasTextureIcon: or, atlasInterpolation: Ni, atlasInterpolationIcon: ur, isSDF: xe, hasHalo: yr };
          if (wt && fe.canOverlap) {
            _t = !0;
            const Li = Oe.segments.get();
            for (const Ts of Li) ce.push({ segments: new c.a0([Ts]), sortKey: Ts.sortKey, state: nn, terrainData: bi });
          } else ce.push({ segments: Oe.segments, sortKey: 0, state: nn, terrainData: bi });
        }
        _t && ce.sort((ue, he) => ue.sortKey - he.sortKey);
        for (const ue of ce) {
          const he = ue.state;
          if (R.activeTexture.set(q.TEXTURE0), he.atlasTexture.bind(he.atlasInterpolation, q.CLAMP_TO_EDGE), he.atlasTextureIcon && (R.activeTexture.set(q.TEXTURE1), he.atlasTextureIcon && he.atlasTextureIcon.bind(he.atlasInterpolationIcon, q.CLAMP_TO_EDGE)), he.isSDF) {
            const fe = he.uniformValues;
            he.hasHalo && (fe.u_is_halo = 1, na(he.buffers, ue.segments, r, o, he.program, Vt, E, M, fe, ue.terrainData)), fe.u_is_halo = 0;
          }
          na(he.buffers, ue.segments, r, o, he.program, Vt, E, M, he.uniformValues, ue.terrainData);
        }
      }
      function na(o, t, r, s, l, h, g, _, A, L) {
        const E = s.context;
        l.draw(E, E.gl.TRIANGLES, h, g, _, Mi.disabled, A, L, r.id, o.layoutVertexBuffer, o.indexBuffer, t, r.paint, s.transform.zoom, o.programConfigurations.get(r.id), o.dynamicLayoutVertexBuffer, o.opacityVertexBuffer);
      }
      function sa(o, t, r, s) {
        const l = o.context, h = l.gl, g = Ci.disabled, _ = new Ai([h.ONE, h.ONE], c.aM.transparent, [!0, !0, !0, !0]), A = t.getBucket(r);
        if (!A) return;
        const L = s.key;
        let E = r.heatmapFbos.get(L);
        E || (E = Rs(l, t.tileSize, t.tileSize), r.heatmapFbos.set(L, E)), l.bindFramebuffer.set(E.framebuffer), l.viewport.set([0, 0, t.tileSize, t.tileSize]), l.clear({ color: c.aM.transparent });
        const M = A.programConfigurations.get(r.id), R = o.useProgram("heatmap", M), q = o.style.map.terrain.getTerrainData(s);
        R.draw(l, h.TRIANGLES, Ye.disabled, g, _, Mi.disabled, He(s.posMatrix, t, o.transform.zoom, r.paint.get("heatmap-intensity")), q, r.id, A.layoutVertexBuffer, A.indexBuffer, A.segments, r.paint, o.transform.zoom, M);
      }
      function Rn(o, t, r) {
        const s = o.context, l = s.gl;
        s.setColorMode(o.colorModeForRenderPass());
        const h = zr(s, t), g = r.key, _ = t.heatmapFbos.get(g);
        _ && (s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, _.colorAttachment.get()), s.activeTexture.set(l.TEXTURE1), h.bind(l.LINEAR, l.CLAMP_TO_EDGE), o.useProgram("heatmapTexture").draw(s, l.TRIANGLES, Ye.disabled, Ci.disabled, o.colorModeForRenderPass(), Mi.disabled, Xa(o, t, 0, 1), null, t.id, o.rasterBoundsBuffer, o.quadTriangleIndexBuffer, o.rasterBoundsSegments, t.paint, o.transform.zoom), _.destroy(), t.heatmapFbos.delete(g));
      }
      function Rs(o, t, r) {
        var s, l;
        const h = o.gl, g = h.createTexture();
        h.bindTexture(h.TEXTURE_2D, g), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR);
        const _ = (s = o.HALF_FLOAT) !== null && s !== void 0 ? s : h.UNSIGNED_BYTE, A = (l = o.RGBA16F) !== null && l !== void 0 ? l : h.RGBA;
        h.texImage2D(h.TEXTURE_2D, 0, A, t, r, 0, h.RGBA, _, null);
        const L = o.createFramebuffer(t, r, !1, !1);
        return L.colorAttachment.set(g), L;
      }
      function zr(o, t) {
        return t.colorRampTexture || (t.colorRampTexture = new at(o, t.colorRamp, o.gl.RGBA)), t.colorRampTexture;
      }
      function aa(o, t, r, s, l) {
        if (!r || !s || !s.imageAtlas) return;
        const h = s.imageAtlas.patternPositions;
        let g = h[r.to.toString()], _ = h[r.from.toString()];
        if (!g && _ && (g = _), !_ && g && (_ = g), !g || !_) {
          const A = l.getPaintProperty(t);
          g = h[A], _ = h[A];
        }
        g && _ && o.setConstantPatternPositions(g, _);
      }
      function Os(o, t, r, s, l, h, g) {
        const _ = o.context.gl, A = "fill-pattern", L = r.paint.get(A), E = L && L.constantOr(1), M = r.getCrossfadeParameters();
        let R, q, B, $, Q;
        g ? (q = E && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", R = _.LINES) : (q = E ? "fillPattern" : "fill", R = _.TRIANGLES);
        const tt = L.constantOr(null);
        for (const nt of s) {
          const it = t.getTile(nt);
          if (E && !it.patternsLoaded()) continue;
          const ht = it.getBucket(r);
          if (!ht) continue;
          const wt = ht.programConfigurations.get(r.id), _t = o.useProgram(q, wt), Vt = o.style.map.terrain && o.style.map.terrain.getTerrainData(nt);
          E && (o.context.activeTexture.set(_.TEXTURE0), it.imageAtlasTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE), wt.updatePaintBuffers(M)), aa(wt, A, tt, it, r);
          const re = Vt ? nt : null, ce = o.translatePosMatrix(re ? re.posMatrix : nt.posMatrix, it, r.paint.get("fill-translate"), r.paint.get("fill-translate-anchor"));
          if (g) {
            $ = ht.indexBuffer2, Q = ht.segments2;
            const de = [_.drawingBufferWidth, _.drawingBufferHeight];
            B = q === "fillOutlinePattern" && E ? ba(ce, o, M, it, de) : Wa(ce, de);
          } else $ = ht.indexBuffer, Q = ht.segments, B = E ? fs(ce, o, M, it) : ta(ce);
          _t.draw(o.context, R, l, o.stencilModeForClipping(nt), h, Mi.disabled, B, Vt, r.id, ht.layoutVertexBuffer, $, Q, r.paint, o.transform.zoom, wt);
        }
      }
      function Ia(o, t, r, s, l, h, g) {
        const _ = o.context, A = _.gl, L = "fill-extrusion-pattern", E = r.paint.get(L), M = E.constantOr(1), R = r.getCrossfadeParameters(), q = r.paint.get("fill-extrusion-opacity"), B = E.constantOr(null);
        for (const $ of s) {
          const Q = t.getTile($), tt = Q.getBucket(r);
          if (!tt) continue;
          const nt = o.style.map.terrain && o.style.map.terrain.getTerrainData($), it = tt.programConfigurations.get(r.id), ht = o.useProgram(M ? "fillExtrusionPattern" : "fillExtrusion", it);
          M && (o.context.activeTexture.set(A.TEXTURE0), Q.imageAtlasTexture.bind(A.LINEAR, A.CLAMP_TO_EDGE), it.updatePaintBuffers(R)), aa(it, L, B, Q, r);
          const wt = o.translatePosMatrix($.posMatrix, Q, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")), _t = r.paint.get("fill-extrusion-vertical-gradient"), Vt = M ? Za(wt, o, _t, q, $, R, Q) : xa(wt, o, _t, q);
          ht.draw(_, _.gl.TRIANGLES, l, h, g, Mi.backCCW, Vt, nt, r.id, tt.layoutVertexBuffer, tt.indexBuffer, tt.segments, r.paint, o.transform.zoom, it, o.style.map.terrain && tt.centroidVertexBuffer);
        }
      }
      function qr(o, t, r, s, l, h, g) {
        const _ = o.context, A = _.gl, L = r.fbo;
        if (!L) return;
        const E = o.useProgram("hillshade"), M = o.style.map.terrain && o.style.map.terrain.getTerrainData(t);
        _.activeTexture.set(A.TEXTURE0), A.bindTexture(A.TEXTURE_2D, L.colorAttachment.get()), E.draw(_, A.TRIANGLES, l, h, g, Mi.disabled, ((R, q, B, $) => {
          const Q = B.paint.get("hillshade-shadow-color"), tt = B.paint.get("hillshade-highlight-color"), nt = B.paint.get("hillshade-accent-color");
          let it = B.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          B.paint.get("hillshade-illumination-anchor") === "viewport" && (it -= R.transform.angle);
          const ht = !R.options.moving;
          return { u_matrix: $ ? $.posMatrix : R.transform.calculatePosMatrix(q.tileID.toUnwrapped(), ht), u_image: 0, u_latrange: Ha(0, q.tileID), u_light: [B.paint.get("hillshade-exaggeration"), it], u_shadow: Q, u_highlight: tt, u_accent: nt };
        })(o, r, s, M ? t : null), M, s.id, o.rasterBoundsBuffer, o.quadTriangleIndexBuffer, o.rasterBoundsSegments);
      }
      function ns(o, t, r, s, l, h) {
        const g = o.context, _ = g.gl, A = t.dem;
        if (A && A.data) {
          const L = A.dim, E = A.stride, M = A.getPixels();
          if (g.activeTexture.set(_.TEXTURE1), g.pixelStoreUnpackPremultiplyAlpha.set(!1), t.demTexture = t.demTexture || o.getTileTexture(E), t.demTexture) {
            const q = t.demTexture;
            q.update(M, { premultiply: !1 }), q.bind(_.NEAREST, _.CLAMP_TO_EDGE);
          } else t.demTexture = new at(g, M, _.RGBA, { premultiply: !1 }), t.demTexture.bind(_.NEAREST, _.CLAMP_TO_EDGE);
          g.activeTexture.set(_.TEXTURE0);
          let R = t.fbo;
          if (!R) {
            const q = new at(g, { width: L, height: L, data: null }, _.RGBA);
            q.bind(_.LINEAR, _.CLAMP_TO_EDGE), R = t.fbo = g.createFramebuffer(L, L, !0, !1), R.colorAttachment.set(q.texture);
          }
          g.bindFramebuffer.set(R.framebuffer), g.viewport.set([0, 0, L, L]), o.useProgram("hillshadePrepare").draw(g, _.TRIANGLES, s, l, h, Mi.disabled, ((q, B) => {
            const $ = B.stride, Q = c.H();
            return c.aP(Q, 0, c.X, -c.X, 0, 0, 1), c.J(Q, Q, [0, -c.X, 0]), { u_matrix: Q, u_image: 1, u_dimension: [$, $], u_zoom: q.overscaledZ, u_unpack: B.getUnpackVector() };
          })(t.tileID, A), null, r.id, o.rasterBoundsBuffer, o.quadTriangleIndexBuffer, o.rasterBoundsSegments), t.needsHillshadePrepare = !1;
        }
      }
      function Go(o, t, r, s, l, h) {
        const g = s.paint.get("raster-fade-duration");
        if (!h && g > 0) {
          const _ = O.now(), A = (_ - o.timeAdded) / g, L = t ? (_ - t.timeAdded) / g : -1, E = r.getSource(), M = l.coveringZoomLevel({ tileSize: E.tileSize, roundZoom: E.roundZoom }), R = !t || Math.abs(t.tileID.overscaledZ - M) > Math.abs(o.tileID.overscaledZ - M), q = R && o.refreshedUponExpiration ? 1 : c.ac(R ? A : 1 - L, 0, 1);
          return o.refreshedUponExpiration && A >= 1 && (o.refreshedUponExpiration = !1), t ? { opacity: 1, mix: 1 - q } : { opacity: q, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const oo = new c.aM(1, 0, 0, 1), Pi = new c.aM(0, 1, 0, 1), xs = new c.aM(0, 0, 1, 1), _n = new c.aM(1, 0, 1, 1), Jr = new c.aM(0, 1, 1, 1);
      function In(o, t, r, s) {
        On(o, 0, t + r / 2, o.transform.width, r, s);
      }
      function bs(o, t, r, s) {
        On(o, t - r / 2, 0, r, o.transform.height, s);
      }
      function On(o, t, r, s, l, h) {
        const g = o.context, _ = g.gl;
        _.enable(_.SCISSOR_TEST), _.scissor(t * o.pixelRatio, r * o.pixelRatio, s * o.pixelRatio, l * o.pixelRatio), g.clear({ color: h }), _.disable(_.SCISSOR_TEST);
      }
      function ka(o, t, r) {
        const s = o.context, l = s.gl, h = r.posMatrix, g = o.useProgram("debug"), _ = Ye.disabled, A = Ci.disabled, L = o.colorModeForRenderPass(), E = "$debug", M = o.style.map.terrain && o.style.map.terrain.getTerrainData(r);
        s.activeTexture.set(l.TEXTURE0);
        const R = t.getTileByID(r.key).latestRawTileData, q = Math.floor((R && R.byteLength || 0) / 1024), B = t.getTile(r).tileSize, $ = 512 / Math.min(B, 512) * (r.overscaledZ / o.transform.zoom) * 0.5;
        let Q = r.canonical.toString();
        r.overscaledZ !== r.canonical.z && (Q += ` => ${r.overscaledZ}`), function(tt, nt) {
          tt.initDebugOverlayCanvas();
          const it = tt.debugOverlayCanvas, ht = tt.context.gl, wt = tt.debugOverlayCanvas.getContext("2d");
          wt.clearRect(0, 0, it.width, it.height), wt.shadowColor = "white", wt.shadowBlur = 2, wt.lineWidth = 1.5, wt.strokeStyle = "white", wt.textBaseline = "top", wt.font = "bold 36px Open Sans, sans-serif", wt.fillText(nt, 5, 5), wt.strokeText(nt, 5, 5), tt.debugOverlayTexture.update(it), tt.debugOverlayTexture.bind(ht.LINEAR, ht.CLAMP_TO_EDGE);
        }(o, `${Q} ${q}kB`), g.draw(s, l.TRIANGLES, _, A, Ai.alphaBlended, Mi.disabled, wa(h, c.aM.transparent, $), null, E, o.debugBuffer, o.quadTriangleIndexBuffer, o.debugSegments), g.draw(s, l.LINE_STRIP, _, A, L, Mi.disabled, wa(h, c.aM.red), M, E, o.debugBuffer, o.tileBorderIndexBuffer, o.debugSegments);
      }
      function ws(o, t, r) {
        const s = o.context, l = s.gl, h = o.colorModeForRenderPass(), g = new Ye(l.LEQUAL, Ye.ReadWrite, o.depthRangeFor3D), _ = o.useProgram("terrain"), A = t.getTerrainMesh();
        s.bindFramebuffer.set(null), s.viewport.set([0, 0, o.width, o.height]);
        for (const L of r) {
          const E = o.renderToTexture.getTexture(L), M = t.getTerrainData(L.tileID);
          s.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, E.texture);
          const R = o.transform.calculatePosMatrix(L.tileID.toUnwrapped()), q = t.getMeshFrameDelta(o.transform.zoom), B = o.transform.calculateFogMatrix(L.tileID.toUnwrapped()), $ = Bo(R, q, B, o.style.sky, o.transform.pitch);
          _.draw(s, l.TRIANGLES, g, Ci.disabled, h, Mi.backCCW, $, M, "terrain", A.vertexBuffer, A.indexBuffer, A.segments);
        }
      }
      class ar {
        constructor(t, r, s) {
          this.vertexBuffer = t, this.indexBuffer = r, this.segments = s;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      class oa {
        constructor(t, r) {
          this.context = new Kr(t), this.transform = r, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: c.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Ce.maxUnderzooming + Ce.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fo();
        }
        resize(t, r, s) {
          if (this.width = Math.floor(t * s), this.height = Math.floor(r * s), this.pixelRatio = s, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const l of this.style._order) this.style._layers[l].resize();
        }
        setup() {
          const t = this.context, r = new c.aX();
          r.emplaceBack(0, 0), r.emplaceBack(c.X, 0), r.emplaceBack(0, c.X), r.emplaceBack(c.X, c.X), this.tileExtentBuffer = t.createVertexBuffer(r, Jn.members), this.tileExtentSegments = c.a0.simpleSegment(0, 0, 4, 2);
          const s = new c.aX();
          s.emplaceBack(0, 0), s.emplaceBack(c.X, 0), s.emplaceBack(0, c.X), s.emplaceBack(c.X, c.X), this.debugBuffer = t.createVertexBuffer(s, Jn.members), this.debugSegments = c.a0.simpleSegment(0, 0, 4, 5);
          const l = new c.$();
          l.emplaceBack(0, 0, 0, 0), l.emplaceBack(c.X, 0, c.X, 0), l.emplaceBack(0, c.X, 0, c.X), l.emplaceBack(c.X, c.X, c.X, c.X), this.rasterBoundsBuffer = t.createVertexBuffer(l, ke.members), this.rasterBoundsSegments = c.a0.simpleSegment(0, 0, 4, 2);
          const h = new c.aX();
          h.emplaceBack(0, 0), h.emplaceBack(1, 0), h.emplaceBack(0, 1), h.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(h, Jn.members), this.viewportSegments = c.a0.simpleSegment(0, 0, 4, 2);
          const g = new c.aZ();
          g.emplaceBack(0), g.emplaceBack(1), g.emplaceBack(3), g.emplaceBack(2), g.emplaceBack(0), this.tileBorderIndexBuffer = t.createIndexBuffer(g);
          const _ = new c.aY();
          _.emplaceBack(0, 1, 2), _.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(_);
          const A = this.context.gl;
          this.stencilClearMode = new Ci({ func: A.ALWAYS, mask: 0 }, 0, 255, A.ZERO, A.ZERO, A.ZERO);
        }
        clearStencil() {
          const t = this.context, r = t.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const s = c.H();
          c.aP(s, 0, this.width, this.height, 0, 0, 1), c.K(s, s, [r.drawingBufferWidth, r.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(t, r.TRIANGLES, Ye.disabled, this.stencilClearMode, Ai.disabled, Mi.disabled, Or(s), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(t, r) {
          if (this.currentStencilSource === t.source || !t.isTileClipped() || !r || !r.length) return;
          this.currentStencilSource = t.source;
          const s = this.context, l = s.gl;
          this.nextStencilID + r.length > 256 && this.clearStencil(), s.setColorMode(Ai.disabled), s.setDepthMode(Ye.disabled);
          const h = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const g of r) {
            const _ = this._tileClippingMaskIDs[g.key] = this.nextStencilID++, A = this.style.map.terrain && this.style.map.terrain.getTerrainData(g);
            h.draw(s, l.TRIANGLES, Ye.disabled, new Ci({ func: l.ALWAYS, mask: 0 }, _, 255, l.KEEP, l.KEEP, l.REPLACE), Ai.disabled, Mi.disabled, Or(g.posMatrix), A, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t = this.nextStencilID++, r = this.context.gl;
          return new Ci({ func: r.NOTEQUAL, mask: 255 }, t, 255, r.KEEP, r.KEEP, r.REPLACE);
        }
        stencilModeForClipping(t) {
          const r = this.context.gl;
          return new Ci({ func: r.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, r.KEEP, r.KEEP, r.REPLACE);
        }
        stencilConfigForOverlap(t) {
          const r = this.context.gl, s = t.sort((g, _) => _.overscaledZ - g.overscaledZ), l = s[s.length - 1].overscaledZ, h = s[0].overscaledZ - l + 1;
          if (h > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + h > 256 && this.clearStencil();
            const g = {};
            for (let _ = 0; _ < h; _++) g[_ + l] = new Ci({ func: r.GEQUAL, mask: 255 }, _ + this.nextStencilID, 255, r.KEEP, r.KEEP, r.REPLACE);
            return this.nextStencilID += h, [g, s];
          }
          return [{ [l]: Ci.disabled }, s];
        }
        colorModeForRenderPass() {
          const t = this.context.gl;
          return this._showOverdrawInspector ? new Ai([t.CONSTANT_COLOR, t.ONE], new c.aM(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Ai.unblended : Ai.alphaBlended;
        }
        depthModeForSublayer(t, r, s) {
          if (!this.opaquePassEnabledForLayer()) return Ye.disabled;
          const l = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
          return new Ye(s || this.context.gl.LEQUAL, r, [l, l]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t, r) {
          this.style = t, this.options = r, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(O.now()), this.imageManager.beginFrame();
          const s = this.style._order, l = this.style.sourceCaches, h = {}, g = {}, _ = {};
          for (const A in l) {
            const L = l[A];
            L.used && L.prepare(this.context), h[A] = L.getVisibleCoordinates(), g[A] = h[A].slice().reverse(), _[A] = L.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let A = 0; A < s.length; A++) if (this.style._layers[s[A]].is3D()) {
            this.opaquePassCutoff = A;
            break;
          }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const A of s) {
            const L = this.style._layers[A];
            if (!L.hasOffscreenPass() || L.isHidden(this.transform.zoom)) continue;
            const E = g[L.source];
            (L.type === "custom" || E.length) && this.renderLayer(this, l[L.source], L, E);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: r.showOverdrawInspector ? c.aM.black : c.aM.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(A, L) {
            const E = A.context, M = E.gl, R = ((tt, nt, it) => ({ u_sky_color: tt.properties.get("sky-color"), u_horizon_color: tt.properties.get("horizon-color"), u_horizon: (nt.height / 2 + nt.getHorizon()) * it, u_sky_horizon_blend: tt.properties.get("sky-horizon-blend") * nt.height / 2 * it }))(L, A.style.map.transform, A.pixelRatio), q = new Ye(M.LEQUAL, Ye.ReadWrite, [0, 1]), B = Ci.disabled, $ = A.colorModeForRenderPass(), Q = A.useProgram("sky");
            if (!L.mesh) {
              const tt = new c.aX();
              tt.emplaceBack(-1, -1), tt.emplaceBack(1, -1), tt.emplaceBack(1, 1), tt.emplaceBack(-1, 1);
              const nt = new c.aY();
              nt.emplaceBack(0, 1, 2), nt.emplaceBack(0, 2, 3), L.mesh = new ar(E.createVertexBuffer(tt, Jn.members), E.createIndexBuffer(nt), c.a0.simpleSegment(0, 0, tt.length, nt.length));
            }
            Q.draw(E, M.TRIANGLES, q, B, $, Mi.disabled, R, void 0, "sky", L.mesh.vertexBuffer, L.mesh.indexBuffer, L.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = r.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = s.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const A = this.style._layers[s[this.currentLayer]], L = l[A.source], E = h[A.source];
            this._renderTileClippingMasks(A, E), this.renderLayer(this, L, A, E);
          }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < s.length; this.currentLayer++) {
            const A = this.style._layers[s[this.currentLayer]], L = l[A.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(A)) continue;
            const E = (A.type === "symbol" ? _ : g)[A.source];
            this._renderTileClippingMasks(A, h[A.source]), this.renderLayer(this, L, A, E);
          }
          if (this.options.showTileBoundaries) {
            const A = function(L, E) {
              let M = null;
              const R = Object.values(L._layers).flatMap((Q) => Q.source && !Q.isHidden(E) ? [L.sourceCaches[Q.source]] : []), q = R.filter((Q) => Q.getSource().type === "vector"), B = R.filter((Q) => Q.getSource().type !== "vector"), $ = (Q) => {
                (!M || M.getSource().maxzoom < Q.getSource().maxzoom) && (M = Q);
              };
              return q.forEach((Q) => $(Q)), M || B.forEach((Q) => $(Q)), M;
            }(this.style, this.transform.zoom);
            A && function(L, E, M) {
              for (let R = 0; R < M.length; R++) ka(L, E, M[R]);
            }(this, A, A.getVisibleCoordinates());
          }
          this.options.showPadding && function(A) {
            const L = A.transform.padding;
            In(A, A.transform.height - (L.top || 0), 3, oo), In(A, L.bottom || 0, 3, Pi), bs(A, L.left || 0, 3, xs), bs(A, A.transform.width - (L.right || 0), 3, _n);
            const E = A.transform.centerPoint;
            (function(M, R, q, B) {
              On(M, R - 1, q - 10, 2, 20, B), On(M, R - 10, q - 1, 20, 2, B);
            })(A, E.x, A.transform.height - E.y, Jr);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(t) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const r = this.terrainFacilitator.matrix, s = this.transform.modelViewProjectionMatrix;
          let l = this.terrainFacilitator.dirty;
          l || (l = t ? !c.a_(r, s) : !c.a$(r, s)), l || (l = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), l && (c.b0(r, s), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(h, g) {
            const _ = h.context, A = _.gl, L = Ai.unblended, E = new Ye(A.LEQUAL, Ye.ReadWrite, [0, 1]), M = g.getTerrainMesh(), R = g.sourceCache.getRenderableTiles(), q = h.useProgram("terrainDepth");
            _.bindFramebuffer.set(g.getFramebuffer("depth").framebuffer), _.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]), _.clear({ color: c.aM.transparent, depth: 1 });
            for (const B of R) {
              const $ = g.getTerrainData(B.tileID), Q = { u_matrix: h.transform.calculatePosMatrix(B.tileID.toUnwrapped()), u_ele_delta: g.getMeshFrameDelta(h.transform.zoom) };
              q.draw(_, A.TRIANGLES, E, Ci.disabled, L, Mi.backCCW, Q, $, "terrain", M.vertexBuffer, M.indexBuffer, M.segments);
            }
            _.bindFramebuffer.set(null), _.viewport.set([0, 0, h.width, h.height]);
          }(this, this.style.map.terrain), function(h, g) {
            const _ = h.context, A = _.gl, L = Ai.unblended, E = new Ye(A.LEQUAL, Ye.ReadWrite, [0, 1]), M = g.getTerrainMesh(), R = g.getCoordsTexture(), q = g.sourceCache.getRenderableTiles(), B = h.useProgram("terrainCoords");
            _.bindFramebuffer.set(g.getFramebuffer("coords").framebuffer), _.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]), _.clear({ color: c.aM.transparent, depth: 1 }), g.coordsIndex = [];
            for (const $ of q) {
              const Q = g.getTerrainData($.tileID);
              _.activeTexture.set(A.TEXTURE0), A.bindTexture(A.TEXTURE_2D, R.texture);
              const tt = { u_matrix: h.transform.calculatePosMatrix($.tileID.toUnwrapped()), u_terrain_coords_id: (255 - g.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: g.getMeshFrameDelta(h.transform.zoom) };
              B.draw(_, A.TRIANGLES, E, Ci.disabled, L, Mi.backCCW, tt, Q, "terrain", M.vertexBuffer, M.indexBuffer, M.segments), g.coordsIndex.push($.tileID.key);
            }
            _.bindFramebuffer.set(null), _.viewport.set([0, 0, h.width, h.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(t, r, s, l) {
          if (!s.isHidden(this.transform.zoom) && (s.type === "background" || s.type === "custom" || (l || []).length)) switch (this.id = s.id, s.type) {
            case "symbol":
              (function(h, g, _, A, L) {
                if (h.renderPass !== "translucent") return;
                const E = Ci.disabled, M = h.colorModeForRenderPass();
                (_._unevaluatedLayout.hasValue("text-variable-anchor") || _._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(R, q, B, $, Q, tt, nt, it, ht) {
                  const wt = q.transform, _t = Dn(), Vt = Q === "map", re = tt === "map";
                  for (const ce of R) {
                    const de = $.getTile(ce), ue = de.getBucket(B);
                    if (!ue || !ue.text || !ue.text.segments.get().length) continue;
                    const he = c.ag(ue.textSizeData, wt.zoom), fe = pi(de, 1, q.transform.zoom), Oe = Mr(ce.posMatrix, re, Vt, q.transform, fe), ve = B.layout.get("icon-text-fit") !== "none" && ue.hasIconData();
                    if (he) {
                      const xe = Math.pow(2, wt.zoom - de.tileID.overscaledZ), Ue = q.style.map.terrain ? (ii, ci) => q.style.map.terrain.getElevation(ce, ii, ci) : null, ni = _t.translatePosition(wt, de, nt, it);
                      vs(ue, Vt, re, ht, wt, Oe, ce.posMatrix, xe, he, ve, _t, ni, ce.toUnwrapped(), Ue);
                    }
                  }
                }(A, h, _, g, _.layout.get("text-rotation-alignment"), _.layout.get("text-pitch-alignment"), _.paint.get("text-translate"), _.paint.get("text-translate-anchor"), L), _.paint.get("icon-opacity").constantOr(1) !== 0 && Lr(h, g, _, A, !1, _.paint.get("icon-translate"), _.paint.get("icon-translate-anchor"), _.layout.get("icon-rotation-alignment"), _.layout.get("icon-pitch-alignment"), _.layout.get("icon-keep-upright"), E, M), _.paint.get("text-opacity").constantOr(1) !== 0 && Lr(h, g, _, A, !0, _.paint.get("text-translate"), _.paint.get("text-translate-anchor"), _.layout.get("text-rotation-alignment"), _.layout.get("text-pitch-alignment"), _.layout.get("text-keep-upright"), E, M), g.map.showCollisionBoxes && (Fs(h, g, _, A, !0), Fs(h, g, _, A, !1));
              })(t, r, s, l, this.style.placement.variableOffsets);
              break;
            case "circle":
              (function(h, g, _, A) {
                if (h.renderPass !== "translucent") return;
                const L = _.paint.get("circle-opacity"), E = _.paint.get("circle-stroke-width"), M = _.paint.get("circle-stroke-opacity"), R = !_.layout.get("circle-sort-key").isConstant();
                if (L.constantOr(1) === 0 && (E.constantOr(1) === 0 || M.constantOr(1) === 0)) return;
                const q = h.context, B = q.gl, $ = h.depthModeForSublayer(0, Ye.ReadOnly), Q = Ci.disabled, tt = h.colorModeForRenderPass(), nt = [];
                for (let it = 0; it < A.length; it++) {
                  const ht = A[it], wt = g.getTile(ht), _t = wt.getBucket(_);
                  if (!_t) continue;
                  const Vt = _t.programConfigurations.get(_.id), re = h.useProgram("circle", Vt), ce = _t.layoutVertexBuffer, de = _t.indexBuffer, ue = h.style.map.terrain && h.style.map.terrain.getTerrainData(ht), he = { programConfiguration: Vt, program: re, layoutVertexBuffer: ce, indexBuffer: de, uniformValues: cl(h, ht, wt, _), terrainData: ue };
                  if (R) {
                    const fe = _t.segments.get();
                    for (const Oe of fe) nt.push({ segments: new c.a0([Oe]), sortKey: Oe.sortKey, state: he });
                  } else nt.push({ segments: _t.segments, sortKey: 0, state: he });
                }
                R && nt.sort((it, ht) => it.sortKey - ht.sortKey);
                for (const it of nt) {
                  const { programConfiguration: ht, program: wt, layoutVertexBuffer: _t, indexBuffer: Vt, uniformValues: re, terrainData: ce } = it.state;
                  wt.draw(q, B.TRIANGLES, $, Q, tt, Mi.disabled, re, ce, _.id, _t, Vt, it.segments, _.paint, h.transform.zoom, ht);
                }
              })(t, r, s, l);
              break;
            case "heatmap":
              (function(h, g, _, A) {
                if (_.paint.get("heatmap-opacity") === 0) return;
                const L = h.context;
                if (h.style.map.terrain) {
                  for (const E of A) {
                    const M = g.getTile(E);
                    g.hasRenderableParent(E) || (h.renderPass === "offscreen" ? sa(h, M, _, E) : h.renderPass === "translucent" && Rn(h, _, E));
                  }
                  L.viewport.set([0, 0, h.width, h.height]);
                } else h.renderPass === "offscreen" ? function(E, M, R, q) {
                  const B = E.context, $ = B.gl, Q = Ci.disabled, tt = new Ai([$.ONE, $.ONE], c.aM.transparent, [!0, !0, !0, !0]);
                  (function(nt, it, ht) {
                    const wt = nt.gl;
                    nt.activeTexture.set(wt.TEXTURE1), nt.viewport.set([0, 0, it.width / 4, it.height / 4]);
                    let _t = ht.heatmapFbos.get(c.aU);
                    _t ? (wt.bindTexture(wt.TEXTURE_2D, _t.colorAttachment.get()), nt.bindFramebuffer.set(_t.framebuffer)) : (_t = Rs(nt, it.width / 4, it.height / 4), ht.heatmapFbos.set(c.aU, _t));
                  })(B, E, R), B.clear({ color: c.aM.transparent });
                  for (let nt = 0; nt < q.length; nt++) {
                    const it = q[nt];
                    if (M.hasRenderableParent(it)) continue;
                    const ht = M.getTile(it), wt = ht.getBucket(R);
                    if (!wt) continue;
                    const _t = wt.programConfigurations.get(R.id), Vt = E.useProgram("heatmap", _t), { zoom: re } = E.transform;
                    Vt.draw(B, $.TRIANGLES, Ye.disabled, Q, tt, Mi.disabled, He(it.posMatrix, ht, re, R.paint.get("heatmap-intensity")), null, R.id, wt.layoutVertexBuffer, wt.indexBuffer, wt.segments, R.paint, E.transform.zoom, _t);
                  }
                  B.viewport.set([0, 0, E.width, E.height]);
                }(h, g, _, A) : h.renderPass === "translucent" && function(E, M) {
                  const R = E.context, q = R.gl;
                  R.setColorMode(E.colorModeForRenderPass());
                  const B = M.heatmapFbos.get(c.aU);
                  B && (R.activeTexture.set(q.TEXTURE0), q.bindTexture(q.TEXTURE_2D, B.colorAttachment.get()), R.activeTexture.set(q.TEXTURE1), zr(R, M).bind(q.LINEAR, q.CLAMP_TO_EDGE), E.useProgram("heatmapTexture").draw(R, q.TRIANGLES, Ye.disabled, Ci.disabled, E.colorModeForRenderPass(), Mi.disabled, Xa(E, M, 0, 1), null, M.id, E.viewportBuffer, E.quadTriangleIndexBuffer, E.viewportSegments, M.paint, E.transform.zoom));
                }(h, _);
              })(t, r, s, l);
              break;
            case "line":
              (function(h, g, _, A) {
                if (h.renderPass !== "translucent") return;
                const L = _.paint.get("line-opacity"), E = _.paint.get("line-width");
                if (L.constantOr(1) === 0 || E.constantOr(1) === 0) return;
                const M = h.depthModeForSublayer(0, Ye.ReadOnly), R = h.colorModeForRenderPass(), q = _.paint.get("line-dasharray"), B = _.paint.get("line-pattern"), $ = B.constantOr(1), Q = _.paint.get("line-gradient"), tt = _.getCrossfadeParameters(), nt = $ ? "linePattern" : q ? "lineSDF" : Q ? "lineGradient" : "line", it = h.context, ht = it.gl;
                let wt = !0;
                for (const _t of A) {
                  const Vt = g.getTile(_t);
                  if ($ && !Vt.patternsLoaded()) continue;
                  const re = Vt.getBucket(_);
                  if (!re) continue;
                  const ce = re.programConfigurations.get(_.id), de = h.context.program.get(), ue = h.useProgram(nt, ce), he = wt || ue.program !== de, fe = h.style.map.terrain && h.style.map.terrain.getTerrainData(_t), Oe = B.constantOr(null);
                  if (Oe && Vt.imageAtlas) {
                    const Ue = Vt.imageAtlas, ni = Ue.patternPositions[Oe.to.toString()], ii = Ue.patternPositions[Oe.from.toString()];
                    ni && ii && ce.setConstantPatternPositions(ni, ii);
                  }
                  const ve = fe ? _t : null, xe = $ ? Ns(h, Vt, _, tt, ve) : q ? Ya(h, Vt, _, q, tt, ve) : Q ? Oo(h, Vt, _, re.lineClipsArray.length, ve) : An(h, Vt, _, ve);
                  if ($) it.activeTexture.set(ht.TEXTURE0), Vt.imageAtlasTexture.bind(ht.LINEAR, ht.CLAMP_TO_EDGE), ce.updatePaintBuffers(tt);
                  else if (q && (he || h.lineAtlas.dirty)) it.activeTexture.set(ht.TEXTURE0), h.lineAtlas.bind(it);
                  else if (Q) {
                    const Ue = re.gradients[_.id];
                    let ni = Ue.texture;
                    if (_.gradientVersion !== Ue.version) {
                      let ii = 256;
                      if (_.stepInterpolant) {
                        const ci = g.getSource().maxzoom, bi = _t.canonical.z === ci ? Math.ceil(1 << h.transform.maxZoom - _t.canonical.z) : 1;
                        ii = c.ac(c.aV(re.maxLineLength / c.X * 1024 * bi), 256, it.maxTextureSize);
                      }
                      Ue.gradient = c.aW({ expression: _.gradientExpression(), evaluationKey: "lineProgress", resolution: ii, image: Ue.gradient || void 0, clips: re.lineClipsArray }), Ue.texture ? Ue.texture.update(Ue.gradient) : Ue.texture = new at(it, Ue.gradient, ht.RGBA), Ue.version = _.gradientVersion, ni = Ue.texture;
                    }
                    it.activeTexture.set(ht.TEXTURE0), ni.bind(_.stepInterpolant ? ht.NEAREST : ht.LINEAR, ht.CLAMP_TO_EDGE);
                  }
                  ue.draw(it, ht.TRIANGLES, M, h.stencilModeForClipping(_t), R, Mi.disabled, xe, fe, _.id, re.layoutVertexBuffer, re.indexBuffer, re.segments, _.paint, h.transform.zoom, ce, re.layoutVertexBuffer2), wt = !1;
                }
              })(t, r, s, l);
              break;
            case "fill":
              (function(h, g, _, A) {
                const L = _.paint.get("fill-color"), E = _.paint.get("fill-opacity");
                if (E.constantOr(1) === 0) return;
                const M = h.colorModeForRenderPass(), R = _.paint.get("fill-pattern"), q = h.opaquePassEnabledForLayer() && !R.constantOr(1) && L.constantOr(c.aM.transparent).a === 1 && E.constantOr(0) === 1 ? "opaque" : "translucent";
                if (h.renderPass === q) {
                  const B = h.depthModeForSublayer(1, h.renderPass === "opaque" ? Ye.ReadWrite : Ye.ReadOnly);
                  Os(h, g, _, A, B, M, !1);
                }
                if (h.renderPass === "translucent" && _.paint.get("fill-antialias")) {
                  const B = h.depthModeForSublayer(_.getPaintProperty("fill-outline-color") ? 2 : 0, Ye.ReadOnly);
                  Os(h, g, _, A, B, M, !0);
                }
              })(t, r, s, l);
              break;
            case "fill-extrusion":
              (function(h, g, _, A) {
                const L = _.paint.get("fill-extrusion-opacity");
                if (L !== 0 && h.renderPass === "translucent") {
                  const E = new Ye(h.context.gl.LEQUAL, Ye.ReadWrite, h.depthRangeFor3D);
                  if (L !== 1 || _.paint.get("fill-extrusion-pattern").constantOr(1)) Ia(h, g, _, A, E, Ci.disabled, Ai.disabled), Ia(h, g, _, A, E, h.stencilModeFor3D(), h.colorModeForRenderPass());
                  else {
                    const M = h.colorModeForRenderPass();
                    Ia(h, g, _, A, E, Ci.disabled, M);
                  }
                }
              })(t, r, s, l);
              break;
            case "hillshade":
              (function(h, g, _, A) {
                if (h.renderPass !== "offscreen" && h.renderPass !== "translucent") return;
                const L = h.context, E = h.depthModeForSublayer(0, Ye.ReadOnly), M = h.colorModeForRenderPass(), [R, q] = h.renderPass === "translucent" ? h.stencilConfigForOverlap(A) : [{}, A];
                for (const B of q) {
                  const $ = g.getTile(B);
                  $.needsHillshadePrepare !== void 0 && $.needsHillshadePrepare && h.renderPass === "offscreen" ? ns(h, $, _, E, Ci.disabled, M) : h.renderPass === "translucent" && qr(h, B, $, _, E, R[B.overscaledZ], M);
                }
                L.viewport.set([0, 0, h.width, h.height]);
              })(t, r, s, l);
              break;
            case "raster":
              (function(h, g, _, A) {
                if (h.renderPass !== "translucent" || _.paint.get("raster-opacity") === 0 || !A.length) return;
                const L = h.context, E = L.gl, M = g.getSource(), R = h.useProgram("raster"), q = h.colorModeForRenderPass(), [B, $] = M instanceof Ze ? [{}, A] : h.stencilConfigForOverlap(A), Q = $[$.length - 1].overscaledZ, tt = !h.options.moving;
                for (const nt of $) {
                  const it = h.depthModeForSublayer(nt.overscaledZ - Q, _.paint.get("raster-opacity") === 1 ? Ye.ReadWrite : Ye.ReadOnly, E.LESS), ht = g.getTile(nt);
                  ht.registerFadeDuration(_.paint.get("raster-fade-duration"));
                  const wt = g.findLoadedParent(nt, 0), _t = g.findLoadedSibling(nt), Vt = Go(ht, wt || _t || null, g, _, h.transform, h.style.map.terrain);
                  let re, ce;
                  const de = _.paint.get("raster-resampling") === "nearest" ? E.NEAREST : E.LINEAR;
                  L.activeTexture.set(E.TEXTURE0), ht.texture.bind(de, E.CLAMP_TO_EDGE, E.LINEAR_MIPMAP_NEAREST), L.activeTexture.set(E.TEXTURE1), wt ? (wt.texture.bind(de, E.CLAMP_TO_EDGE, E.LINEAR_MIPMAP_NEAREST), re = Math.pow(2, wt.tileID.overscaledZ - ht.tileID.overscaledZ), ce = [ht.tileID.canonical.x * re % 1, ht.tileID.canonical.y * re % 1]) : ht.texture.bind(de, E.CLAMP_TO_EDGE, E.LINEAR_MIPMAP_NEAREST), ht.texture.useMipmap && L.extTextureFilterAnisotropic && h.transform.pitch > 20 && E.texParameterf(E.TEXTURE_2D, L.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, L.extTextureFilterAnisotropicMax);
                  const ue = h.style.map.terrain && h.style.map.terrain.getTerrainData(nt), he = ue ? nt : null, fe = he ? he.posMatrix : h.transform.calculatePosMatrix(nt.toUnwrapped(), tt), Oe = El(fe, ce || [0, 0], re || 1, Vt, _);
                  M instanceof Ze ? R.draw(L, E.TRIANGLES, it, Ci.disabled, q, Mi.disabled, Oe, ue, _.id, M.boundsBuffer, h.quadTriangleIndexBuffer, M.boundsSegments) : R.draw(L, E.TRIANGLES, it, B[nt.overscaledZ], q, Mi.disabled, Oe, ue, _.id, h.rasterBoundsBuffer, h.quadTriangleIndexBuffer, h.rasterBoundsSegments);
                }
              })(t, r, s, l);
              break;
            case "background":
              (function(h, g, _, A) {
                const L = _.paint.get("background-color"), E = _.paint.get("background-opacity");
                if (E === 0) return;
                const M = h.context, R = M.gl, q = h.transform, B = q.tileSize, $ = _.paint.get("background-pattern");
                if (h.isPatternMissing($)) return;
                const Q = !$ && L.a === 1 && E === 1 && h.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (h.renderPass !== Q) return;
                const tt = Ci.disabled, nt = h.depthModeForSublayer(0, Q === "opaque" ? Ye.ReadWrite : Ye.ReadOnly), it = h.colorModeForRenderPass(), ht = h.useProgram($ ? "backgroundPattern" : "background"), wt = A || q.coveringTiles({ tileSize: B, terrain: h.style.map.terrain });
                $ && (M.activeTexture.set(R.TEXTURE0), h.imageManager.bind(h.context));
                const _t = _.getCrossfadeParameters();
                for (const Vt of wt) {
                  const re = A ? Vt.posMatrix : h.transform.calculatePosMatrix(Vt.toUnwrapped()), ce = $ ? Ds(re, E, h, $, { tileID: Vt, tileSize: B }, _t) : Qa(re, E, L), de = h.style.map.terrain && h.style.map.terrain.getTerrainData(Vt);
                  ht.draw(M, R.TRIANGLES, nt, tt, it, Mi.disabled, ce, de, _.id, h.tileExtentBuffer, h.quadTriangleIndexBuffer, h.tileExtentSegments);
                }
              })(t, 0, s, l);
              break;
            case "custom":
              (function(h, g, _) {
                const A = h.context, L = _.implementation;
                if (h.renderPass === "offscreen") {
                  const E = L.prerender;
                  E && (h.setCustomLayerDefaults(), A.setColorMode(h.colorModeForRenderPass()), E.call(L, A.gl, h.transform.customLayerMatrix()), A.setDirty(), h.setBaseState());
                } else if (h.renderPass === "translucent") {
                  h.setCustomLayerDefaults(), A.setColorMode(h.colorModeForRenderPass()), A.setStencilMode(Ci.disabled);
                  const E = L.renderingMode === "3d" ? new Ye(h.context.gl.LEQUAL, Ye.ReadWrite, h.depthRangeFor3D) : h.depthModeForSublayer(0, Ye.ReadOnly);
                  A.setDepthMode(E), L.render(A.gl, h.transform.customLayerMatrix(), { farZ: h.transform.farZ, nearZ: h.transform.nearZ, fov: h.transform._fov, modelViewProjectionMatrix: h.transform.modelViewProjectionMatrix, projectionMatrix: h.transform.projectionMatrix }), A.setDirty(), h.setBaseState(), A.bindFramebuffer.set(null);
                }
              })(t, 0, s);
          }
        }
        translatePosMatrix(t, r, s, l, h) {
          if (!s[0] && !s[1]) return t;
          const g = h ? l === "map" ? this.transform.angle : 0 : l === "viewport" ? -this.transform.angle : 0;
          if (g) {
            const L = Math.sin(g), E = Math.cos(g);
            s = [s[0] * E - s[1] * L, s[0] * L + s[1] * E];
          }
          const _ = [h ? s[0] : pi(r, s[0], this.transform.zoom), h ? s[1] : pi(r, s[1], this.transform.zoom), 0], A = new Float32Array(16);
          return c.J(A, t, _), A;
        }
        saveTileTexture(t) {
          const r = this._tileTextures[t.size[0]];
          r ? r.push(t) : this._tileTextures[t.size[0]] = [t];
        }
        getTileTexture(t) {
          const r = this._tileTextures[t];
          return r && r.length > 0 ? r.pop() : null;
        }
        isPatternMissing(t) {
          if (!t) return !1;
          if (!t.from || !t.to) return !0;
          const r = this.imageManager.getPattern(t.from.toString()), s = this.imageManager.getPattern(t.to.toString());
          return !r || !s;
        }
        useProgram(t, r) {
          this.cache = this.cache || {};
          const s = t + (r ? r.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[s] || (this.cache[s] = new Ro(this.context, Qn[t], r, Sa[t], this._showOverdrawInspector, this.style.map.terrain)), this.cache[s];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new at(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: t, drawingBufferHeight: r } = this.context.gl;
          return this.width !== t || this.height !== r;
        }
      }
      class Pr {
        constructor(t, r) {
          this.points = t, this.planes = r;
        }
        static fromInvProjectionMatrix(t, r, s) {
          const l = Math.pow(2, s), h = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((_) => {
            const A = 1 / (_ = c.af([], _, t))[3] / r * l;
            return c.b1(_, _, [A, A, 1 / _[3], A]);
          }), g = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((_) => {
            const A = function(R, q) {
              var B = q[0], $ = q[1], Q = q[2], tt = B * B + $ * $ + Q * Q;
              return tt > 0 && (tt = 1 / Math.sqrt(tt)), R[0] = q[0] * tt, R[1] = q[1] * tt, R[2] = q[2] * tt, R;
            }([], function(R, q, B) {
              var $ = q[0], Q = q[1], tt = q[2], nt = B[0], it = B[1], ht = B[2];
              return R[0] = Q * ht - tt * it, R[1] = tt * nt - $ * ht, R[2] = $ * it - Q * nt, R;
            }([], Ot([], h[_[0]], h[_[1]]), Ot([], h[_[2]], h[_[1]]))), L = -((E = A)[0] * (M = h[_[1]])[0] + E[1] * M[1] + E[2] * M[2]);
            var E, M;
            return A.concat(L);
          });
          return new Pr(h, g);
        }
      }
      class Ur {
        constructor(t, r) {
          this.min = t, this.max = r, this.center = function(s, l, h) {
            return s[0] = 0.5 * l[0], s[1] = 0.5 * l[1], s[2] = 0.5 * l[2], s;
          }([], function(s, l, h) {
            return s[0] = l[0] + h[0], s[1] = l[1] + h[1], s[2] = l[2] + h[2], s;
          }([], this.min, this.max));
        }
        quadrant(t) {
          const r = [t % 2 == 0, t < 2], s = Kt(this.min), l = Kt(this.max);
          for (let h = 0; h < r.length; h++) s[h] = r[h] ? this.min[h] : this.center[h], l[h] = r[h] ? this.center[h] : this.max[h];
          return l[2] = this.max[2], new Ur(s, l);
        }
        distanceX(t) {
          return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
        }
        distanceY(t) {
          return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
        }
        intersects(t) {
          const r = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let s = !0;
          for (let l = 0; l < t.planes.length; l++) {
            const h = t.planes[l];
            let g = 0;
            for (let _ = 0; _ < r.length; _++) c.b2(h, r[_]) >= 0 && g++;
            if (g === 0) return 0;
            g !== r.length && (s = !1);
          }
          if (s) return 2;
          for (let l = 0; l < 3; l++) {
            let h = Number.MAX_VALUE, g = -Number.MAX_VALUE;
            for (let _ = 0; _ < t.points.length; _++) {
              const A = t.points[_][l] - this.min[l];
              h = Math.min(h, A), g = Math.max(g, A);
            }
            if (g < 0 || h > this.max[l] - this.min[l]) return 0;
          }
          return 1;
        }
      }
      class ss {
        constructor(t = 0, r = 0, s = 0, l = 0) {
          if (isNaN(t) || t < 0 || isNaN(r) || r < 0 || isNaN(s) || s < 0 || isNaN(l) || l < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = t, this.bottom = r, this.left = s, this.right = l;
        }
        interpolate(t, r, s) {
          return r.top != null && t.top != null && (this.top = c.y.number(t.top, r.top, s)), r.bottom != null && t.bottom != null && (this.bottom = c.y.number(t.bottom, r.bottom, s)), r.left != null && t.left != null && (this.left = c.y.number(t.left, r.left, s)), r.right != null && t.right != null && (this.right = c.y.number(t.right, r.right, s)), this;
        }
        getCenter(t, r) {
          const s = c.ac((this.left + t - this.right) / 2, 0, t), l = c.ac((this.top + r - this.bottom) / 2, 0, r);
          return new c.P(s, l);
        }
        equals(t) {
          return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
        }
        clone() {
          return new ss(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const lo = 85.051129;
      class Ss {
        constructor(t, r, s, l, h) {
          this.tileSize = 512, this._renderWorldCopies = h === void 0 || !!h, this._minZoom = t || 0, this._maxZoom = r || 22, this._minPitch = s ?? 0, this._maxPitch = l ?? 60, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new c.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = !0, this._edgeInsets = new ss(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const t = new Ss(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return t.apply(this), t;
        }
        apply(t) {
          this.tileSize = t.tileSize, this.latRange = t.latRange, this.lngRange = t.lngRange, this.width = t.width, this.height = t.height, this._center = t._center, this._elevation = t._elevation, this.minElevationForCurrentTile = t.minElevationForCurrentTile, this.zoom = t.zoom, this.angle = t.angle, this._fov = t._fov, this._pitch = t._pitch, this._unmodified = t._unmodified, this._edgeInsets = t._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(t) {
          this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(t) {
          this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(t) {
          this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(t) {
          this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(t) {
          t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new c.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(t) {
          const r = -c.b3(t, -180, 180) * Math.PI / 180;
          this.angle !== r && (this._unmodified = !1, this.angle = r, this._calcMatrices(), this.rotationMatrix = function() {
            var s = new c.A(4);
            return c.A != Float32Array && (s[1] = 0, s[2] = 0), s[0] = 1, s[3] = 1, s;
          }(), function(s, l, h) {
            var g = l[0], _ = l[1], A = l[2], L = l[3], E = Math.sin(h), M = Math.cos(h);
            s[0] = g * M + A * E, s[1] = _ * M + L * E, s[2] = g * -E + A * M, s[3] = _ * -E + L * M;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t) {
          const r = c.ac(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== r && (this._unmodified = !1, this._pitch = r, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(t) {
          t = Math.max(0.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = t / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(t) {
          const r = Math.min(Math.max(t, this.minZoom), this.maxZoom);
          this._zoom !== r && (this._unmodified = !1, this._zoom = r, this.tileZoom = Math.max(0, Math.floor(r)), this.scale = this.zoomScale(r), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(t) {
          t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(t) {
          t !== this._elevation && (this._elevation = t, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(t) {
          this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(t) {
          return this._edgeInsets.equals(t);
        }
        interpolatePadding(t, r, s) {
          this._unmodified = !1, this._edgeInsets.interpolate(t, r, s), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(t) {
          const r = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
          return Math.max(0, r);
        }
        getVisibleUnwrappedCoordinates(t) {
          const r = [new c.b4(0, t)];
          if (this._renderWorldCopies) {
            const s = this.pointCoordinate(new c.P(0, 0)), l = this.pointCoordinate(new c.P(this.width, 0)), h = this.pointCoordinate(new c.P(this.width, this.height)), g = this.pointCoordinate(new c.P(0, this.height)), _ = Math.floor(Math.min(s.x, l.x, h.x, g.x)), A = Math.floor(Math.max(s.x, l.x, h.x, g.x)), L = 1;
            for (let E = _ - L; E <= A + L; E++) E !== 0 && r.push(new c.b4(E, t));
          }
          return r;
        }
        coveringTiles(t) {
          var r, s;
          let l = this.coveringZoomLevel(t);
          const h = l;
          if (t.minzoom !== void 0 && l < t.minzoom) return [];
          t.maxzoom !== void 0 && l > t.maxzoom && (l = t.maxzoom);
          const g = this.pointCoordinate(this.getCameraPoint()), _ = c.Z.fromLngLat(this.center), A = Math.pow(2, l), L = [A * g.x, A * g.y, 0], E = [A * _.x, A * _.y, 0], M = Pr.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, l);
          let R = t.minzoom || 0;
          !t.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (R = l);
          const q = t.terrain ? 2 / Math.min(this.tileSize, t.tileSize) * this.tileSize : 3, B = (it) => ({ aabb: new Ur([it * A, 0, 0], [(it + 1) * A, A, 0]), zoom: 0, x: 0, y: 0, wrap: it, fullyVisible: !1 }), $ = [], Q = [], tt = l, nt = t.reparseOverscaled ? h : l;
          if (this._renderWorldCopies) for (let it = 1; it <= 3; it++) $.push(B(-it)), $.push(B(it));
          for ($.push(B(0)); $.length > 0; ) {
            const it = $.pop(), ht = it.x, wt = it.y;
            let _t = it.fullyVisible;
            if (!_t) {
              const ue = it.aabb.intersects(M);
              if (ue === 0) continue;
              _t = ue === 2;
            }
            const Vt = t.terrain ? L : E, re = it.aabb.distanceX(Vt), ce = it.aabb.distanceY(Vt), de = Math.max(Math.abs(re), Math.abs(ce));
            if (it.zoom === tt || de > q + (1 << tt - it.zoom) - 2 && it.zoom >= R) {
              const ue = tt - it.zoom, he = L[0] - 0.5 - (ht << ue), fe = L[1] - 0.5 - (wt << ue);
              Q.push({ tileID: new c.S(it.zoom === tt ? nt : it.zoom, it.wrap, it.zoom, ht, wt), distanceSq: kt([E[0] - 0.5 - ht, E[1] - 0.5 - wt]), tileDistanceToCamera: Math.sqrt(he * he + fe * fe) });
            } else for (let ue = 0; ue < 4; ue++) {
              const he = (ht << 1) + ue % 2, fe = (wt << 1) + (ue >> 1), Oe = it.zoom + 1;
              let ve = it.aabb.quadrant(ue);
              if (t.terrain) {
                const xe = new c.S(Oe, it.wrap, Oe, he, fe), Ue = t.terrain.getMinMaxElevation(xe), ni = (r = Ue.minElevation) !== null && r !== void 0 ? r : this.elevation, ii = (s = Ue.maxElevation) !== null && s !== void 0 ? s : this.elevation;
                ve = new Ur([ve.min[0], ve.min[1], ni], [ve.max[0], ve.max[1], ii]);
              }
              $.push({ aabb: ve, zoom: Oe, x: he, y: fe, wrap: it.wrap, fullyVisible: _t });
            }
          }
          return Q.sort((it, ht) => it.distanceSq - ht.distanceSq).map((it) => it.tileID);
        }
        resize(t, r) {
          this.width = t, this.height = r, this.pixelsToGLUnits = [2 / t, -2 / r], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(t) {
          return Math.pow(2, t);
        }
        scaleZoom(t) {
          return Math.log(t) / Math.LN2;
        }
        project(t) {
          const r = c.ac(t.lat, -85.051129, lo);
          return new c.P(c.O(t.lng) * this.worldSize, c.Q(r) * this.worldSize);
        }
        unproject(t) {
          return new c.Z(t.x / this.worldSize, t.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(t) {
          const r = this.elevation, s = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, l = this.pointLocation(this.centerPoint, t), h = t.getElevationForLngLatZoom(l, this.tileZoom);
          if (!(this.elevation - h)) return;
          const g = s + r - h, _ = Math.cos(this._pitch) * this.cameraToCenterDistance / g / c.b5(1, l.lat), A = this.scaleZoom(_ / this.tileSize);
          this._elevation = h, this._center = l, this.zoom = A;
        }
        setLocationAtPoint(t, r) {
          const s = this.pointCoordinate(r), l = this.pointCoordinate(this.centerPoint), h = this.locationCoordinate(t), g = new c.Z(h.x - (s.x - l.x), h.y - (s.y - l.y));
          this.center = this.coordinateLocation(g), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(t, r) {
          return r ? this.coordinatePoint(this.locationCoordinate(t), r.getElevationForLngLatZoom(t, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t));
        }
        pointLocation(t, r) {
          return this.coordinateLocation(this.pointCoordinate(t, r));
        }
        locationCoordinate(t) {
          return c.Z.fromLngLat(t);
        }
        coordinateLocation(t) {
          return t && t.toLngLat();
        }
        pointCoordinate(t, r) {
          if (r) {
            const R = r.pointCoordinate(t);
            if (R != null) return R;
          }
          const s = [t.x, t.y, 0, 1], l = [t.x, t.y, 1, 1];
          c.af(s, s, this.pixelMatrixInverse), c.af(l, l, this.pixelMatrixInverse);
          const h = s[3], g = l[3], _ = s[1] / h, A = l[1] / g, L = s[2] / h, E = l[2] / g, M = L === E ? 0 : (0 - L) / (E - L);
          return new c.Z(c.y.number(s[0] / h, l[0] / g, M) / this.worldSize, c.y.number(_, A, M) / this.worldSize);
        }
        coordinatePoint(t, r = 0, s = this.pixelMatrix) {
          const l = [t.x * this.worldSize, t.y * this.worldSize, r, 1];
          return c.af(l, l, s), new c.P(l[0] / l[3], l[1] / l[3]);
        }
        getBounds() {
          const t = Math.max(0, this.height / 2 - this.getHorizon());
          return new Y().extend(this.pointLocation(new c.P(0, t))).extend(this.pointLocation(new c.P(this.width, t))).extend(this.pointLocation(new c.P(this.width, this.height))).extend(this.pointLocation(new c.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new Y([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(t) {
          t ? (this.lngRange = [t.getWest(), t.getEast()], this.latRange = [t.getSouth(), t.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, lo]);
        }
        calculateTileMatrix(t) {
          const r = t.canonical, s = this.worldSize / this.zoomScale(r.z), l = r.x + Math.pow(2, r.z) * t.wrap, h = c.an(new Float64Array(16));
          return c.J(h, h, [l * s, r.y * s, 0]), c.K(h, h, [s / c.X, s / c.X, 1]), h;
        }
        calculatePosMatrix(t, r = !1) {
          const s = t.key, l = r ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (l[s]) return l[s];
          const h = this.calculateTileMatrix(t);
          return c.L(h, r ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, h), l[s] = new Float32Array(h), l[s];
        }
        calculateFogMatrix(t) {
          const r = t.key, s = this._fogMatrixCache;
          if (s[r]) return s[r];
          const l = this.calculateTileMatrix(t);
          return c.L(l, this.fogMatrix, l), s[r] = new Float32Array(l), s[r];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(t, r) {
          r = c.ac(+r, this.minZoom, this.maxZoom);
          const s = { center: new c.N(t.lng, t.lat), zoom: r };
          let l = this.lngRange;
          if (!this._renderWorldCopies && l === null) {
            const it = 179.9999999999;
            l = [-it, it];
          }
          const h = this.tileSize * this.zoomScale(s.zoom);
          let g = 0, _ = h, A = 0, L = h, E = 0, M = 0;
          const { x: R, y: q } = this.size;
          if (this.latRange) {
            const it = this.latRange;
            g = c.Q(it[1]) * h, _ = c.Q(it[0]) * h, _ - g < q && (E = q / (_ - g));
          }
          l && (A = c.b3(c.O(l[0]) * h, 0, h), L = c.b3(c.O(l[1]) * h, 0, h), L < A && (L += h), L - A < R && (M = R / (L - A)));
          const { x: B, y: $ } = this.project.call({ worldSize: h }, t);
          let Q, tt;
          const nt = Math.max(M || 0, E || 0);
          if (nt) {
            const it = new c.P(M ? (L + A) / 2 : B, E ? (_ + g) / 2 : $);
            return s.center = this.unproject.call({ worldSize: h }, it).wrap(), s.zoom += this.scaleZoom(nt), s;
          }
          if (this.latRange) {
            const it = q / 2;
            $ - it < g && (tt = g + it), $ + it > _ && (tt = _ - it);
          }
          if (l) {
            const it = (A + L) / 2;
            let ht = B;
            this._renderWorldCopies && (ht = c.b3(B, it - h / 2, it + h / 2));
            const wt = R / 2;
            ht - wt < A && (Q = A + wt), ht + wt > L && (Q = L - wt);
          }
          if (Q !== void 0 || tt !== void 0) {
            const it = new c.P(Q ?? B, tt ?? $);
            s.center = this.unproject.call({ worldSize: h }, it).wrap();
          }
          return s;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const t = this._unmodified, { center: r, zoom: s } = this.getConstrained(this.center, this.zoom);
          this.center = r, this.zoom = s, this._unmodified = t, this._constraining = !1;
        }
        _calcMatrices() {
          if (!this.height) return;
          const t = this.centerOffset, r = this.point.x, s = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = c.b5(1, this.center.lat) * this.worldSize;
          let l = c.an(new Float64Array(16));
          c.K(l, l, [this.width / 2, -this.height / 2, 1]), c.J(l, l, [1, -1, 0]), this.labelPlaneMatrix = l, l = c.an(new Float64Array(16)), c.K(l, l, [1, -1, 1]), c.J(l, l, [-1, -1, 0]), c.K(l, l, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = l;
          const h = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), g = Math.min(this.elevation, this.minElevationForCurrentTile), _ = h - g * this._pixelPerMeter / Math.cos(this._pitch), A = g < 0 ? _ : h, L = Math.PI / 2 + this._pitch, E = this._fov * (0.5 + t.y / this.height), M = Math.sin(E) * A / Math.sin(c.ac(Math.PI - L - E, 0.01, Math.PI - 0.01)), R = this.getHorizon(), q = 2 * Math.atan(R / this.cameraToCenterDistance) * (0.5 + t.y / (2 * R)), B = Math.sin(q) * A / Math.sin(c.ac(Math.PI - L - q, 0.01, Math.PI - 0.01)), $ = Math.min(M, B);
          this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * $ + A), this.nearZ = this.height / 50, l = new Float64Array(16), c.b6(l, this._fov, this.width / this.height, this.nearZ, this.farZ), l[8] = 2 * -t.x / this.width, l[9] = 2 * t.y / this.height, this.projectionMatrix = c.ae(l), c.K(l, l, [1, -1, 1]), c.J(l, l, [0, 0, -this.cameraToCenterDistance]), c.b7(l, l, this._pitch), c.ad(l, l, this.angle), c.J(l, l, [-r, -s, 0]), this.mercatorMatrix = c.K([], l, [this.worldSize, this.worldSize, this.worldSize]), c.K(l, l, [1, 1, this._pixelPerMeter]), this.pixelMatrix = c.L(new Float64Array(16), this.labelPlaneMatrix, l), c.J(l, l, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = l, this.invModelViewProjectionMatrix = c.as([], l), this.fogMatrix = new Float64Array(16), c.b6(this.fogMatrix, this._fov, this.width / this.height, h, this.farZ), this.fogMatrix[8] = 2 * -t.x / this.width, this.fogMatrix[9] = 2 * t.y / this.height, c.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), c.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), c.b7(this.fogMatrix, this.fogMatrix, this._pitch), c.ad(this.fogMatrix, this.fogMatrix, this.angle), c.J(this.fogMatrix, this.fogMatrix, [-r, -s, 0]), c.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), c.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = c.L(new Float64Array(16), this.labelPlaneMatrix, l);
          const Q = this.width % 2 / 2, tt = this.height % 2 / 2, nt = Math.cos(this.angle), it = Math.sin(this.angle), ht = r - Math.round(r) + nt * Q + it * tt, wt = s - Math.round(s) + nt * tt + it * Q, _t = new Float64Array(l);
          if (c.J(_t, _t, [ht > 0.5 ? ht - 1 : ht, wt > 0.5 ? wt - 1 : wt, 0]), this.alignedModelViewProjectionMatrix = _t, l = c.as(new Float64Array(16), this.pixelMatrix), !l) throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = l, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse) return 1;
          const t = this.pointCoordinate(new c.P(0, 0)), r = [t.x * this.worldSize, t.y * this.worldSize, 0, 1];
          return c.af(r, r, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new c.P(0, t));
        }
        getCameraQueryGeometry(t) {
          const r = this.getCameraPoint();
          if (t.length === 1) return [t[0], r];
          {
            let s = r.x, l = r.y, h = r.x, g = r.y;
            for (const _ of t) s = Math.min(s, _.x), l = Math.min(l, _.y), h = Math.max(h, _.x), g = Math.max(g, _.y);
            return [new c.P(s, l), new c.P(h, l), new c.P(h, g), new c.P(s, g), new c.P(s, l)];
          }
        }
        lngLatToCameraDepth(t, r) {
          const s = this.locationCoordinate(t), l = [s.x * this.worldSize, s.y * this.worldSize, r, 1];
          return c.af(l, l, this.modelViewProjectionMatrix), l[2] / l[3];
        }
      }
      function as(o, t) {
        let r, s = !1, l = null, h = null;
        const g = () => {
          l = null, s && (o.apply(h, r), l = setTimeout(g, t), s = !1);
        };
        return (..._) => (s = !0, h = this, r = _, l || g(), l);
      }
      class As {
        constructor(t) {
          this._getCurrentHash = () => {
            const r = window.location.hash.replace("#", "");
            if (this._hashName) {
              let s;
              return r.split("&").map((l) => l.split("=")).forEach((l) => {
                l[0] === this._hashName && (s = l);
              }), (s && s[1] || "").split("/");
            }
            return r.split("/");
          }, this._onHashChange = () => {
            const r = this._getCurrentHash();
            if (r.length >= 3 && !r.some((s) => isNaN(s))) {
              const s = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(r[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+r[2], +r[1]], zoom: +r[0], bearing: s, pitch: +(r[4] || 0) }), !0;
            }
            return !1;
          }, this._updateHashUnthrottled = () => {
            const r = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, r);
          }, this._removeHash = () => {
            const r = this._getCurrentHash();
            if (r.length === 0) return;
            const s = r.join("/");
            let l = s;
            l.split("&").length > 0 && (l = l.split("&")[0]), this._hashName && (l = `${this._hashName}=${s}`);
            let h = window.location.hash.replace(l, "");
            h.startsWith("#&") ? h = h.slice(0, 1) + h.slice(2) : h === "#" && (h = "");
            let g = window.location.href.replace(/(#.+)?$/, h);
            g = g.replace("&&", "&"), window.history.replaceState(window.history.state, null, g);
          }, this._updateHash = as(this._updateHashUnthrottled, 300), this._hashName = t && encodeURIComponent(t);
        }
        addTo(t) {
          return this._map = t, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(t) {
          const r = this._map.getCenter(), s = Math.round(100 * this._map.getZoom()) / 100, l = Math.ceil((s * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), h = Math.pow(10, l), g = Math.round(r.lng * h) / h, _ = Math.round(r.lat * h) / h, A = this._map.getBearing(), L = this._map.getPitch();
          let E = "";
          if (E += t ? `/${g}/${_}/${s}` : `${s}/${_}/${g}`, (A || L) && (E += "/" + Math.round(10 * A) / 10), L && (E += `/${Math.round(L)}`), this._hashName) {
            const M = this._hashName;
            let R = !1;
            const q = window.location.hash.slice(1).split("&").map((B) => {
              const $ = B.split("=")[0];
              return $ === M ? (R = !0, `${$}=${E}`) : B;
            }).filter((B) => B);
            return R || q.push(`${M}=${E}`), `#${q.join("&")}`;
          }
          return `#${E}`;
        }
      }
      const os = { linearity: 0.3, easing: c.b8(0, 0, 0.3, 1) }, js = c.e({ deceleration: 2500, maxSpeed: 1400 }, os), co = c.e({ deceleration: 20, maxSpeed: 1400 }, os), la = c.e({ deceleration: 1e3, maxSpeed: 360 }, os), ls = c.e({ deceleration: 1e3, maxSpeed: 90 }, os);
      class Ta {
        constructor(t) {
          this._map = t, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: O.now(), settings: t });
        }
        _drainInertiaBuffer() {
          const t = this._inertiaBuffer, r = O.now();
          for (; t.length > 0 && r - t[0].time > 160; ) t.shift();
        }
        _onMoveEnd(t) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const r = { zoom: 0, bearing: 0, pitch: 0, pan: new c.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: h } of this._inertiaBuffer) r.zoom += h.zoomDelta || 0, r.bearing += h.bearingDelta || 0, r.pitch += h.pitchDelta || 0, h.panDelta && r.pan._add(h.panDelta), h.around && (r.around = h.around), h.pinchAround && (r.pinchAround = h.pinchAround);
          const s = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, l = {};
          if (r.pan.mag()) {
            const h = tn(r.pan.mag(), s, c.e({}, js, t || {}));
            l.offset = r.pan.mult(h.amount / r.pan.mag()), l.center = this._map.transform.center, Qr(l, h);
          }
          if (r.zoom) {
            const h = tn(r.zoom, s, co);
            l.zoom = this._map.transform.zoom + h.amount, Qr(l, h);
          }
          if (r.bearing) {
            const h = tn(r.bearing, s, la);
            l.bearing = this._map.transform.bearing + c.ac(h.amount, -179, 179), Qr(l, h);
          }
          if (r.pitch) {
            const h = tn(r.pitch, s, ls);
            l.pitch = this._map.transform.pitch + h.amount, Qr(l, h);
          }
          if (l.zoom || l.bearing) {
            const h = r.pinchAround === void 0 ? r.around : r.pinchAround;
            l.around = h ? this._map.unproject(h) : this._map.getCenter();
          }
          return this.clear(), c.e(l, { noMoveStart: !0 });
        }
      }
      function Qr(o, t) {
        (!o.duration || o.duration < t.duration) && (o.duration = t.duration, o.easing = t.easing);
      }
      function tn(o, t, r) {
        const { maxSpeed: s, linearity: l, deceleration: h } = r, g = c.ac(o * l / (t / 1e3), -s, s), _ = Math.abs(g) / (h * l);
        return { easing: r.easing, duration: 1e3 * _, amount: g * (_ / 2) };
      }
      class Ii extends c.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, r, s, l = {}) {
          const h = j.mousePos(r.getCanvas(), s), g = r.unproject(h);
          super(t, c.e({ point: h, lngLat: g, originalEvent: s }, l)), this._defaultPrevented = !1, this.target = r;
        }
      }
      class Oi extends c.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, r, s) {
          const l = t === "touchend" ? s.changedTouches : s.touches, h = j.touchPos(r.getCanvasContainer(), l), g = h.map((A) => r.unproject(A)), _ = h.reduce((A, L, E, M) => A.add(L.div(M.length)), new c.P(0, 0));
          super(t, { points: h, point: _, lngLats: g, lngLat: r.unproject(_), originalEvent: s }), this._defaultPrevented = !1;
        }
      }
      class gr extends c.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, r, s) {
          super(t, { originalEvent: s }), this._defaultPrevented = !1;
        }
      }
      class Ir {
        constructor(t, r) {
          this._map = t, this._clickTolerance = r.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(t) {
          return this._firePreventable(new gr(t.type, this._map, t));
        }
        mousedown(t, r) {
          return this._mousedownPos = r, this._firePreventable(new Ii(t.type, this._map, t));
        }
        mouseup(t) {
          this._map.fire(new Ii(t.type, this._map, t));
        }
        click(t, r) {
          this._mousedownPos && this._mousedownPos.dist(r) >= this._clickTolerance || this._map.fire(new Ii(t.type, this._map, t));
        }
        dblclick(t) {
          return this._firePreventable(new Ii(t.type, this._map, t));
        }
        mouseover(t) {
          this._map.fire(new Ii(t.type, this._map, t));
        }
        mouseout(t) {
          this._map.fire(new Ii(t.type, this._map, t));
        }
        touchstart(t) {
          return this._firePreventable(new Oi(t.type, this._map, t));
        }
        touchmove(t) {
          this._map.fire(new Oi(t.type, this._map, t));
        }
        touchend(t) {
          this._map.fire(new Oi(t.type, this._map, t));
        }
        touchcancel(t) {
          this._map.fire(new Oi(t.type, this._map, t));
        }
        _firePreventable(t) {
          if (this._map.fire(t), t.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class $i {
        constructor(t) {
          this._map = t;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(t) {
          this._map.fire(new Ii(t.type, this._map, t));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Ii("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(t) {
          this._delayContextMenu ? this._contextMenuEvent = t : this._ignoreContextMenu || this._map.fire(new Ii(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class un {
        constructor(t) {
          this._map = t;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(t) {
          return this.transform.pointLocation(c.P.convert(t), this._map.terrain);
        }
      }
      class Nr {
        constructor(t, r) {
          this._map = t, this._tr = new un(t), this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = r.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(t, r) {
          this.isEnabled() && t.shiftKey && t.button === 0 && (j.disableDrag(), this._startPos = this._lastPos = r, this._active = !0);
        }
        mousemoveWindow(t, r) {
          if (!this._active) return;
          const s = r;
          if (this._lastPos.equals(s) || !this._box && s.dist(this._startPos) < this._clickTolerance) return;
          const l = this._startPos;
          this._lastPos = s, this._box || (this._box = j.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t));
          const h = Math.min(l.x, s.x), g = Math.max(l.x, s.x), _ = Math.min(l.y, s.y), A = Math.max(l.y, s.y);
          j.setTransform(this._box, `translate(${h}px,${_}px)`), this._box.style.width = g - h + "px", this._box.style.height = A - _ + "px";
        }
        mouseupWindow(t, r) {
          if (!this._active || t.button !== 0) return;
          const s = this._startPos, l = r;
          if (this.reset(), j.suppressClick(), s.x !== l.x || s.y !== l.y) return this._map.fire(new c.k("boxzoomend", { originalEvent: t })), { cameraAnimation: (h) => h.fitScreenCoordinates(s, l, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", t);
        }
        keydown(t) {
          this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (j.remove(this._box), this._box = null), j.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t, r) {
          return this._map.fire(new c.k(t, { originalEvent: r }));
        }
      }
      function ca(o, t) {
        if (o.length !== t.length) throw new Error(`The number of touches and points are not equal - touches ${o.length}, points ${t.length}`);
        const r = {};
        for (let s = 0; s < o.length; s++) r[o[s].identifier] = t[s];
        return r;
      }
      class $o {
        constructor(t) {
          this.reset(), this.numTouches = t.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(t, r, s) {
          (this.centroid || s.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = t.timeStamp), s.length === this.numTouches && (this.centroid = function(l) {
            const h = new c.P(0, 0);
            for (const g of l) h._add(g);
            return h.div(l.length);
          }(r), this.touches = ca(s, r)));
        }
        touchmove(t, r, s) {
          if (this.aborted || !this.centroid) return;
          const l = ca(s, r);
          for (const h in this.touches) {
            const g = l[h];
            (!g || g.dist(this.touches[h]) > 30) && (this.aborted = !0);
          }
        }
        touchend(t, r, s) {
          if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), s.length === 0) {
            const l = !this.aborted && this.centroid;
            if (this.reset(), l) return l;
          }
        }
      }
      class La {
        constructor(t) {
          this.singleTap = new $o(t), this.numTaps = t.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(t, r, s) {
          this.singleTap.touchstart(t, r, s);
        }
        touchmove(t, r, s) {
          this.singleTap.touchmove(t, r, s);
        }
        touchend(t, r, s) {
          const l = this.singleTap.touchend(t, r, s);
          if (l) {
            const h = t.timeStamp - this.lastTime < 500, g = !this.lastTap || this.lastTap.dist(l) < 30;
            if (h && g || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = l, this.count === this.numTaps) return this.reset(), l;
          }
        }
      }
      class Dr {
        constructor(t) {
          this._tr = new un(t), this._zoomIn = new La({ numTouches: 1, numTaps: 2 }), this._zoomOut = new La({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t, r, s) {
          this._zoomIn.touchstart(t, r, s), this._zoomOut.touchstart(t, r, s);
        }
        touchmove(t, r, s) {
          this._zoomIn.touchmove(t, r, s), this._zoomOut.touchmove(t, r, s);
        }
        touchend(t, r, s) {
          const l = this._zoomIn.touchend(t, r, s), h = this._zoomOut.touchend(t, r, s), g = this._tr;
          return l ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (_) => _.easeTo({ duration: 300, zoom: g.zoom + 1, around: g.unproject(l) }, { originalEvent: t }) }) : h ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (_) => _.easeTo({ duration: 300, zoom: g.zoom - 1, around: g.unproject(h) }, { originalEvent: t }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class kr {
        constructor(t) {
          this._enabled = !!t.enable, this._moveStateManager = t.moveStateManager, this._clickTolerance = t.clickTolerance || 1, this._moveFunction = t.move, this._activateOnStart = !!t.activateOnStart, t.assignEvents(this), this.reset();
        }
        reset(t) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(t);
        }
        _move(...t) {
          const r = this._moveFunction(...t);
          if (r.bearingDelta || r.pitchDelta || r.around || r.panDelta) return this._active = !0, r;
        }
        dragStart(t, r) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t) && (this._moveStateManager.startMove(t), this._lastPoint = r.length ? r[0] : r, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(t, r) {
          if (!this.isEnabled()) return;
          const s = this._lastPoint;
          if (!s) return;
          if (t.preventDefault(), !this._moveStateManager.isValidMoveEvent(t)) return void this.reset(t);
          const l = r.length ? r[0] : r;
          return !this._moved && l.dist(s) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = l, this._move(s, l));
        }
        dragEnd(t) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t) && (this._moved && j.suppressClick(), this.reset(t));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const ho = { 0: 1, 2: 2 };
      class Ca {
        constructor(t) {
          this._correctEvent = t.checkCorrectEvent;
        }
        startMove(t) {
          const r = j.mouseButton(t);
          this._eventButton = r;
        }
        endMove(t) {
          delete this._eventButton;
        }
        isValidStartEvent(t) {
          return this._correctEvent(t);
        }
        isValidMoveEvent(t) {
          return !function(r, s) {
            const l = ho[s];
            return r.buttons === void 0 || (r.buttons & l) !== l;
          }(t, this._eventButton);
        }
        isValidEndEvent(t) {
          return j.mouseButton(t) === this._eventButton;
        }
      }
      class fl {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(t) {
          return t.targetTouches.length === 1;
        }
        _isSameTouchEvent(t) {
          return t.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(t) {
          this._firstTouch = t.targetTouches[0].identifier;
        }
        endMove(t) {
          delete this._firstTouch;
        }
        isValidStartEvent(t) {
          return this._isOneFingerTouch(t);
        }
        isValidMoveEvent(t) {
          return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
        }
        isValidEndEvent(t) {
          return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
        }
      }
      const Ma = (o) => {
        o.mousedown = o.dragStart, o.mousemoveWindow = o.dragMove, o.mouseup = o.dragEnd, o.contextmenu = (t) => {
          t.preventDefault();
        };
      }, uo = ({ enable: o, clickTolerance: t, bearingDegreesPerPixelMoved: r = 0.8 }) => {
        const s = new Ca({ checkCorrectEvent: (l) => j.mouseButton(l) === 0 && l.ctrlKey || j.mouseButton(l) === 2 });
        return new kr({ clickTolerance: t, move: (l, h) => ({ bearingDelta: (h.x - l.x) * r }), moveStateManager: s, enable: o, assignEvents: Ma });
      }, Zo = ({ enable: o, clickTolerance: t, pitchDegreesPerPixelMoved: r = -0.5 }) => {
        const s = new Ca({ checkCorrectEvent: (l) => j.mouseButton(l) === 0 && l.ctrlKey || j.mouseButton(l) === 2 });
        return new kr({ clickTolerance: t, move: (l, h) => ({ pitchDelta: (h.y - l.y) * r }), moveStateManager: s, enable: o, assignEvents: Ma });
      };
      class ha {
        constructor(t, r) {
          this._clickTolerance = t.clickTolerance || 1, this._map = r, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new c.P(0, 0);
        }
        _shouldBePrevented(t) {
          return t < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(t, r, s) {
          return this._calculateTransform(t, r, s);
        }
        touchmove(t, r, s) {
          if (this._active) {
            if (!this._shouldBePrevented(s.length)) return t.preventDefault(), this._calculateTransform(t, r, s);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", t);
          }
        }
        touchend(t, r, s) {
          this._calculateTransform(t, r, s), this._active && this._shouldBePrevented(s.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t, r, s) {
          s.length > 0 && (this._active = !0);
          const l = ca(s, r), h = new c.P(0, 0), g = new c.P(0, 0);
          let _ = 0;
          for (const L in l) {
            const E = l[L], M = this._touches[L];
            M && (h._add(E), g._add(E.sub(M)), _++, l[L] = E);
          }
          if (this._touches = l, this._shouldBePrevented(_) || !g.mag()) return;
          const A = g.div(_);
          return this._sum._add(A), this._sum.mag() < this._clickTolerance ? void 0 : { around: h.div(_), panDelta: A };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class po {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(t, r, s) {
          this._firstTwoTouches || s.length < 2 || (this._firstTwoTouches = [s[0].identifier, s[1].identifier], this._start([r[0], r[1]]));
        }
        touchmove(t, r, s) {
          if (!this._firstTwoTouches) return;
          t.preventDefault();
          const [l, h] = this._firstTwoTouches, g = Ea(s, r, l), _ = Ea(s, r, h);
          if (!g || !_) return;
          const A = this._aroundCenter ? null : g.add(_).div(2);
          return this._move([g, _], A, t);
        }
        touchend(t, r, s) {
          if (!this._firstTwoTouches) return;
          const [l, h] = this._firstTwoTouches, g = Ea(s, r, l), _ = Ea(s, r, h);
          g && _ || (this._active && j.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t) {
          this._enabled = !0, this._aroundCenter = !!t && t.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function Ea(o, t, r) {
        for (let s = 0; s < o.length; s++) if (o[s].identifier === r) return t[s];
      }
      function fo(o, t) {
        return Math.log(o / t) / Math.LN2;
      }
      class Wo extends po {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(t) {
          this._startDistance = this._distance = t[0].dist(t[1]);
        }
        _move(t, r) {
          const s = this._distance;
          if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(fo(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: fo(this._distance, s), pinchAround: r };
        }
      }
      function Dl(o, t) {
        return 180 * o.angleWith(t) / Math.PI;
      }
      class Fl extends po {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(t) {
          this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
        }
        _move(t, r, s) {
          const l = this._vector;
          if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: Dl(this._vector, l), pinchAround: r };
        }
        _isBelowThreshold(t) {
          this._minDiameter = Math.min(this._minDiameter, t.mag());
          const r = 25 / (Math.PI * this._minDiameter) * 360, s = Dl(t, this._startVector);
          return Math.abs(s) < r;
        }
      }
      function Xo(o) {
        return Math.abs(o.y) > Math.abs(o.x);
      }
      class mo extends po {
        constructor(t) {
          super(), this._currentTouchCount = 0, this._map = t;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(t, r, s) {
          super.touchstart(t, r, s), this._currentTouchCount = s.length;
        }
        _start(t) {
          this._lastPoints = t, Xo(t[0].sub(t[1])) && (this._valid = !1);
        }
        _move(t, r, s) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          const l = t[0].sub(this._lastPoints[0]), h = t[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(l, h, s.timeStamp), this._valid ? (this._lastPoints = t, this._active = !0, { pitchDelta: (l.y + h.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(t, r, s) {
          if (this._valid !== void 0) return this._valid;
          const l = t.mag() >= 2, h = r.mag() >= 2;
          if (!l && !h) return;
          if (!l || !h) return this._firstMove === void 0 && (this._firstMove = s), s - this._firstMove < 100 && void 0;
          const g = t.y > 0 == r.y > 0;
          return Xo(t) && Xo(r) && g;
        }
      }
      const nc = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class jn {
        constructor(t) {
          this._tr = new un(t);
          const r = nc;
          this._panStep = r.panStep, this._bearingStep = r.bearingStep, this._pitchStep = r.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(t) {
          if (t.altKey || t.ctrlKey || t.metaKey) return;
          let r = 0, s = 0, l = 0, h = 0, g = 0;
          switch (t.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              r = 1;
              break;
            case 189:
            case 109:
            case 173:
              r = -1;
              break;
            case 37:
              t.shiftKey ? s = -1 : (t.preventDefault(), h = -1);
              break;
            case 39:
              t.shiftKey ? s = 1 : (t.preventDefault(), h = 1);
              break;
            case 38:
              t.shiftKey ? l = 1 : (t.preventDefault(), g = -1);
              break;
            case 40:
              t.shiftKey ? l = -1 : (t.preventDefault(), g = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (s = 0, l = 0), { cameraAnimation: (_) => {
            const A = this._tr;
            _.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Ps, zoom: r ? Math.round(A.zoom) + r * (t.shiftKey ? 2 : 1) : A.zoom, bearing: A.bearing + s * this._bearingStep, pitch: A.pitch + l * this._pitchStep, offset: [-h * this._panStep, -g * this._panStep], center: A.center }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Ps(o) {
        return o * (2 - o);
      }
      const Bl = 4.000244140625;
      class kn {
        constructor(t, r) {
          this._onTimeout = (s) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(s);
          }, this._map = t, this._tr = new un(t), this._triggerRenderFrame = r, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(t) {
          this._defaultZoomRate = t;
        }
        setWheelZoomRate(t) {
          this._wheelZoomRate = t;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        _shouldBePrevented(t) {
          return !!this._map.cooperativeGestures.isEnabled() && !(t.ctrlKey || this._map.cooperativeGestures.isBypassed(t));
        }
        wheel(t) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(t)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", t);
          let r = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
          const s = O.now(), l = s - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = s, r !== 0 && r % Bl == 0 ? this._type = "wheel" : r !== 0 && Math.abs(r) < 4 ? this._type = "trackpad" : l > 400 ? (this._type = null, this._lastValue = r, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(l * r) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, r += this._lastValue)), t.shiftKey && r && (r /= 4), this._type && (this._lastWheelEvent = t, this._delta -= r, this._active || this._start(t)), t.preventDefault();
        }
        _start(t) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const r = j.mousePos(this._map.getCanvas(), t), s = this._tr;
          this._around = r.y > s.transform.height / 2 - s.transform.getHorizon() ? c.N.convert(this._aroundCenter ? s.center : s.unproject(r)) : c.N.convert(s.center), this._aroundPoint = s.transform.locationPoint(this._around), this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const t = this._tr.transform;
          if (this._delta !== 0) {
            const A = this._type === "wheel" && Math.abs(this._delta) > Bl ? this._wheelZoomRate : this._defaultZoomRate;
            let L = 2 / (1 + Math.exp(-Math.abs(this._delta * A)));
            this._delta < 0 && L !== 0 && (L = 1 / L);
            const E = typeof this._targetZoom == "number" ? t.zoomScale(this._targetZoom) : t.scale;
            this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(E * L))), this._type === "wheel" && (this._startZoom = t.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const r = typeof this._targetZoom == "number" ? this._targetZoom : t.zoom, s = this._startZoom, l = this._easing;
          let h, g = !1;
          const _ = O.now() - this._lastWheelEventTime;
          if (this._type === "wheel" && s && l && _) {
            const A = Math.min(_ / 200, 1), L = l(A);
            h = c.y.number(s, r, L), A < 1 ? this._frameId || (this._frameId = !0) : g = !0;
          } else h = r, g = !0;
          return this._active = !0, g && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: !0, needsRenderFrame: !g, zoomDelta: h - t.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t) {
          let r = c.b9;
          if (this._prevEase) {
            const s = this._prevEase, l = (O.now() - s.start) / s.duration, h = s.easing(l + 0.01) - s.easing(l), g = 0.27 / Math.sqrt(h * h + 1e-4) * 0.01, _ = Math.sqrt(0.0729 - g * g);
            r = c.b8(g, _, 0.25, 1);
          }
          return this._prevEase = { start: O.now(), duration: t, easing: r }, r;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class qs {
        constructor(t, r) {
          this._clickZoom = t, this._tapZoom = r;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Ho {
        constructor(t) {
          this._tr = new un(t), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(t, r) {
          return t.preventDefault(), { cameraAnimation: (s) => {
            s.easeTo({ duration: 300, zoom: this._tr.zoom + (t.shiftKey ? -1 : 1), around: this._tr.unproject(r) }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Dc {
        constructor() {
          this._tap = new La({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(t, r, s) {
          if (!this._swipePoint) if (this._tapTime) {
            const l = r[0], h = t.timeStamp - this._tapTime < 500, g = this._tapPoint.dist(l) < 30;
            h && g ? s.length > 0 && (this._swipePoint = l, this._swipeTouch = s[0].identifier) : this.reset();
          } else this._tap.touchstart(t, r, s);
        }
        touchmove(t, r, s) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (s[0].identifier !== this._swipeTouch) return;
              const l = r[0], h = l.y - this._swipePoint.y;
              return this._swipePoint = l, t.preventDefault(), this._active = !0, { zoomDelta: h / 128 };
            }
          } else this._tap.touchmove(t, r, s);
        }
        touchend(t, r, s) {
          if (this._tapTime) this._swipePoint && s.length === 0 && this.reset();
          else {
            const l = this._tap.touchend(t, r, s);
            l && (this._tapTime = t.timeStamp, this._tapPoint = l);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class sc {
        constructor(t, r, s) {
          this._el = t, this._mousePan = r, this._touchPan = s;
        }
        enable(t) {
          this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class Rl {
        constructor(t, r, s) {
          this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = r, this._mousePitch = s;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class Ol {
        constructor(t, r, s, l) {
          this._el = t, this._touchZoom = r, this._touchRotate = s, this._tapDragZoom = l, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(t) {
          this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class go {
        constructor(t, r) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = t, this._options = r, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          const t = this._map.getCanvasContainer();
          t.classList.add("maplibregl-cooperative-gestures"), this._container = j.create("div", "maplibregl-cooperative-gesture-screen", t);
          let r = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (r = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const s = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), l = document.createElement("div");
          l.className = "maplibregl-desktop-message", l.textContent = r, this._container.appendChild(l);
          const h = document.createElement("div");
          h.className = "maplibregl-mobile-message", h.textContent = s, this._container.appendChild(h), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (j.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(t) {
          return t[this._bypassKey];
        }
        notifyGestureBlocked(t, r) {
          this._enabled && (this._map.fire(new c.k("cooperativegestureprevented", { gestureType: t, originalEvent: r })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const qn = (o) => o.zoom || o.drag || o.pitch || o.rotate;
      class De extends c.k {
      }
      function cs(o) {
        return o.panDelta && o.panDelta.mag() || o.zoomDelta || o.bearingDelta || o.pitchDelta;
      }
      class Tn {
        constructor(t, r) {
          this.handleWindowEvent = (l) => {
            this.handleEvent(l, `${l.type}Window`);
          }, this.handleEvent = (l, h) => {
            if (l.type === "blur") return void this.stop(!0);
            this._updatingCamera = !0;
            const g = l.type === "renderFrame" ? void 0 : l, _ = { needsRenderFrame: !1 }, A = {}, L = {}, E = l.touches, M = E ? this._getMapTouches(E) : void 0, R = M ? j.touchPos(this._map.getCanvas(), M) : j.mousePos(this._map.getCanvas(), l);
            for (const { handlerName: $, handler: Q, allowed: tt } of this._handlers) {
              if (!Q.isEnabled()) continue;
              let nt;
              this._blockedByActive(L, tt, $) ? Q.reset() : Q[h || l.type] && (nt = Q[h || l.type](l, R, M), this.mergeHandlerResult(_, A, nt, $, g), nt && nt.needsRenderFrame && this._triggerRenderFrame()), (nt || Q.isActive()) && (L[$] = Q);
            }
            const q = {};
            for (const $ in this._previousActiveHandlers) L[$] || (q[$] = g);
            this._previousActiveHandlers = L, (Object.keys(q).length || cs(_)) && (this._changes.push([_, A, q]), this._triggerRenderFrame()), (Object.keys(L).length || cs(_)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: B } = _;
            B && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], B(this._map));
          }, this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ta(t), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(r);
          const s = this._el;
          this._listeners = [[s, "touchstart", { passive: !0 }], [s, "touchmove", { passive: !1 }], [s, "touchend", void 0], [s, "touchcancel", void 0], [s, "mousedown", void 0], [s, "mousemove", void 0], [s, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [s, "mouseover", void 0], [s, "mouseout", void 0], [s, "dblclick", void 0], [s, "click", void 0], [s, "keydown", { capture: !1 }], [s, "keyup", void 0], [s, "wheel", { passive: !1 }], [s, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [l, h, g] of this._listeners) j.addEventListener(l, h, l === document ? this.handleWindowEvent : this.handleEvent, g);
        }
        destroy() {
          for (const [t, r, s] of this._listeners) j.removeEventListener(t, r, t === document ? this.handleWindowEvent : this.handleEvent, s);
        }
        _addDefaultHandlers(t) {
          const r = this._map, s = r.getCanvasContainer();
          this._add("mapEvent", new Ir(r, t));
          const l = r.boxZoom = new Nr(r, t);
          this._add("boxZoom", l), t.interactive && t.boxZoom && l.enable();
          const h = r.cooperativeGestures = new go(r, t.cooperativeGestures);
          this._add("cooperativeGestures", h), t.cooperativeGestures && h.enable();
          const g = new Dr(r), _ = new Ho(r);
          r.doubleClickZoom = new qs(_, g), this._add("tapZoom", g), this._add("clickZoom", _), t.interactive && t.doubleClickZoom && r.doubleClickZoom.enable();
          const A = new Dc();
          this._add("tapDragZoom", A);
          const L = r.touchPitch = new mo(r);
          this._add("touchPitch", L), t.interactive && t.touchPitch && r.touchPitch.enable(t.touchPitch);
          const E = uo(t), M = Zo(t);
          r.dragRotate = new Rl(t, E, M), this._add("mouseRotate", E, ["mousePitch"]), this._add("mousePitch", M, ["mouseRotate"]), t.interactive && t.dragRotate && r.dragRotate.enable();
          const R = (({ enable: nt, clickTolerance: it }) => {
            const ht = new Ca({ checkCorrectEvent: (wt) => j.mouseButton(wt) === 0 && !wt.ctrlKey });
            return new kr({ clickTolerance: it, move: (wt, _t) => ({ around: _t, panDelta: _t.sub(wt) }), activateOnStart: !0, moveStateManager: ht, enable: nt, assignEvents: Ma });
          })(t), q = new ha(t, r);
          r.dragPan = new sc(s, R, q), this._add("mousePan", R), this._add("touchPan", q, ["touchZoom", "touchRotate"]), t.interactive && t.dragPan && r.dragPan.enable(t.dragPan);
          const B = new Fl(), $ = new Wo();
          r.touchZoomRotate = new Ol(s, $, B, A), this._add("touchRotate", B, ["touchPan", "touchZoom"]), this._add("touchZoom", $, ["touchPan", "touchRotate"]), t.interactive && t.touchZoomRotate && r.touchZoomRotate.enable(t.touchZoomRotate);
          const Q = r.scrollZoom = new kn(r, () => this._triggerRenderFrame());
          this._add("scrollZoom", Q, ["mousePan"]), t.interactive && t.scrollZoom && r.scrollZoom.enable(t.scrollZoom);
          const tt = r.keyboard = new jn(r);
          this._add("keyboard", tt), t.interactive && t.keyboard && r.keyboard.enable(), this._add("blockableMapEvent", new $i(r));
        }
        _add(t, r, s) {
          this._handlers.push({ handlerName: t, handler: r, allowed: s }), this._handlersById[t] = r;
        }
        stop(t) {
          if (!this._updatingCamera) {
            for (const { handler: r } of this._handlers) r.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: t } of this._handlers) if (t.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!qn(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(t, r, s) {
          for (const l in t) if (l !== s && (!r || r.indexOf(l) < 0)) return !0;
          return !1;
        }
        _getMapTouches(t) {
          const r = [];
          for (const s of t) this._el.contains(s.target) && r.push(s);
          return r;
        }
        mergeHandlerResult(t, r, s, l, h) {
          if (!s) return;
          c.e(t, s);
          const g = { handlerName: l, originalEvent: s.originalEvent || h };
          s.zoomDelta !== void 0 && (r.zoom = g), s.panDelta !== void 0 && (r.drag = g), s.pitchDelta !== void 0 && (r.pitch = g), s.bearingDelta !== void 0 && (r.rotate = g);
        }
        _applyChanges() {
          const t = {}, r = {}, s = {};
          for (const [l, h, g] of this._changes) l.panDelta && (t.panDelta = (t.panDelta || new c.P(0, 0))._add(l.panDelta)), l.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + l.zoomDelta), l.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + l.bearingDelta), l.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + l.pitchDelta), l.around !== void 0 && (t.around = l.around), l.pinchAround !== void 0 && (t.pinchAround = l.pinchAround), l.noInertia && (t.noInertia = l.noInertia), c.e(r, h), c.e(s, g);
          this._updateMapTransform(t, r, s), this._changes = [];
        }
        _updateMapTransform(t, r, s) {
          const l = this._map, h = l._getTransformForUpdate(), g = l.terrain;
          if (!(cs(t) || g && this._terrainMovement)) return this._fireEvents(r, s, !0);
          let { panDelta: _, zoomDelta: A, bearingDelta: L, pitchDelta: E, around: M, pinchAround: R } = t;
          R !== void 0 && (M = R), l._stop(!0), M = M || l.transform.centerPoint;
          const q = h.pointLocation(_ ? M.sub(_) : M);
          L && (h.bearing += L), E && (h.pitch += E), A && (h.zoom += A), g ? this._terrainMovement || !r.drag && !r.zoom ? r.drag && this._terrainMovement ? h.center = h.pointLocation(h.centerPoint.sub(_)) : h.setLocationAtPoint(q, M) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, h.setLocationAtPoint(q, M)) : h.setLocationAtPoint(q, M), l._applyUpdatedTransform(h), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(r, s, !0);
        }
        _fireEvents(t, r, s) {
          const l = qn(this._eventsInProgress), h = qn(t), g = {};
          for (const M in t) {
            const { originalEvent: R } = t[M];
            this._eventsInProgress[M] || (g[`${M}start`] = R), this._eventsInProgress[M] = t[M];
          }
          !l && h && this._fireEvent("movestart", h.originalEvent);
          for (const M in g) this._fireEvent(M, g[M]);
          h && this._fireEvent("move", h.originalEvent);
          for (const M in t) {
            const { originalEvent: R } = t[M];
            this._fireEvent(M, R);
          }
          const _ = {};
          let A;
          for (const M in this._eventsInProgress) {
            const { handlerName: R, originalEvent: q } = this._eventsInProgress[M];
            this._handlersById[R].isActive() || (delete this._eventsInProgress[M], A = r[R] || q, _[`${M}end`] = A);
          }
          for (const M in _) this._fireEvent(M, _[M]);
          const L = qn(this._eventsInProgress), E = (l || h) && !L;
          if (E && this._terrainMovement) {
            this._map._elevationFreeze = !1, this._terrainMovement = !1;
            const M = this._map._getTransformForUpdate();
            M.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(M);
          }
          if (s && E) {
            this._updatingCamera = !0;
            const M = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), R = (q) => q !== 0 && -this._bearingSnap < q && q < this._bearingSnap;
            !M || !M.essential && O.prefersReducedMotion ? (this._map.fire(new c.k("moveend", { originalEvent: A })), R(this._map.getBearing()) && this._map.resetNorth()) : (R(M.bearing || this._map.getBearing()) && (M.bearing = 0), M.freezeElevation = !0, this._map.easeTo(M, { originalEvent: A })), this._updatingCamera = !1;
          }
        }
        _fireEvent(t, r) {
          this._map.fire(new c.k(t, r ? { originalEvent: r } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t) => {
            delete this._frameId, this.handleEvent(new De("renderFrame", { timeStamp: t })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class Is extends c.E {
        constructor(t, r) {
          super(), this._renderFrameCallback = () => {
            const s = Math.min((O.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(s)), s < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = r.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new c.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t, r) {
          return this.jumpTo({ center: t }, r);
        }
        panBy(t, r, s) {
          return t = c.P.convert(t).mult(-1), this.panTo(this.transform.center, c.e({ offset: t }, r), s);
        }
        panTo(t, r, s) {
          return this.easeTo(c.e({ center: t }, r), s);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t, r) {
          return this.jumpTo({ zoom: t }, r), this;
        }
        zoomTo(t, r, s) {
          return this.easeTo(c.e({ zoom: t }, r), s);
        }
        zoomIn(t, r) {
          return this.zoomTo(this.getZoom() + 1, t, r), this;
        }
        zoomOut(t, r) {
          return this.zoomTo(this.getZoom() - 1, t, r), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t, r) {
          return this.jumpTo({ bearing: t }, r), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t, r) {
          return this.jumpTo({ padding: t }, r), this;
        }
        rotateTo(t, r, s) {
          return this.easeTo(c.e({ bearing: t }, r), s);
        }
        resetNorth(t, r) {
          return this.rotateTo(0, c.e({ duration: 1e3 }, t), r), this;
        }
        resetNorthPitch(t, r) {
          return this.easeTo(c.e({ bearing: 0, pitch: 0, duration: 1e3 }, t), r), this;
        }
        snapToNorth(t, r) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, r) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t, r) {
          return this.jumpTo({ pitch: t }, r), this;
        }
        cameraForBounds(t, r) {
          t = Y.convert(t).adjustAntiMeridian();
          const s = r && r.bearing || 0;
          return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), s, r);
        }
        _cameraForBoxAndBearing(t, r, s, l) {
          const h = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (l = c.e({ padding: h, offset: [0, 0], maxZoom: this.transform.maxZoom }, l)).padding == "number") {
            const ue = l.padding;
            l.padding = { top: ue, bottom: ue, right: ue, left: ue };
          }
          l.padding = c.e(h, l.padding);
          const g = this.transform, _ = g.padding, A = new Y(t, r), L = g.project(A.getNorthWest()), E = g.project(A.getNorthEast()), M = g.project(A.getSouthEast()), R = g.project(A.getSouthWest()), q = c.ba(-s), B = L.rotate(q), $ = E.rotate(q), Q = M.rotate(q), tt = R.rotate(q), nt = new c.P(Math.max(B.x, $.x, tt.x, Q.x), Math.max(B.y, $.y, tt.y, Q.y)), it = new c.P(Math.min(B.x, $.x, tt.x, Q.x), Math.min(B.y, $.y, tt.y, Q.y)), ht = nt.sub(it), wt = (g.width - (_.left + _.right + l.padding.left + l.padding.right)) / ht.x, _t = (g.height - (_.top + _.bottom + l.padding.top + l.padding.bottom)) / ht.y;
          if (_t < 0 || wt < 0) return void c.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const Vt = Math.min(g.scaleZoom(g.scale * Math.min(wt, _t)), l.maxZoom), re = c.P.convert(l.offset), ce = new c.P((l.padding.left - l.padding.right) / 2, (l.padding.top - l.padding.bottom) / 2).rotate(c.ba(s)), de = re.add(ce).mult(g.scale / g.zoomScale(Vt));
          return { center: g.unproject(L.add(M).div(2).sub(de)), zoom: Vt, bearing: s };
        }
        fitBounds(t, r, s) {
          return this._fitInternal(this.cameraForBounds(t, r), r, s);
        }
        fitScreenCoordinates(t, r, s, l, h) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(c.P.convert(t)), this.transform.pointLocation(c.P.convert(r)), s, l), l, h);
        }
        _fitInternal(t, r, s) {
          return t ? (delete (r = c.e(t, r)).padding, r.linear ? this.easeTo(r, s) : this.flyTo(r, s)) : this;
        }
        jumpTo(t, r) {
          this.stop();
          const s = this._getTransformForUpdate();
          let l = !1, h = !1, g = !1;
          return "zoom" in t && s.zoom !== +t.zoom && (l = !0, s.zoom = +t.zoom), t.center !== void 0 && (s.center = c.N.convert(t.center)), "bearing" in t && s.bearing !== +t.bearing && (h = !0, s.bearing = +t.bearing), "pitch" in t && s.pitch !== +t.pitch && (g = !0, s.pitch = +t.pitch), t.padding == null || s.isPaddingEqual(t.padding) || (s.padding = t.padding), this._applyUpdatedTransform(s), this.fire(new c.k("movestart", r)).fire(new c.k("move", r)), l && this.fire(new c.k("zoomstart", r)).fire(new c.k("zoom", r)).fire(new c.k("zoomend", r)), h && this.fire(new c.k("rotatestart", r)).fire(new c.k("rotate", r)).fire(new c.k("rotateend", r)), g && this.fire(new c.k("pitchstart", r)).fire(new c.k("pitch", r)).fire(new c.k("pitchend", r)), this.fire(new c.k("moveend", r));
        }
        calculateCameraOptionsFromTo(t, r, s, l = 0) {
          const h = c.Z.fromLngLat(t, r), g = c.Z.fromLngLat(s, l), _ = g.x - h.x, A = g.y - h.y, L = g.z - h.z, E = Math.hypot(_, A, L);
          if (E === 0) throw new Error("Can't calculate camera options with same From and To");
          const M = Math.hypot(_, A), R = this.transform.scaleZoom(this.transform.cameraToCenterDistance / E / this.transform.tileSize), q = 180 * Math.atan2(_, -A) / Math.PI;
          let B = 180 * Math.acos(M / E) / Math.PI;
          return B = L < 0 ? 90 - B : 90 + B, { center: g.toLngLat(), zoom: R, pitch: B, bearing: q };
        }
        easeTo(t, r) {
          var s;
          this._stop(!1, t.easeId), ((t = c.e({ offset: [0, 0], duration: 500, easing: c.b9 }, t)).animate === !1 || !t.essential && O.prefersReducedMotion) && (t.duration = 0);
          const l = this._getTransformForUpdate(), h = l.zoom, g = l.bearing, _ = l.pitch, A = l.padding, L = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, E = "pitch" in t ? +t.pitch : _, M = "padding" in t ? t.padding : l.padding, R = c.P.convert(t.offset);
          let q = l.centerPoint.add(R);
          const B = l.pointLocation(q), { center: $, zoom: Q } = l.getConstrained(c.N.convert(t.center || B), (s = t.zoom) !== null && s !== void 0 ? s : h);
          this._normalizeCenter($, l);
          const tt = l.project(B), nt = l.project($).sub(tt), it = l.zoomScale(Q - h);
          let ht, wt;
          t.around && (ht = c.N.convert(t.around), wt = l.locationPoint(ht));
          const _t = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || Q !== h, this._rotating = this._rotating || g !== L, this._pitching = this._pitching || E !== _, this._padding = !l.isPaddingEqual(M), this._easeId = t.easeId, this._prepareEase(r, t.noMoveStart, _t), this.terrain && this._prepareElevation($), this._ease((Vt) => {
            if (this._zooming && (l.zoom = c.y.number(h, Q, Vt)), this._rotating && (l.bearing = c.y.number(g, L, Vt)), this._pitching && (l.pitch = c.y.number(_, E, Vt)), this._padding && (l.interpolatePadding(A, M, Vt), q = l.centerPoint.add(R)), this.terrain && !t.freezeElevation && this._updateElevation(Vt), ht) l.setLocationAtPoint(ht, wt);
            else {
              const re = l.zoomScale(l.zoom - h), ce = Q > h ? Math.min(2, it) : Math.max(0.5, it), de = Math.pow(ce, 1 - Vt), ue = l.unproject(tt.add(nt.mult(Vt * de)).mult(re));
              l.setLocationAtPoint(l.renderWorldCopies ? ue.wrap() : ue, q);
            }
            this._applyUpdatedTransform(l), this._fireMoveEvents(r);
          }, (Vt) => {
            this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(r, Vt);
          }, t), this;
        }
        _prepareEase(t, r, s = {}) {
          this._moving = !0, r || s.moving || this.fire(new c.k("movestart", t)), this._zooming && !s.zooming && this.fire(new c.k("zoomstart", t)), this._rotating && !s.rotating && this.fire(new c.k("rotatestart", t)), this._pitching && !s.pitching && this.fire(new c.k("pitchstart", t));
        }
        _prepareElevation(t) {
          this._elevationCenter = t, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(t) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const r = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (t < 1 && r !== this._elevationTarget) {
            const s = this._elevationTarget - this._elevationStart;
            this._elevationStart += t * (s - (r - (s * t + this._elevationStart)) / (1 - t)), this._elevationTarget = r;
          }
          this.transform.elevation = c.y.number(this._elevationStart, this._elevationTarget, t);
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(t) {
          const r = t.getCameraPosition(), s = this.terrain.getElevationForLngLatZoom(r.lngLat, t.zoom);
          if (r.altitude < s) {
            const l = this.calculateCameraOptionsFromTo(r.lngLat, s, t.center, t.elevation);
            return { pitch: l.pitch, zoom: l.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(t) {
          const r = [];
          if (this.terrain && r.push((l) => this._elevateCameraIfInsideTerrain(l)), this.transformCameraUpdate && r.push((l) => this.transformCameraUpdate(l)), !r.length) return;
          const s = t.clone();
          for (const l of r) {
            const h = s.clone(), { center: g, zoom: _, pitch: A, bearing: L, elevation: E } = l(h);
            g && (h.center = g), _ !== void 0 && (h.zoom = _), A !== void 0 && (h.pitch = A), L !== void 0 && (h.bearing = L), E !== void 0 && (h.elevation = E), s.apply(h);
          }
          this.transform.apply(s);
        }
        _fireMoveEvents(t) {
          this.fire(new c.k("move", t)), this._zooming && this.fire(new c.k("zoom", t)), this._rotating && this.fire(new c.k("rotate", t)), this._pitching && this.fire(new c.k("pitch", t));
        }
        _afterEase(t, r) {
          if (this._easeId && r && this._easeId === r) return;
          delete this._easeId;
          const s = this._zooming, l = this._rotating, h = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, s && this.fire(new c.k("zoomend", t)), l && this.fire(new c.k("rotateend", t)), h && this.fire(new c.k("pitchend", t)), this.fire(new c.k("moveend", t));
        }
        flyTo(t, r) {
          var s;
          if (!t.essential && O.prefersReducedMotion) {
            const xe = c.M(t, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(xe, r);
          }
          this.stop(), t = c.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: c.b9 }, t);
          const l = this._getTransformForUpdate(), h = l.zoom, g = l.bearing, _ = l.pitch, A = l.padding, L = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, E = "pitch" in t ? +t.pitch : _, M = "padding" in t ? t.padding : l.padding, R = c.P.convert(t.offset);
          let q = l.centerPoint.add(R);
          const B = l.pointLocation(q), { center: $, zoom: Q } = l.getConstrained(c.N.convert(t.center || B), (s = t.zoom) !== null && s !== void 0 ? s : h);
          this._normalizeCenter($, l);
          const tt = l.zoomScale(Q - h), nt = l.project(B), it = l.project($).sub(nt);
          let ht = t.curve;
          const wt = Math.max(l.width, l.height), _t = wt / tt, Vt = it.mag();
          if ("minZoom" in t) {
            const xe = c.ac(Math.min(t.minZoom, h, Q), l.minZoom, l.maxZoom), Ue = wt / l.zoomScale(xe - h);
            ht = Math.sqrt(Ue / Vt * 2);
          }
          const re = ht * ht;
          function ce(xe) {
            const Ue = (_t * _t - wt * wt + (xe ? -1 : 1) * re * re * Vt * Vt) / (2 * (xe ? _t : wt) * re * Vt);
            return Math.log(Math.sqrt(Ue * Ue + 1) - Ue);
          }
          function de(xe) {
            return (Math.exp(xe) - Math.exp(-xe)) / 2;
          }
          function ue(xe) {
            return (Math.exp(xe) + Math.exp(-xe)) / 2;
          }
          const he = ce(!1);
          let fe = function(xe) {
            return ue(he) / ue(he + ht * xe);
          }, Oe = function(xe) {
            return wt * ((ue(he) * (de(Ue = he + ht * xe) / ue(Ue)) - de(he)) / re) / Vt;
            var Ue;
          }, ve = (ce(!0) - he) / ht;
          if (Math.abs(Vt) < 1e-6 || !isFinite(ve)) {
            if (Math.abs(wt - _t) < 1e-6) return this.easeTo(t, r);
            const xe = _t < wt ? -1 : 1;
            ve = Math.abs(Math.log(_t / wt)) / ht, Oe = () => 0, fe = (Ue) => Math.exp(xe * ht * Ue);
          }
          return t.duration = "duration" in t ? +t.duration : 1e3 * ve / ("screenSpeed" in t ? +t.screenSpeed / ht : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = !0, this._rotating = g !== L, this._pitching = E !== _, this._padding = !l.isPaddingEqual(M), this._prepareEase(r, !1), this.terrain && this._prepareElevation($), this._ease((xe) => {
            const Ue = xe * ve, ni = 1 / fe(Ue);
            l.zoom = xe === 1 ? Q : h + l.scaleZoom(ni), this._rotating && (l.bearing = c.y.number(g, L, xe)), this._pitching && (l.pitch = c.y.number(_, E, xe)), this._padding && (l.interpolatePadding(A, M, xe), q = l.centerPoint.add(R)), this.terrain && !t.freezeElevation && this._updateElevation(xe);
            const ii = xe === 1 ? $ : l.unproject(nt.add(it.mult(Oe(Ue))).mult(ni));
            l.setLocationAtPoint(l.renderWorldCopies ? ii.wrap() : ii, q), this._applyUpdatedTransform(l), this._fireMoveEvents(r);
          }, () => {
            this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(r);
          }, t), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(t, r) {
          var s;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const l = this._onEaseEnd;
            delete this._onEaseEnd, l.call(this, r);
          }
          return t || (s = this.handlers) === null || s === void 0 || s.stop(!1), this;
        }
        _ease(t, r, s) {
          s.animate === !1 || s.duration === 0 ? (t(1), r()) : (this._easeStart = O.now(), this._easeOptions = s, this._onEaseFrame = t, this._onEaseEnd = r, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(t, r) {
          t = c.b3(t, -180, 180);
          const s = Math.abs(t - r);
          return Math.abs(t - 360 - r) < s && (t -= 360), Math.abs(t + 360 - r) < s && (t += 360), t;
        }
        _normalizeCenter(t, r) {
          if (!r.renderWorldCopies || r.lngRange) return;
          const s = t.lng - r.center.lng;
          t.lng += s > 180 ? -360 : s < -180 ? 360 : 0;
        }
        queryTerrainElevation(t) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(c.N.convert(t), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const yo = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class za {
        constructor(t = yo) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (r) => {
            !r || r.sourceDataType !== "metadata" && r.sourceDataType !== "visibility" && r.dataType !== "style" && r.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = t;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(t) {
          return this._map = t, this._compact = this.options.compact, this._container = j.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = j.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = j.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          j.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(t, r) {
          const s = this._map._getUIString(`AttributionControl.${r}`);
          t.title = s, t.setAttribute("aria-label", s);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let t = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map((l) => typeof l != "string" ? "" : l)) : typeof this.options.customAttribution == "string" && t.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const l = this._map.style.stylesheet;
            this.styleOwner = l.owner, this.styleId = l.id;
          }
          const r = this._map.style.sourceCaches;
          for (const l in r) {
            const h = r[l];
            if (h.used || h.usedForTerrain) {
              const g = h.getSource();
              g.attribution && t.indexOf(g.attribution) < 0 && t.push(g.attribution);
            }
          }
          t = t.filter((l) => String(l).trim()), t.sort((l, h) => l.length - h.length), t = t.filter((l, h) => {
            for (let g = h + 1; g < t.length; g++) if (t[g].indexOf(l) >= 0) return !1;
            return !0;
          });
          const s = t.join(" | ");
          s !== this._attribHTML && (this._attribHTML = s, t.length ? (this._innerContainer.innerHTML = s, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class ks {
        constructor(t = {}) {
          this._updateCompact = () => {
            const r = this._container.children;
            if (r.length) {
              const s = r[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && s.classList.add("maplibregl-compact") : s.classList.remove("maplibregl-compact");
            }
          }, this.options = t;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(t) {
          this._map = t, this._compact = this.options && this.options.compact, this._container = j.create("div", "maplibregl-ctrl");
          const r = j.create("a", "maplibregl-ctrl-logo");
          return r.target = "_blank", r.rel = "noopener nofollow", r.href = "https://maplibre.org/", r.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), r.setAttribute("rel", "noopener nofollow"), this._container.appendChild(r), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          j.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class fi {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(t) {
          const r = ++this._id;
          return this._queue.push({ callback: t, id: r, cancelled: !1 }), r;
        }
        remove(t) {
          const r = this._currentlyRunning, s = r ? this._queue.concat(r) : this._queue;
          for (const l of s) if (l.id === t) return void (l.cancelled = !0);
        }
        run(t = 0) {
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const r = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const s of r) if (!s.cancelled && (s.callback(t), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var jl = c.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class Fc extends c.E {
        constructor(t) {
          super(), this.sourceCache = t, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t.usedForTerrain = !0, t.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(t, r) {
          this.sourceCache.update(t, r), this._renderableTilesKeys = [];
          const s = {};
          for (const l of t.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: r })) s[l.key] = !0, this._renderableTilesKeys.push(l.key), this._tiles[l.key] || (l.posMatrix = new Float64Array(16), c.aP(l.posMatrix, 0, c.X, 0, c.X, 0, 1), this._tiles[l.key] = new cr(l, this.tileSize));
          for (const l in this._tiles) s[l] || delete this._tiles[l];
        }
        freeRtt(t) {
          for (const r in this._tiles) {
            const s = this._tiles[r];
            (!t || s.tileID.equals(t) || s.tileID.isChildOf(t) || t.isChildOf(s.tileID)) && (s.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((t) => this.getTileByID(t));
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        getTerrainCoords(t) {
          const r = {};
          for (const s of this._renderableTilesKeys) {
            const l = this._tiles[s].tileID;
            if (l.canonical.equals(t.canonical)) {
              const h = t.clone();
              h.posMatrix = new Float64Array(16), c.aP(h.posMatrix, 0, c.X, 0, c.X, 0, 1), r[s] = h;
            } else if (l.canonical.isChildOf(t.canonical)) {
              const h = t.clone();
              h.posMatrix = new Float64Array(16);
              const g = l.canonical.z - t.canonical.z, _ = l.canonical.x - (l.canonical.x >> g << g), A = l.canonical.y - (l.canonical.y >> g << g), L = c.X >> g;
              c.aP(h.posMatrix, 0, L, 0, L, 0, 1), c.J(h.posMatrix, h.posMatrix, [-_ * L, -A * L, 0]), r[s] = h;
            } else if (t.canonical.isChildOf(l.canonical)) {
              const h = t.clone();
              h.posMatrix = new Float64Array(16);
              const g = t.canonical.z - l.canonical.z, _ = t.canonical.x - (t.canonical.x >> g << g), A = t.canonical.y - (t.canonical.y >> g << g), L = c.X >> g;
              c.aP(h.posMatrix, 0, c.X, 0, c.X, 0, 1), c.J(h.posMatrix, h.posMatrix, [_ * L, A * L, 0]), c.K(h.posMatrix, h.posMatrix, [1 / 2 ** g, 1 / 2 ** g, 0]), r[s] = h;
            }
          }
          return r;
        }
        getSourceTile(t, r) {
          const s = this.sourceCache._source;
          let l = t.overscaledZ - this.deltaZoom;
          if (l > s.maxzoom && (l = s.maxzoom), l < s.minzoom) return null;
          this._sourceTileCache[t.key] || (this._sourceTileCache[t.key] = t.scaledTo(l).key);
          let h = this.sourceCache.getTileByID(this._sourceTileCache[t.key]);
          if ((!h || !h.dem) && r) for (; l >= s.minzoom && (!h || !h.dem); ) h = this.sourceCache.getTileByID(t.scaledTo(l--).key);
          return h;
        }
        tilesAfterTime(t = Date.now()) {
          return Object.values(this._tiles).filter((r) => r.timeAdded >= t);
        }
      }
      class ml {
        constructor(t, r, s) {
          this.painter = t, this.sourceCache = new Fc(r), this.options = s, this.exaggeration = typeof s.exaggeration == "number" ? s.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(t, r, s, l = c.X) {
          var h;
          if (!(r >= 0 && r < l && s >= 0 && s < l)) return 0;
          const g = this.getTerrainData(t), _ = (h = g.tile) === null || h === void 0 ? void 0 : h.dem;
          if (!_) return 0;
          const A = function(B, $, Q) {
            var tt = $[0], nt = $[1];
            return B[0] = Q[0] * tt + Q[4] * nt + Q[12], B[1] = Q[1] * tt + Q[5] * nt + Q[13], B;
          }([], [r / l * c.X, s / l * c.X], g.u_terrain_matrix), L = [A[0] * _.dim, A[1] * _.dim], E = Math.floor(L[0]), M = Math.floor(L[1]), R = L[0] - E, q = L[1] - M;
          return _.get(E, M) * (1 - R) * (1 - q) + _.get(E + 1, M) * R * (1 - q) + _.get(E, M + 1) * (1 - R) * q + _.get(E + 1, M + 1) * R * q;
        }
        getElevationForLngLatZoom(t, r) {
          if (!c.bb(r, t.wrap())) return 0;
          const { tileID: s, mercatorX: l, mercatorY: h } = this._getOverscaledTileIDFromLngLatZoom(t, r);
          return this.getElevation(s, l % c.X, h % c.X, c.X);
        }
        getElevation(t, r, s, l = c.X) {
          return this.getDEMElevation(t, r, s, l) * this.exaggeration;
        }
        getTerrainData(t) {
          if (!this._emptyDemTexture) {
            const l = this.painter.context, h = new c.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new at(l, h, l.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new at(l, new c.R({ width: 1, height: 1 }), l.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(l.gl.NEAREST, l.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = c.an([]);
          }
          const r = this.sourceCache.getSourceTile(t, !0);
          if (r && r.dem && (!r.demTexture || r.needsTerrainPrepare)) {
            const l = this.painter.context;
            r.demTexture = this.painter.getTileTexture(r.dem.stride), r.demTexture ? r.demTexture.update(r.dem.getPixels(), { premultiply: !1 }) : r.demTexture = new at(l, r.dem.getPixels(), l.gl.RGBA, { premultiply: !1 }), r.demTexture.bind(l.gl.NEAREST, l.gl.CLAMP_TO_EDGE), r.needsTerrainPrepare = !1;
          }
          const s = r && r + r.tileID.key + t.key;
          if (s && !this._demMatrixCache[s]) {
            const l = this.sourceCache.sourceCache._source.maxzoom;
            let h = t.canonical.z - r.tileID.canonical.z;
            t.overscaledZ > t.canonical.z && (t.canonical.z >= l ? h = t.canonical.z - l : c.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const g = t.canonical.x - (t.canonical.x >> h << h), _ = t.canonical.y - (t.canonical.y >> h << h), A = c.bc(new Float64Array(16), [1 / (c.X << h), 1 / (c.X << h), 0]);
            c.J(A, A, [g * c.X, _ * c.X, 0]), this._demMatrixCache[t.key] = { matrix: A, coord: t };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: r && r.dem && r.dem.dim || 1, u_terrain_matrix: s ? this._demMatrixCache[t.key].matrix : this._emptyDemMatrix, u_terrain_unpack: r && r.dem && r.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (r && r.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: r };
        }
        getFramebuffer(t) {
          const r = this.painter, s = r.width / devicePixelRatio, l = r.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === s && this._fbo.height === l || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new at(r.context, { width: s, height: l, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new at(r.context, { width: s, height: l, data: null }, r.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(r.context.gl.NEAREST, r.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = r.context.createFramebuffer(s, l, !0, !1), this._fbo.depthAttachment.set(r.context.createRenderbuffer(r.context.gl.DEPTH_COMPONENT16, s, l))), this._fbo.colorAttachment.set(t === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const t = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const r = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let h = 0, g = 0; h < this._coordsTextureSize; h++) for (let _ = 0; _ < this._coordsTextureSize; _++, g += 4) r[g + 0] = 255 & _, r[g + 1] = 255 & h, r[g + 2] = _ >> 8 << 4 | h >> 8, r[g + 3] = 0;
          const s = new c.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(r.buffer)), l = new at(t, s, t.gl.RGBA, { premultiply: !1 });
          return l.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE), this._coordsTexture = l, l;
        }
        pointCoordinate(t) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const r = new Uint8Array(4), s = this.painter.context, l = s.gl, h = Math.round(t.x * this.painter.pixelRatio / devicePixelRatio), g = Math.round(t.y * this.painter.pixelRatio / devicePixelRatio), _ = Math.round(this.painter.height / devicePixelRatio);
          s.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), l.readPixels(h, _ - g - 1, 1, 1, l.RGBA, l.UNSIGNED_BYTE, r), s.bindFramebuffer.set(null);
          const A = r[0] + (r[2] >> 4 << 8), L = r[1] + ((15 & r[2]) << 8), E = this.coordsIndex[255 - r[3]], M = E && this.sourceCache.getTileByID(E);
          if (!M) return null;
          const R = this._coordsTextureSize, q = (1 << M.tileID.canonical.z) * R;
          return new c.Z((M.tileID.canonical.x * R + A) / q + M.tileID.wrap, (M.tileID.canonical.y * R + L) / q, this.getElevation(M.tileID, A, L, R));
        }
        depthAtPoint(t) {
          const r = new Uint8Array(4), s = this.painter.context, l = s.gl;
          return s.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), l.readPixels(t.x, this.painter.height / devicePixelRatio - t.y - 1, 1, 1, l.RGBA, l.UNSIGNED_BYTE, r), s.bindFramebuffer.set(null), (r[0] / 16777216 + r[1] / 65536 + r[2] / 256 + r[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh) return this._mesh;
          const t = this.painter.context, r = new c.bd(), s = new c.aY(), l = this.meshSize, h = c.X / l, g = l * l;
          for (let M = 0; M <= l; M++) for (let R = 0; R <= l; R++) r.emplaceBack(R * h, M * h, 0);
          for (let M = 0; M < g; M += l + 1) for (let R = 0; R < l; R++) s.emplaceBack(R + M, l + R + M + 1, l + R + M + 2), s.emplaceBack(R + M, l + R + M + 2, R + M + 1);
          const _ = r.length, A = _ + 2 * (l + 1);
          for (const M of [0, 1]) for (let R = 0; R <= l; R++) for (const q of [0, 1]) r.emplaceBack(R * h, M * c.X, q);
          for (let M = 0; M < 2 * l; M += 2) s.emplaceBack(A + M, A + M + 1, A + M + 3), s.emplaceBack(A + M, A + M + 3, A + M + 2), s.emplaceBack(_ + M, _ + M + 3, _ + M + 1), s.emplaceBack(_ + M, _ + M + 2, _ + M + 3);
          const L = r.length, E = L + 2 * (l + 1);
          for (const M of [0, 1]) for (let R = 0; R <= l; R++) for (const q of [0, 1]) r.emplaceBack(M * c.X, R * h, q);
          for (let M = 0; M < 2 * l; M += 2) s.emplaceBack(L + M, L + M + 1, L + M + 3), s.emplaceBack(L + M, L + M + 3, L + M + 2), s.emplaceBack(E + M, E + M + 3, E + M + 1), s.emplaceBack(E + M, E + M + 2, E + M + 3);
          return this._mesh = new ar(t.createVertexBuffer(r, jl.members), t.createIndexBuffer(s), c.a0.simpleSegment(0, 0, r.length, s.length)), this._mesh;
        }
        getMeshFrameDelta(t) {
          return 2 * Math.PI * c.be / Math.pow(2, t) / 5;
        }
        getMinTileElevationForLngLatZoom(t, r) {
          var s;
          const { tileID: l } = this._getOverscaledTileIDFromLngLatZoom(t, r);
          return (s = this.getMinMaxElevation(l).minElevation) !== null && s !== void 0 ? s : 0;
        }
        getMinMaxElevation(t) {
          const r = this.getTerrainData(t).tile, s = { minElevation: null, maxElevation: null };
          return r && r.dem && (s.minElevation = r.dem.min * this.exaggeration, s.maxElevation = r.dem.max * this.exaggeration), s;
        }
        _getOverscaledTileIDFromLngLatZoom(t, r) {
          const s = c.Z.fromLngLat(t.wrap()), l = (1 << r) * c.X, h = s.x * l, g = s.y * l, _ = Math.floor(h / c.X), A = Math.floor(g / c.X);
          return { tileID: new c.S(r, 0, r, _, A), mercatorX: h, mercatorY: g };
        }
      }
      class ac {
        constructor(t, r, s) {
          this._context = t, this._size = r, this._tileSize = s, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const t of this._objects) t.texture.destroy(), t.fbo.destroy();
        }
        _createObject(t) {
          const r = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), s = new at(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return s.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), r.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), r.colorAttachment.set(s.texture), { id: t, fbo: r, texture: s, stamp: -1, inUse: !1 };
        }
        getObjectForId(t) {
          return this._objects[t];
        }
        useObject(t) {
          t.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((r) => t.id !== r), this._recentlyUsed.push(t.id);
        }
        stampObject(t) {
          t.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const r of this._recentlyUsed) if (!this._objects[r].inUse) return this._objects[r];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const t = this._createObject(this._objects.length);
          return this._objects.push(t), t;
        }
        freeObject(t) {
          t.inUse = !1;
        }
        freeAllObjects() {
          for (const t of this._objects) this.freeObject(t);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((t) => !t.inUse) === !1;
        }
      }
      const Na = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class ql {
        constructor(t, r) {
          this.painter = t, this.terrain = r, this.pool = new ac(t.context, 30, r.sourceCache.tileSize * r.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(t) {
          return this.pool.getObjectForId(t.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(t, r) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t._order.filter((s) => !t._layers[s].isHidden(r)), this._coordsDescendingInv = {};
          for (const s in t.sourceCaches) {
            this._coordsDescendingInv[s] = {};
            const l = t.sourceCaches[s].getVisibleCoordinates();
            for (const h of l) {
              const g = this.terrain.sourceCache.getTerrainCoords(h);
              for (const _ in g) this._coordsDescendingInv[s][_] || (this._coordsDescendingInv[s][_] = []), this._coordsDescendingInv[s][_].push(g[_]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const s of t._order) {
            const l = t._layers[s], h = l.source;
            if (Na[l.type] && !this._coordsDescendingInvStr[h]) {
              this._coordsDescendingInvStr[h] = {};
              for (const g in this._coordsDescendingInv[h]) this._coordsDescendingInvStr[h][g] = this._coordsDescendingInv[h][g].map((_) => _.key).sort().join();
            }
          }
          for (const s of this._renderableTiles) for (const l in this._coordsDescendingInvStr) {
            const h = this._coordsDescendingInvStr[l][s.tileID.key];
            h && h !== s.rttCoords[l] && (s.rtt = []);
          }
        }
        renderLayer(t) {
          if (t.isHidden(this.painter.transform.zoom)) return !1;
          const r = t.type, s = this.painter, l = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t.id;
          if (Na[r] && (this._prevType && Na[this._prevType] || this._stacks.push([]), this._prevType = r, this._stacks[this._stacks.length - 1].push(t.id), !l)) return !0;
          if (Na[this._prevType] || Na[r] && l) {
            this._prevType = r;
            const h = this._stacks.length - 1, g = this._stacks[h] || [];
            for (const _ of this._renderableTiles) {
              if (this.pool.isFull() && (ws(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(_), _.rtt[h]) {
                const L = this.pool.getObjectForId(_.rtt[h].id);
                if (L.stamp === _.rtt[h].stamp) {
                  this.pool.useObject(L);
                  continue;
                }
              }
              const A = this.pool.getOrCreateFreeObject();
              this.pool.useObject(A), this.pool.stampObject(A), _.rtt[h] = { id: A.id, stamp: A.stamp }, s.context.bindFramebuffer.set(A.fbo.framebuffer), s.context.clear({ color: c.aM.transparent, stencil: 0 }), s.currentStencilSource = void 0;
              for (let L = 0; L < g.length; L++) {
                const E = s.style._layers[g[L]], M = E.source ? this._coordsDescendingInv[E.source][_.tileID.key] : [_.tileID];
                s.context.viewport.set([0, 0, A.fbo.width, A.fbo.height]), s._renderTileClippingMasks(E, M), s.renderLayer(s, s.style.sourceCaches[E.source], E, M), E.source && (_.rttCoords[E.source] = this._coordsDescendingInvStr[E.source][_.tileID.key]);
              }
            }
            return ws(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), Na[r];
          }
          return !1;
        }
      }
      const Ul = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Yo = z, gl = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: yo, maplibreLogo: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, refreshExpiredTiles: !0, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: c.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0 }, Da = (o) => {
        o.touchstart = o.dragStart, o.touchmoveWindow = o.dragMove, o.touchend = o.dragEnd;
      }, Vl = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class oc {
        constructor(t, r, s = !1) {
          this.mousedown = (g) => {
            this.startMouse(c.e({}, g, { ctrlKey: !0, preventDefault: () => g.preventDefault() }), j.mousePos(this.element, g)), j.addEventListener(window, "mousemove", this.mousemove), j.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (g) => {
            this.moveMouse(g, j.mousePos(this.element, g));
          }, this.mouseup = (g) => {
            this.mouseRotate.dragEnd(g), this.mousePitch && this.mousePitch.dragEnd(g), this.offTemp();
          }, this.touchstart = (g) => {
            g.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = j.touchPos(this.element, g.targetTouches)[0], this.startTouch(g, this._startPos), j.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), j.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (g) => {
            g.targetTouches.length !== 1 ? this.reset() : (this._lastPos = j.touchPos(this.element, g.targetTouches)[0], this.moveTouch(g, this._lastPos));
          }, this.touchend = (g) => {
            g.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const l = t.dragRotate._mouseRotate.getClickTolerance(), h = t.dragRotate._mousePitch.getClickTolerance();
          this.element = r, this.mouseRotate = uo({ clickTolerance: l, enable: !0 }), this.touchRotate = (({ enable: g, clickTolerance: _, bearingDegreesPerPixelMoved: A = 0.8 }) => {
            const L = new fl();
            return new kr({ clickTolerance: _, move: (E, M) => ({ bearingDelta: (M.x - E.x) * A }), moveStateManager: L, enable: g, assignEvents: Da });
          })({ clickTolerance: l, enable: !0 }), this.map = t, s && (this.mousePitch = Zo({ clickTolerance: h, enable: !0 }), this.touchPitch = (({ enable: g, clickTolerance: _, pitchDegreesPerPixelMoved: A = -0.5 }) => {
            const L = new fl();
            return new kr({ clickTolerance: _, move: (E, M) => ({ pitchDelta: (M.y - E.y) * A }), moveStateManager: L, enable: g, assignEvents: Da });
          })({ clickTolerance: h, enable: !0 })), j.addEventListener(r, "mousedown", this.mousedown), j.addEventListener(r, "touchstart", this.touchstart, { passive: !1 }), j.addEventListener(r, "touchcancel", this.reset);
        }
        startMouse(t, r) {
          this.mouseRotate.dragStart(t, r), this.mousePitch && this.mousePitch.dragStart(t, r), j.disableDrag();
        }
        startTouch(t, r) {
          this.touchRotate.dragStart(t, r), this.touchPitch && this.touchPitch.dragStart(t, r), j.disableDrag();
        }
        moveMouse(t, r) {
          const s = this.map, { bearingDelta: l } = this.mouseRotate.dragMove(t, r) || {};
          if (l && s.setBearing(s.getBearing() + l), this.mousePitch) {
            const { pitchDelta: h } = this.mousePitch.dragMove(t, r) || {};
            h && s.setPitch(s.getPitch() + h);
          }
        }
        moveTouch(t, r) {
          const s = this.map, { bearingDelta: l } = this.touchRotate.dragMove(t, r) || {};
          if (l && s.setBearing(s.getBearing() + l), this.touchPitch) {
            const { pitchDelta: h } = this.touchPitch.dragMove(t, r) || {};
            h && s.setPitch(s.getPitch() + h);
          }
        }
        off() {
          const t = this.element;
          j.removeEventListener(t, "mousedown", this.mousedown), j.removeEventListener(t, "touchstart", this.touchstart, { passive: !1 }), j.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), j.removeEventListener(window, "touchend", this.touchend), j.removeEventListener(t, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          j.enableDrag(), j.removeEventListener(window, "mousemove", this.mousemove), j.removeEventListener(window, "mouseup", this.mouseup), j.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), j.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Ln;
      function Xi(o, t, r) {
        const s = new c.N(o.lng, o.lat);
        if (o = new c.N(o.lng, o.lat), t) {
          const l = new c.N(o.lng - 360, o.lat), h = new c.N(o.lng + 360, o.lat), g = r.locationPoint(o).distSqr(t);
          r.locationPoint(l).distSqr(t) < g ? o = l : r.locationPoint(h).distSqr(t) < g && (o = h);
        }
        for (; Math.abs(o.lng - r.center.lng) > 180; ) {
          const l = r.locationPoint(o);
          if (l.x >= 0 && l.y >= 0 && l.x <= r.width && l.y <= r.height) break;
          o.lng > r.center.lng ? o.lng -= 360 : o.lng += 360;
        }
        return o.lng !== s.lng && r.locationPoint(o).y > r.height / 2 - r.getHorizon() ? o : s;
      }
      const _o = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function yl(o, t, r) {
        const s = o.classList;
        for (const l in _o) s.remove(`maplibregl-${r}-anchor-${l}`);
        s.add(`maplibregl-${r}-anchor-${t}`);
      }
      class _l extends c.E {
        constructor(t) {
          if (super(), this._onKeyPress = (r) => {
            const s = r.code, l = r.charCode || r.keyCode;
            s !== "Space" && s !== "Enter" && l !== 32 && l !== 13 || this.togglePopup();
          }, this._onMapClick = (r) => {
            const s = r.originalEvent.target, l = this._element;
            this._popup && (s === l || l.contains(s)) && this.togglePopup();
          }, this._update = (r) => {
            var s;
            if (!this._map) return;
            const l = this._map.loaded() && !this._map.isMoving();
            ((r == null ? void 0 : r.type) === "terrain" || (r == null ? void 0 : r.type) === "render" && !l) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Xi(this._lngLat, this._flatPos, this._map.transform) : (s = this._lngLat) === null || s === void 0 ? void 0 : s.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let h = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? h = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (h = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let g = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? g = "rotateX(0deg)" : this._pitchAlignment === "map" && (g = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || r && r.type !== "moveend" || (this._pos = this._pos.round()), j.setTransform(this._element, `${_o[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${g} ${h}`), O.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(r && r.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (r) => {
            if (!this._isDragging) {
              const s = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = r.point.dist(this._pointerdownPos) >= s;
            }
            this._isDragging && (this._pos = r.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new c.k("dragstart"))), this.fire(new c.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new c.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (r) => {
            this._element.contains(r.originalEvent.target) && (r.preventDefault(), this._positionDelta = r.point.sub(this._pos).add(this._offset), this._pointerdownPos = r.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._subpixelPositioning = t && t.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment !== "auto" ? t.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(t == null ? void 0 : t.opacity, t == null ? void 0 : t.opacityWhenCovered), t && t.element) this._element = t.element, this._offset = c.P.convert(t && t.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = j.create("div");
            const r = j.createNS("http://www.w3.org/2000/svg", "svg"), s = 41, l = 27;
            r.setAttributeNS(null, "display", "block"), r.setAttributeNS(null, "height", `${s}px`), r.setAttributeNS(null, "width", `${l}px`), r.setAttributeNS(null, "viewBox", `0 0 ${l} ${s}`);
            const h = j.createNS("http://www.w3.org/2000/svg", "g");
            h.setAttributeNS(null, "stroke", "none"), h.setAttributeNS(null, "stroke-width", "1"), h.setAttributeNS(null, "fill", "none"), h.setAttributeNS(null, "fill-rule", "evenodd");
            const g = j.createNS("http://www.w3.org/2000/svg", "g");
            g.setAttributeNS(null, "fill-rule", "nonzero");
            const _ = j.createNS("http://www.w3.org/2000/svg", "g");
            _.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), _.setAttributeNS(null, "fill", "#000000");
            const A = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const tt of A) {
              const nt = j.createNS("http://www.w3.org/2000/svg", "ellipse");
              nt.setAttributeNS(null, "opacity", "0.04"), nt.setAttributeNS(null, "cx", "10.5"), nt.setAttributeNS(null, "cy", "5.80029008"), nt.setAttributeNS(null, "rx", tt.rx), nt.setAttributeNS(null, "ry", tt.ry), _.appendChild(nt);
            }
            const L = j.createNS("http://www.w3.org/2000/svg", "g");
            L.setAttributeNS(null, "fill", this._color);
            const E = j.createNS("http://www.w3.org/2000/svg", "path");
            E.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), L.appendChild(E);
            const M = j.createNS("http://www.w3.org/2000/svg", "g");
            M.setAttributeNS(null, "opacity", "0.25"), M.setAttributeNS(null, "fill", "#000000");
            const R = j.createNS("http://www.w3.org/2000/svg", "path");
            R.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), M.appendChild(R);
            const q = j.createNS("http://www.w3.org/2000/svg", "g");
            q.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), q.setAttributeNS(null, "fill", "#FFFFFF");
            const B = j.createNS("http://www.w3.org/2000/svg", "g");
            B.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const $ = j.createNS("http://www.w3.org/2000/svg", "circle");
            $.setAttributeNS(null, "fill", "#000000"), $.setAttributeNS(null, "opacity", "0.25"), $.setAttributeNS(null, "cx", "5.5"), $.setAttributeNS(null, "cy", "5.5"), $.setAttributeNS(null, "r", "5.4999962");
            const Q = j.createNS("http://www.w3.org/2000/svg", "circle");
            Q.setAttributeNS(null, "fill", "#FFFFFF"), Q.setAttributeNS(null, "cx", "5.5"), Q.setAttributeNS(null, "cy", "5.5"), Q.setAttributeNS(null, "r", "5.4999962"), B.appendChild($), B.appendChild(Q), g.appendChild(_), g.appendChild(L), g.appendChild(M), g.appendChild(q), g.appendChild(B), r.appendChild(g), r.setAttributeNS(null, "height", s * this._scale + "px"), r.setAttributeNS(null, "width", l * this._scale + "px"), this._element.appendChild(r), this._offset = c.P.convert(t && t.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (r) => {
            r.preventDefault();
          }), this._element.addEventListener("mousedown", (r) => {
            r.preventDefault();
          }), yl(this._element, this._anchor, "marker"), t && t.className) for (const r of t.className.split(" ")) this._element.classList.add(r);
          this._popup = null;
        }
        addTo(t) {
          return this.remove(), this._map = t, this._element.setAttribute("aria-label", t._getUIString("Marker.Title")), t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), t.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), j.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t) {
          return this._lngLat = c.N.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(t) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
            if (!("offset" in t.options)) {
              const l = Math.abs(13.5) / Math.SQRT2;
              t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [l, -1 * (38.1 - 13.5 + l)], "bottom-right": [-l, -1 * (38.1 - 13.5 + l)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = t, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(t) {
          return this._subpixelPositioning = t, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : t ? (t.isOpen() ? t.remove() : (t.setLngLat(this._lngLat), t.addTo(this._map)), this) : this;
        }
        _updateOpacity(t = !1) {
          var r, s;
          if (!(!((r = this._map) === null || r === void 0) && r.terrain)) return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (t) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const l = this._map, h = l.terrain.depthAtPoint(this._pos), g = l.terrain.getElevationForLngLatZoom(this._lngLat, l.transform.tileZoom);
          if (l.transform.lngLatToCameraDepth(this._lngLat, g) - h < 6e-3) return void (this._element.style.opacity = this._opacity);
          const _ = -this._offset.y / l.transform._pixelPerMeter, A = Math.sin(l.getPitch() * Math.PI / 180) * _, L = l.terrain.depthAtPoint(new c.P(this._pos.x, this._pos.y - this._offset.y)), E = l.transform.lngLatToCameraDepth(this._lngLat, g + A) - L > 6e-3;
          !((s = this._popup) === null || s === void 0) && s.isOpen() && E && this._popup.remove(), this._element.style.opacity = E ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t) {
          return this._offset = c.P.convert(t), this._update(), this;
        }
        addClassName(t) {
          this._element.classList.add(t);
        }
        removeClassName(t) {
          this._element.classList.remove(t);
        }
        toggleClassName(t) {
          return this._element.classList.toggle(t);
        }
        setDraggable(t) {
          return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t) {
          return this._rotation = t || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t) {
          return this._rotationAlignment = t || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(t) {
          return this._pitchAlignment = t && t !== "auto" ? t : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(t, r) {
          return t === void 0 && r === void 0 && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t !== void 0 && (this._opacity = t), r !== void 0 && (this._opacityWhenCovered = r), this._map && this._updateOpacity(!0), this;
        }
      }
      const lc = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let Ko = 0, Jo = !1;
      const hs = { maxWidth: 100, unit: "metric" };
      function ua(o, t, r) {
        const s = r && r.maxWidth || 100, l = o._container.clientHeight / 2, h = o.unproject([0, l]), g = o.unproject([s, l]), _ = h.distanceTo(g);
        if (r && r.unit === "imperial") {
          const A = 3.2808 * _;
          A > 5280 ? je(t, s, A / 5280, o._getUIString("ScaleControl.Miles")) : je(t, s, A, o._getUIString("ScaleControl.Feet"));
        } else r && r.unit === "nautical" ? je(t, s, _ / 1852, o._getUIString("ScaleControl.NauticalMiles")) : _ >= 1e3 ? je(t, s, _ / 1e3, o._getUIString("ScaleControl.Kilometers")) : je(t, s, _, o._getUIString("ScaleControl.Meters"));
      }
      function je(o, t, r, s) {
        const l = function(h) {
          const g = Math.pow(10, `${Math.floor(h)}`.length - 1);
          let _ = h / g;
          return _ = _ >= 10 ? 10 : _ >= 5 ? 5 : _ >= 3 ? 3 : _ >= 2 ? 2 : _ >= 1 ? 1 : function(A) {
            const L = Math.pow(10, Math.ceil(-Math.log(A) / Math.LN10));
            return Math.round(A * L) / L;
          }(_), g * _;
        }(r);
        o.style.width = t * (l / r) + "px", o.innerHTML = `${l}&nbsp;${s}`;
      }
      const Qe = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, Qo = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function p(o) {
        if (o) {
          if (typeof o == "number") {
            const t = Math.round(Math.abs(o) / Math.SQRT2);
            return { center: new c.P(0, 0), top: new c.P(0, o), "top-left": new c.P(t, t), "top-right": new c.P(-t, t), bottom: new c.P(0, -o), "bottom-left": new c.P(t, -t), "bottom-right": new c.P(-t, -t), left: new c.P(o, 0), right: new c.P(-o, 0) };
          }
          if (o instanceof c.P || Array.isArray(o)) {
            const t = c.P.convert(o);
            return { center: t, top: t, "top-left": t, "top-right": t, bottom: t, "bottom-left": t, "bottom-right": t, left: t, right: t };
          }
          return { center: c.P.convert(o.center || [0, 0]), top: c.P.convert(o.top || [0, 0]), "top-left": c.P.convert(o["top-left"] || [0, 0]), "top-right": c.P.convert(o["top-right"] || [0, 0]), bottom: c.P.convert(o.bottom || [0, 0]), "bottom-left": c.P.convert(o["bottom-left"] || [0, 0]), "bottom-right": c.P.convert(o["bottom-right"] || [0, 0]), left: c.P.convert(o.left || [0, 0]), right: c.P.convert(o.right || [0, 0]) };
        }
        return p(new c.P(0, 0));
      }
      const w = z;
      v.AJAXError = c.bh, v.Evented = c.E, v.LngLat = c.N, v.MercatorCoordinate = c.Z, v.Point = c.P, v.addProtocol = c.bi, v.config = c.a, v.removeProtocol = c.bj, v.AttributionControl = za, v.BoxZoomHandler = Nr, v.CanvasSource = ai, v.CooperativeGesturesHandler = go, v.DoubleClickZoomHandler = qs, v.DragPanHandler = sc, v.DragRotateHandler = Rl, v.EdgeInsets = ss, v.FullscreenControl = class extends c.E {
        constructor(o = {}) {
          super(), this._onFullscreenChange = () => {
            var t;
            let r = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((t = r == null ? void 0 : r.shadowRoot) === null || t === void 0) && t.fullscreenElement; ) r = r.shadowRoot.fullscreenElement;
            r === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, o && o.container && (o.container instanceof HTMLElement ? this._container = o.container : c.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(o) {
          return this._map = o, this._container || (this._container = this._map.getContainer()), this._controlContainer = j.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          j.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const o = this._fullscreenButton = j.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          j.create("span", "maplibregl-ctrl-icon", o).setAttribute("aria-hidden", "true"), o.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const o = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", o), this._fullscreenButton.title = o;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new c.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new c.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, v.GeoJSONSource = ze, v.GeolocateControl = class extends c.E {
        constructor(o) {
          super(), this._onSuccess = (t) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new c.k("outofmaxbounds", t)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new c.k("geolocate", t)), this._finish();
            }
          }, this._updateCamera = (t) => {
            const r = new c.N(t.coords.longitude, t.coords.latitude), s = t.coords.accuracy, l = this._map.getBearing(), h = c.e({ bearing: l }, this.options.fitBoundsOptions), g = Y.fromLngLat(r, s);
            this._map.fitBounds(g, h, { geolocateSource: !0 });
          }, this._updateMarker = (t) => {
            if (t) {
              const r = new c.N(t.coords.longitude, t.coords.latitude);
              this._accuracyCircleMarker.setLngLat(r).addTo(this._map), this._userLocationDotMarker.setLngLat(r).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (t) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (t.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (t.code === 3 && Jo) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new c.k("error", t)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this._geolocateButton = j.create("button", "maplibregl-ctrl-geolocate", this._container), j.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
          }, this._finishSetupUI = (t) => {
            if (this._map) {
              if (t === !1) {
                c.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const r = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
              } else {
                const r = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = !1, this._geolocateButton.title = r, this._geolocateButton.setAttribute("aria-label", r);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = j.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new _l({ element: this._dotElement }), this._circleElement = j.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new _l({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (r) => {
                r.geolocateSource || this._watchState !== "ACTIVE_LOCK" || r.originalEvent && r.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new c.k("trackuserlocationend")), this.fire(new c.k("userlocationlostfocus")));
              });
            }
          }, this.options = c.e({}, lc, o);
        }
        onAdd(o) {
          return this._map = o, this._container = j.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return c._(this, arguments, void 0, function* (t = !1) {
              if (Ln !== void 0 && !t) return Ln;
              if (window.navigator.permissions === void 0) return Ln = !!window.navigator.geolocation, Ln;
              try {
                Ln = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
              } catch {
                Ln = !!window.navigator.geolocation;
              }
              return Ln;
            });
          }().then((t) => this._finishSetupUI(t)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), j.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ko = 0, Jo = !1;
        }
        _isOutOfMapMaxBounds(o) {
          const t = this._map.getMaxBounds(), r = o.coords;
          return t && (r.longitude < t.getWest() || r.longitude > t.getEast() || r.latitude < t.getSouth() || r.latitude > t.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const o = this._map.getBounds(), t = o.getSouthEast(), r = o.getNorthEast(), s = t.distanceTo(r), l = Math.ceil(this._accuracy / (s / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${l}px`, this._circleElement.style.height = `${l}px`;
        }
        trigger() {
          if (!this._setup) return c.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new c.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Ko--, Jo = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new c.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new c.k("trackuserlocationstart")), this.fire(new c.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let o;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ko++, Ko > 1 ? (o = { maximumAge: 6e5, timeout: 0 }, Jo = !0) : (o = this.options.positionOptions, Jo = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, o);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, v.Hash = As, v.ImageSource = Ze, v.KeyboardHandler = jn, v.LngLatBounds = Y, v.LogoControl = ks, v.Map = class extends Is {
        constructor(o) {
          c.bf.mark(c.bg.create);
          const t = Object.assign(Object.assign({}, gl), o);
          if (t.minZoom != null && t.maxZoom != null && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (t.minPitch != null && t.maxPitch != null && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (t.minPitch != null && t.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (t.maxPitch != null && t.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (super(new Ss(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), { bearingSnap: t.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new fi(), this._controls = [], this._mapId = c.a4(), this._contextLost = (r) => {
            r.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new c.k("webglcontextlost", { originalEvent: r }));
          }, this._contextRestored = (r) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new c.k("webglcontextrestored", { originalEvent: r }));
          }, this._onMapScroll = (r) => {
            if (r.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = t.interactive, this._maxTileCacheSize = t.maxTileCacheSize, this._maxTileCacheZoomLevels = t.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat === !0, this._preserveDrawingBuffer = t.preserveDrawingBuffer === !0, this._antialias = t.antialias === !0, this._trackResize = t.trackResize === !0, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles === !0, this._fadeDuration = t.fadeDuration, this._crossSourceCollisions = t.crossSourceCollisions === !0, this._collectResourceTiming = t.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Ul), t.locale), this._clickTolerance = t.clickTolerance, this._overridePixelRatio = t.pixelRatio, this._maxCanvasSize = t.maxCanvasSize, this.transformCameraUpdate = t.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = t.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = zt.addThrottleControl(() => this.isMoving()), this._requestManager = new Jt(t.transformRequest), typeof t.container == "string") {
            if (this._container = document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`);
          } else {
            if (!(t.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t.container;
          }
          if (t.maxBounds && this.setMaxBounds(t.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)).on("moveend", () => this._update(!1)).on("zoom", () => this._update(!0)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }).once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let r = !1;
            const s = as((l) => {
              this._trackResize && !this._removed && (this.resize(l), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((l) => {
              r ? s(l) : r = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new Tn(this, t), this._hash = t.hash && new As(typeof t.hash == "string" && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t.center, zoom: t.zoom, bearing: t.bearing, pitch: t.pitch }), t.bounds && (this.resize(), this.fitBounds(t.bounds, c.e({}, t.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = t.localIdeographFontFamily, this._validateStyle = t.validateStyle, t.style && this.setStyle(t.style, { localIdeographFontFamily: t.localIdeographFontFamily }), t.attributionControl && this.addControl(new za(typeof t.attributionControl == "boolean" ? void 0 : t.attributionControl)), t.maplibreLogo && this.addControl(new ks(), t.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (r) => {
            this._update(r.dataType === "style"), this.fire(new c.k(`${r.dataType}data`, r));
          }), this.on("dataloading", (r) => {
            this.fire(new c.k(`${r.dataType}dataloading`, r));
          }), this.on("dataabort", (r) => {
            this.fire(new c.k("sourcedataabort", r));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(o, t) {
          if (t === void 0 && (t = o.getDefaultPosition ? o.getDefaultPosition() : "top-right"), !o || !o.onAdd) return this.fire(new c.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const r = o.onAdd(this);
          this._controls.push(o);
          const s = this._controlPositions[t];
          return t.indexOf("bottom") !== -1 ? s.insertBefore(r, s.firstChild) : s.appendChild(r), this;
        }
        removeControl(o) {
          if (!o || !o.onRemove) return this.fire(new c.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const t = this._controls.indexOf(o);
          return t > -1 && this._controls.splice(t, 1), o.onRemove(this), this;
        }
        hasControl(o) {
          return this._controls.indexOf(o) > -1;
        }
        calculateCameraOptionsFromTo(o, t, r, s) {
          return s == null && this.terrain && (s = this.terrain.getElevationForLngLatZoom(r, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(o, t, r, s);
        }
        resize(o) {
          var t;
          const r = this._containerDimensions(), s = r[0], l = r[1], h = this._getClampedPixelRatio(s, l);
          if (this._resizeCanvas(s, l, h), this.painter.resize(s, l, h), this.painter.overLimit()) {
            const _ = this.painter.context.gl;
            this._maxCanvasSize = [_.drawingBufferWidth, _.drawingBufferHeight];
            const A = this._getClampedPixelRatio(s, l);
            this._resizeCanvas(s, l, A), this.painter.resize(s, l, A);
          }
          this.transform.resize(s, l), (t = this._requestedCameraState) === null || t === void 0 || t.resize(s, l);
          const g = !this._moving;
          return g && (this.stop(), this.fire(new c.k("movestart", o)).fire(new c.k("move", o))), this.fire(new c.k("resize", o)), g && this.fire(new c.k("moveend", o)), this;
        }
        _getClampedPixelRatio(o, t) {
          const { 0: r, 1: s } = this._maxCanvasSize, l = this.getPixelRatio(), h = o * l, g = t * l;
          return Math.min(h > r ? r / h : 1, g > s ? s / g : 1) * l;
        }
        getPixelRatio() {
          var o;
          return (o = this._overridePixelRatio) !== null && o !== void 0 ? o : devicePixelRatio;
        }
        setPixelRatio(o) {
          this._overridePixelRatio = o, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(o) {
          return this.transform.setMaxBounds(Y.convert(o)), this._update();
        }
        setMinZoom(o) {
          if ((o = o ?? -2) >= -2 && o <= this.transform.maxZoom) return this.transform.minZoom = o, this._update(), this.getZoom() < o && this.setZoom(o), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(o) {
          if ((o = o ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = o, this._update(), this.getZoom() > o && this.setZoom(o), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(o) {
          if ((o = o ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (o >= 0 && o <= this.transform.maxPitch) return this.transform.minPitch = o, this._update(), this.getPitch() < o && this.setPitch(o), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(o) {
          if ((o = o ?? 60) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (o >= this.transform.minPitch) return this.transform.maxPitch = o, this._update(), this.getPitch() > o && this.setPitch(o), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(o) {
          return this.transform.renderWorldCopies = o, this._update();
        }
        project(o) {
          return this.transform.locationPoint(c.N.convert(o), this.style && this.terrain);
        }
        unproject(o) {
          return this.transform.pointLocation(c.P.convert(o), this.terrain);
        }
        isMoving() {
          var o;
          return this._moving || ((o = this.handlers) === null || o === void 0 ? void 0 : o.isMoving());
        }
        isZooming() {
          var o;
          return this._zooming || ((o = this.handlers) === null || o === void 0 ? void 0 : o.isZooming());
        }
        isRotating() {
          var o;
          return this._rotating || ((o = this.handlers) === null || o === void 0 ? void 0 : o.isRotating());
        }
        _createDelegatedListener(o, t, r) {
          if (o === "mouseenter" || o === "mouseover") {
            let s = !1;
            return { layers: t, listener: r, delegates: { mousemove: (h) => {
              const g = t.filter((A) => this.getLayer(A)), _ = g.length !== 0 ? this.queryRenderedFeatures(h.point, { layers: g }) : [];
              _.length ? s || (s = !0, r.call(this, new Ii(o, this, h.originalEvent, { features: _ }))) : s = !1;
            }, mouseout: () => {
              s = !1;
            } } };
          }
          if (o === "mouseleave" || o === "mouseout") {
            let s = !1;
            return { layers: t, listener: r, delegates: { mousemove: (g) => {
              const _ = t.filter((A) => this.getLayer(A));
              (_.length !== 0 ? this.queryRenderedFeatures(g.point, { layers: _ }) : []).length ? s = !0 : s && (s = !1, r.call(this, new Ii(o, this, g.originalEvent)));
            }, mouseout: (g) => {
              s && (s = !1, r.call(this, new Ii(o, this, g.originalEvent)));
            } } };
          }
          {
            const s = (l) => {
              const h = t.filter((_) => this.getLayer(_)), g = h.length !== 0 ? this.queryRenderedFeatures(l.point, { layers: h }) : [];
              g.length && (l.features = g, r.call(this, l), delete l.features);
            };
            return { layers: t, listener: r, delegates: { [o]: s } };
          }
        }
        _saveDelegatedListener(o, t) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[o] = this._delegatedListeners[o] || [], this._delegatedListeners[o].push(t);
        }
        _removeDelegatedListener(o, t, r) {
          if (!this._delegatedListeners || !this._delegatedListeners[o]) return;
          const s = this._delegatedListeners[o];
          for (let l = 0; l < s.length; l++) {
            const h = s[l];
            if (h.listener === r && h.layers.length === t.length && h.layers.every((g) => t.includes(g))) {
              for (const g in h.delegates) this.off(g, h.delegates[g]);
              return void s.splice(l, 1);
            }
          }
        }
        on(o, t, r) {
          if (r === void 0) return super.on(o, t);
          const s = this._createDelegatedListener(o, typeof t == "string" ? [t] : t, r);
          this._saveDelegatedListener(o, s);
          for (const l in s.delegates) this.on(l, s.delegates[l]);
          return this;
        }
        once(o, t, r) {
          if (r === void 0) return super.once(o, t);
          const s = typeof t == "string" ? [t] : t, l = this._createDelegatedListener(o, s, r);
          for (const h in l.delegates) {
            const g = l.delegates[h];
            l.delegates[h] = (..._) => {
              this._removeDelegatedListener(o, s, r), g(..._);
            };
          }
          this._saveDelegatedListener(o, l);
          for (const h in l.delegates) this.once(h, l.delegates[h]);
          return this;
        }
        off(o, t, r) {
          return r === void 0 ? super.off(o, t) : (this._removeDelegatedListener(o, typeof t == "string" ? [t] : t, r), this);
        }
        queryRenderedFeatures(o, t) {
          if (!this.style) return [];
          let r;
          const s = o instanceof c.P || Array.isArray(o), l = s ? o : [[0, 0], [this.transform.width, this.transform.height]];
          if (t = t || (s ? {} : o) || {}, l instanceof c.P || typeof l[0] == "number") r = [c.P.convert(l)];
          else {
            const h = c.P.convert(l[0]), g = c.P.convert(l[1]);
            r = [h, new c.P(g.x, h.y), g, new c.P(h.x, g.y), h];
          }
          return this.style.queryRenderedFeatures(r, t, this.transform);
        }
        querySourceFeatures(o, t) {
          return this.style.querySourceFeatures(o, t);
        }
        setStyle(o, t) {
          return (t = c.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, t)).diff !== !1 && t.localIdeographFontFamily === this._localIdeographFontFamily && this.style && o ? (this._diffStyle(o, t), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._updateStyle(o, t));
        }
        setTransformRequest(o) {
          return this._requestManager.setTransformRequest(o), this;
        }
        _getUIString(o) {
          const t = this._locale[o];
          if (t == null) throw new Error(`Missing UI string '${o}'`);
          return t;
        }
        _updateStyle(o, t) {
          if (t.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(o, t));
          const r = this.style && t.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!o)), o ? (this.style = new Rr(this, t || {}), this.style.setEventedParent(this, { style: this.style }), typeof o == "string" ? this.style.loadURL(o, t, r) : this.style.loadJSON(o, t, r), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Rr(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(o, t) {
          if (typeof o == "string") {
            const r = this._requestManager.transformRequest(o, "Style");
            c.h(r, new AbortController()).then((s) => {
              this._updateDiff(s.data, t);
            }).catch((s) => {
              s && this.fire(new c.j(s));
            });
          } else typeof o == "object" && this._updateDiff(o, t);
        }
        _updateDiff(o, t) {
          try {
            this.style.setState(o, t) && this._update(!0);
          } catch (r) {
            c.w(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`), this._updateStyle(o, t);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : c.w("There is no style added to the map.");
        }
        addSource(o, t) {
          return this._lazyInitEmptyStyle(), this.style.addSource(o, t), this._update(!0);
        }
        isSourceLoaded(o) {
          const t = this.style && this.style.sourceCaches[o];
          if (t !== void 0) return t.loaded();
          this.fire(new c.j(new Error(`There is no source with ID '${o}'`)));
        }
        setTerrain(o) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), o) {
            const t = this.style.sourceCaches[o.source];
            if (!t) throw new Error(`cannot load terrain, because there exists no source with ID: ${o.source}`);
            this.terrain === null && t.reload();
            for (const r in this.style._layers) {
              const s = this.style._layers[r];
              s.type === "hillshade" && s.source === o.source && c.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new ml(this.painter, t, o), this.painter.renderToTexture = new ql(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (r) => {
              r.dataType === "style" ? this.terrain.sourceCache.freeRtt() : r.dataType === "source" && r.tile && (r.sourceId !== o.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(r.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new c.k("terrain", { terrain: o })), this;
        }
        getTerrain() {
          var o, t;
          return (t = (o = this.terrain) === null || o === void 0 ? void 0 : o.options) !== null && t !== void 0 ? t : null;
        }
        areTilesLoaded() {
          const o = this.style && this.style.sourceCaches;
          for (const t in o) {
            const r = o[t]._tiles;
            for (const s in r) {
              const l = r[s];
              if (l.state !== "loaded" && l.state !== "errored") return !1;
            }
          }
          return !0;
        }
        removeSource(o) {
          return this.style.removeSource(o), this._update(!0);
        }
        getSource(o) {
          return this.style.getSource(o);
        }
        addImage(o, t, r = {}) {
          const { pixelRatio: s = 1, sdf: l = !1, stretchX: h, stretchY: g, content: _, textFitWidth: A, textFitHeight: L } = r;
          if (this._lazyInitEmptyStyle(), !(t instanceof HTMLImageElement || c.b(t))) {
            if (t.width === void 0 || t.height === void 0) return this.fire(new c.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: E, height: M, data: R } = t, q = t;
              return this.style.addImage(o, { data: new c.R({ width: E, height: M }, new Uint8Array(R)), pixelRatio: s, stretchX: h, stretchY: g, content: _, textFitWidth: A, textFitHeight: L, sdf: l, version: 0, userImage: q }), q.onAdd && q.onAdd(this, o), this;
            }
          }
          {
            const { width: E, height: M, data: R } = O.getImageData(t);
            this.style.addImage(o, { data: new c.R({ width: E, height: M }, R), pixelRatio: s, stretchX: h, stretchY: g, content: _, textFitWidth: A, textFitHeight: L, sdf: l, version: 0 });
          }
        }
        updateImage(o, t) {
          const r = this.style.getImage(o);
          if (!r) return this.fire(new c.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const s = t instanceof HTMLImageElement || c.b(t) ? O.getImageData(t) : t, { width: l, height: h, data: g } = s;
          if (l === void 0 || h === void 0) return this.fire(new c.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (l !== r.data.width || h !== r.data.height) return this.fire(new c.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const _ = !(t instanceof HTMLImageElement || c.b(t));
          return r.data.replace(g, _), this.style.updateImage(o, r), this;
        }
        getImage(o) {
          return this.style.getImage(o);
        }
        hasImage(o) {
          return o ? !!this.style.getImage(o) : (this.fire(new c.j(new Error("Missing required image id"))), !1);
        }
        removeImage(o) {
          this.style.removeImage(o);
        }
        loadImage(o) {
          return zt.getImage(this._requestManager.transformRequest(o, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(o, t) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(o, t), this._update(!0);
        }
        moveLayer(o, t) {
          return this.style.moveLayer(o, t), this._update(!0);
        }
        removeLayer(o) {
          return this.style.removeLayer(o), this._update(!0);
        }
        getLayer(o) {
          return this.style.getLayer(o);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(o, t, r) {
          return this.style.setLayerZoomRange(o, t, r), this._update(!0);
        }
        setFilter(o, t, r = {}) {
          return this.style.setFilter(o, t, r), this._update(!0);
        }
        getFilter(o) {
          return this.style.getFilter(o);
        }
        setPaintProperty(o, t, r, s = {}) {
          return this.style.setPaintProperty(o, t, r, s), this._update(!0);
        }
        getPaintProperty(o, t) {
          return this.style.getPaintProperty(o, t);
        }
        setLayoutProperty(o, t, r, s = {}) {
          return this.style.setLayoutProperty(o, t, r, s), this._update(!0);
        }
        getLayoutProperty(o, t) {
          return this.style.getLayoutProperty(o, t);
        }
        setGlyphs(o, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(o, t), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(o, t, r = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(o, t, r, (s) => {
            s || this._update(!0);
          }), this;
        }
        removeSprite(o) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(o), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(o, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(o, t, (r) => {
            r || this._update(!0);
          }), this;
        }
        setLight(o, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(o, t), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(o) {
          return this._lazyInitEmptyStyle(), this.style.setSky(o), this._update(!0);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(o, t) {
          return this.style.setFeatureState(o, t), this._update();
        }
        removeFeatureState(o, t) {
          return this.style.removeFeatureState(o, t), this._update();
        }
        getFeatureState(o) {
          return this.style.getFeatureState(o);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let o = 0, t = 0;
          return this._container && (o = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [o, t];
        }
        _setupContainer() {
          const o = this._container;
          o.classList.add("maplibregl-map");
          const t = this._canvasContainer = j.create("div", "maplibregl-canvas-container", o);
          this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = j.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const r = this._containerDimensions(), s = this._getClampedPixelRatio(r[0], r[1]);
          this._resizeCanvas(r[0], r[1], s);
          const l = this._controlContainer = j.create("div", "maplibregl-control-container", o), h = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((g) => {
            h[g] = j.create("div", `maplibregl-ctrl-${g} `, l);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(o, t, r) {
          this._canvas.width = Math.floor(r * o), this._canvas.height = Math.floor(r * t), this._canvas.style.width = `${o}px`, this._canvas.style.height = `${t}px`;
        }
        _setupPainter() {
          const o = { alpha: !0, stencil: !0, depth: !0, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 };
          let t = null;
          this._canvas.addEventListener("webglcontextcreationerror", (s) => {
            t = { requestedAttributes: o }, s && (t.statusMessage = s.statusMessage, t.type = s.type);
          }, { once: !0 });
          const r = this._canvas.getContext("webgl2", o) || this._canvas.getContext("webgl", o);
          if (!r) {
            const s = "Failed to initialize WebGL";
            throw t ? (t.message = s, new Error(JSON.stringify(t))) : new Error(s);
          }
          this.painter = new oa(r, this.transform), F.testSupport(r);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(o) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || o, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(o) {
          return this._update(), this._renderTaskQueue.add(o);
        }
        _cancelRenderFrame(o) {
          this._renderTaskQueue.remove(o);
        }
        _render(o) {
          const t = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(o), this._removed) return;
          let r = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const l = this.transform.zoom, h = O.now();
            this.style.zoomHistory.update(l, h);
            const g = new c.z(l, { now: h, fadeDuration: t, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), _ = g.crossFadingFactor();
            _ === 1 && _ === this._crossFadingFactor || (r = !0, this._crossFadingFactor = _), this.style.update(g);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, t, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: t, showPadding: this.showPadding }), this.fire(new c.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, c.bf.mark(c.bg.load), this.fire(new c.k("load"))), this.style && (this.style.hasTransitions() || r) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const s = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return s || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new c.k("idle")), !this._loaded || this._fullyLoaded || s || (this._fullyLoaded = !0, c.bf.mark(c.bg.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var o;
          this._hash && this._hash.remove();
          for (const r of this._controls) r.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), zt.removeThrottleControl(this._imageQueueHandle), (o = this._resizeObserver) === null || o === void 0 || o.disconnect();
          const t = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t != null && t.loseContext && t.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), j.remove(this._canvasContainer), j.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), c.bf.clearMetrics(), this._removed = !0, this.fire(new c.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), O.frameAsync(this._frameRequest).then((o) => {
            c.bf.frame(o), this._frameRequest = null, this._render(o);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(o) {
          this._showTileBoundaries !== o && (this._showTileBoundaries = o, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(o) {
          this._showPadding !== o && (this._showPadding = o, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(o) {
          this._showCollisionBoxes !== o && (this._showCollisionBoxes = o, o ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(o) {
          this._showOverdrawInspector !== o && (this._showOverdrawInspector = o, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(o) {
          this._repaint !== o && (this._repaint = o, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(o) {
          this._vertices = o, this._update();
        }
        get version() {
          return Yo;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, v.MapMouseEvent = Ii, v.MapTouchEvent = Oi, v.MapWheelEvent = gr, v.Marker = _l, v.NavigationControl = class {
        constructor(o) {
          this._updateZoomButtons = () => {
            const t = this._map.getZoom(), r = t === this._map.getMaxZoom(), s = t === this._map.getMinZoom();
            this._zoomInButton.disabled = r, this._zoomOutButton.disabled = s, this._zoomInButton.setAttribute("aria-disabled", r.toString()), this._zoomOutButton.setAttribute("aria-disabled", s.toString());
          }, this._rotateCompassArrow = () => {
            const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = t;
          }, this._setButtonTitle = (t, r) => {
            const s = this._map._getUIString(`NavigationControl.${r}`);
            t.title = s, t.setAttribute("aria-label", s);
          }, this.options = c.e({}, Vl, o), this._container = j.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t) => this._map.zoomIn({}, { originalEvent: t })), j.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t) => this._map.zoomOut({}, { originalEvent: t })), j.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t });
          }), this._compassIcon = j.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(o) {
          return this._map = o, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new oc(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          j.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(o, t) {
          const r = j.create("button", o, this._container);
          return r.type = "button", r.addEventListener("click", t), r;
        }
      }, v.Popup = class extends c.E {
        constructor(o) {
          super(), this.remove = () => (this._content && j.remove(this._content), this._container && (j.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new c.k("close"))), this), this._onMouseUp = (t) => {
            this._update(t.point);
          }, this._onMouseMove = (t) => {
            this._update(t.point);
          }, this._onDrag = (t) => {
            this._update(t.point);
          }, this._update = (t) => {
            var r;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = j.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = j.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const _ of this.options.className.split(" ")) this._container.classList.add(_);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Xi(this._lngLat, this._flatPos, this._map.transform) : (r = this._lngLat) === null || r === void 0 ? void 0 : r.wrap(), this._trackPointer && !t) return;
            const s = this._flatPos = this._pos = this._trackPointer && t ? t : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && t ? t : this._map.transform.locationPoint(this._lngLat));
            let l = this.options.anchor;
            const h = p(this.options.offset);
            if (!l) {
              const _ = this._container.offsetWidth, A = this._container.offsetHeight;
              let L;
              L = s.y + h.bottom.y < A ? ["top"] : s.y > this._map.transform.height - A ? ["bottom"] : [], s.x < _ / 2 ? L.push("left") : s.x > this._map.transform.width - _ / 2 && L.push("right"), l = L.length === 0 ? "bottom" : L.join("-");
            }
            let g = s.add(h[l]);
            this.options.subpixelPositioning || (g = g.round()), j.setTransform(this._container, `${_o[l]} translate(${g.x}px,${g.y}px)`), yl(this._container, l, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = c.e(Object.create(Qe), o);
        }
        addTo(o) {
          return this._map && this.remove(), this._map = o, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new c.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(o) {
          return this._lngLat = c.N.convert(o), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(o) {
          return this.setDOMContent(document.createTextNode(o));
        }
        setHTML(o) {
          const t = document.createDocumentFragment(), r = document.createElement("body");
          let s;
          for (r.innerHTML = o; s = r.firstChild, s; ) t.appendChild(s);
          return this.setDOMContent(t);
        }
        getMaxWidth() {
          var o;
          return (o = this._container) === null || o === void 0 ? void 0 : o.style.maxWidth;
        }
        setMaxWidth(o) {
          return this.options.maxWidth = o, this._update(), this;
        }
        setDOMContent(o) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = j.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(o), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(o) {
          return this._container && this._container.classList.add(o), this;
        }
        removeClassName(o) {
          return this._container && this._container.classList.remove(o), this;
        }
        setOffset(o) {
          return this.options.offset = o, this._update(), this;
        }
        toggleClassName(o) {
          if (this._container) return this._container.classList.toggle(o);
        }
        setSubpixelPositioning(o) {
          this.options.subpixelPositioning = o;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = j.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const o = this._container.querySelector(Qo);
          o && o.focus();
        }
      }, v.RasterDEMTileSource = _e, v.RasterTileSource = se, v.ScaleControl = class {
        constructor(o) {
          this._onMove = () => {
            ua(this._map, this._container, this.options);
          }, this.setUnit = (t) => {
            this.options.unit = t, ua(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, hs), o);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(o) {
          return this._map = o, this._container = j.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", o.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          j.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, v.ScrollZoomHandler = kn, v.Style = Rr, v.TerrainControl = class {
        constructor(o) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = o;
        }
        onAdd(o) {
          return this._map = o, this._container = j.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = j.create("button", "maplibregl-ctrl-terrain", this._container), j.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          j.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, v.TwoFingersTouchPitchHandler = mo, v.TwoFingersTouchRotateHandler = Fl, v.TwoFingersTouchZoomHandler = Wo, v.TwoFingersTouchZoomRotateHandler = Ol, v.VectorTileSource = Ge, v.VideoSource = di, v.addSourceType = (o, t) => c._(void 0, void 0, void 0, function* () {
        if (Ei(o)) throw new Error(`A source type called "${o}" already exists.`);
        ((r, s) => {
          wi[r] = s;
        })(o, t);
      }), v.clearPrewarmedResources = function() {
        const o = Rt;
        o && (o.isPreloaded() && o.numActive() === 1 ? (o.release(xt), Rt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, v.getMaxParallelImageRequests = function() {
        return c.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, v.getRTLTextPluginStatus = function() {
        return Te().getRTLTextPluginStatus();
      }, v.getVersion = function() {
        return w;
      }, v.getWorkerCount = function() {
        return Tt.workerCount;
      }, v.getWorkerUrl = function() {
        return c.a.WORKER_URL;
      }, v.importScriptInWorkers = function(o) {
        return be().broadcast("IS", o);
      }, v.prewarm = function() {
        Gt().acquire(xt);
      }, v.setMaxParallelImageRequests = function(o) {
        c.a.MAX_PARALLEL_IMAGE_REQUESTS = o;
      }, v.setRTLTextPlugin = function(o, t) {
        return Te().setRTLTextPlugin(o, t);
      }, v.setWorkerCount = function(o) {
        Tt.workerCount = o;
      }, v.setWorkerUrl = function(o) {
        c.a.WORKER_URL = o;
      };
    });
    var P = y;
    return P;
  });
})(Kp);
var fg = Kp.exports, mg = Object.defineProperty, gg = (x, f, y) => f in x ? mg(x, f, { enumerable: !0, configurable: !0, writable: !0, value: y }) : x[f] = y, Wi = (x, f, y) => gg(x, typeof f != "symbol" ? f + "" : f, y);
class yg {
  constructor(f) {
    Wi(this, "map"), Wi(this, "width"), Wi(this, "height"), Wi(this, "svgCanvas"), Wi(this, "xLine"), Wi(this, "yLine"), Wi(this, "color", "#535353"), this.map = f, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var f, y;
    this.width = (f = this.map) == null ? void 0 : f.getCanvas().clientWidth, this.height = (y = this.map) == null ? void 0 : y.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const f = this.width / 2, y = this.height / 2;
      this.yLine.setAttribute("x1", `${f}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${f}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${y}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${y}px`);
    } else
      console.error("element value is null");
  }
  createCanvas(f) {
    if (this.width !== void 0 && this.height !== void 0) {
      const y = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      y.style.position = "relative", y.setAttribute("width", `${this.width}px`), y.setAttribute("height", `${this.height}px`);
      const b = this.width / 2, k = this.height / 2;
      this.yLine = y.appendChild(
        this.createLine(b, 0, b, this.height, this.color, "2px")
      ), this.xLine = y.appendChild(
        this.createLine(0, k, this.width, k, this.color, "2px")
      ), f == null || f.appendChild(y), this.svgCanvas = y;
    }
  }
  createLine(f, y, b, k, P, v) {
    const c = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return c.setAttribute("x1", f), c.setAttribute("y1", y), c.setAttribute("x2", b), c.setAttribute("y2", k), c.setAttribute("stroke-dasharray", "5,5"), c.setAttribute("stroke", P), c.setAttribute("stroke-width", v), c;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const Lp = {
  72: 72,
  96: 96,
  200: 200,
  300: 300,
  400: 400
}, hh = {
  JPEG: "jpg",
  PNG: "png",
  PDF: "pdf",
  SVG: "svg"
}, zh = {
  Landscape: "landscape",
  Portrait: "portrait"
}, tc = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, ic = {
  // don't use inch unit. because page size setting is using mm unit.
  in: "in",
  mm: "mm"
};
class _g {
  constructor(f) {
    Wi(this, "map"), Wi(this, "width"), Wi(this, "height"), Wi(this, "unit"), Wi(this, "svgCanvas"), Wi(this, "svgPath");
    var y, b, k;
    if (this.map = f, this.map === void 0)
      return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const P = (y = this.map) == null ? void 0 : y.getCanvas().clientWidth, v = (b = this.map) == null ? void 0 : b.getCanvas().clientHeight, c = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    c.style.position = "absolute", c.style.top = "0px", c.style.left = "0px", c.setAttribute("width", `${P}px`), c.setAttribute("height", `${v}px`);
    const z = document.createElementNS("http://www.w3.org/2000/svg", "path");
    z.setAttribute("style", "fill:#888888;stroke-width:0"), z.setAttribute("fill-opacity", "0.5"), c.append(z), (k = this.map) == null || k.getCanvasContainer().appendChild(c), this.svgCanvas = c, this.svgPath = z;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(f, y) {
    this.width = f, this.height = y, this.unit = ic.mm, this.generateCutOut();
  }
  generateCutOut() {
    var f, y;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0)
      return;
    const b = this.toPixels(this.width), k = this.toPixels(this.height), P = (f = this.map) == null ? void 0 : f.getCanvas().clientWidth, v = (y = this.map) == null ? void 0 : y.getCanvas().clientHeight, c = P / 2 - b / 2, z = c + b, U = v / 2 - k / 2, X = U + k;
    this.svgCanvas.setAttribute("width", `${P}px`), this.svgCanvas.setAttribute("height", `${v}px`), this.svgPath.setAttribute(
      "d",
      `M 0 0 L ${P} 0 L ${P} ${v} L 0 ${v} M ${c} ${U} L ${c} ${X} L ${z} ${X} L ${z} ${U}`
    );
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(f, y = 96) {
    return this.unit === ic.mm && (y /= 25.4), y * f;
  }
}
const Qp = {
  PageSize: "Page Size",
  PageOrientation: "Page Orientation",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generate",
  LanguageName: "English",
  LanguageCode: "en"
}, vg = {
  PageSize: "Taille de page",
  PageOrientation: "Orientation de la page",
  Format: "Format",
  DPI: "DPI",
  Generate: "Gnrer",
  LanguageName: "Franais",
  LanguageCode: "fr"
}, xg = {
  PageSize: "Sivukoko",
  PageOrientation: "Sivun suunta",
  Format: "Muoto",
  DPI: "DPI",
  Generate: "Generoi",
  LanguageName: "Suomalainen",
  LanguageCode: "fi"
}, bg = {
  PageSize: "Papierformat",
  PageOrientation: "Papierausrichtung",
  Format: "Dateiformat",
  DPI: "Druckauflsung",
  Generate: "Erstellen",
  LanguageName: "Deutsch",
  LanguageCode: "de"
}, wg = {
  PageSize: "Sidstorlek",
  PageOrientation: "Sidorientering",
  Format: "Format",
  DPI: "DPI",
  Generate: "Generera",
  LanguageName: "Svenska",
  LanguageCode: "sv"
}, Sg = {
  PageSize: "Tamao de pgina",
  PageOrientation: "Orientacin de pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Generar",
  LanguageName: "Espaola",
  LanguageCode: "es"
}, Ag = {
  PageSize: "Mida",
  PageOrientation: "Orientaci",
  Format: "Format",
  DPI: "DPI",
  Generate: "Genera",
  LanguageName: "Catalan",
  LanguageCode: "ca"
}, Pg = {
  PageSize: "Kch thc trang",
  PageOrientation: "Loi trang",
  Format: "nh dng",
  DPI: "Mt  im nh (DPI)",
  Generate: "To",
  LanguageName: "Ting Vit",
  LanguageCode: "vi"
}, Ig = {
  PageSize: " ",
  PageOrientation: " ",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "uk"
}, kg = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHans"
}, Tg = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "",
  Generate: "",
  LanguageName: "",
  LanguageCode: "zhHant"
}, Lg = {
  PageSize: "",
  PageOrientation: "",
  Format: "",
  DPI: "DPI",
  Generate: "",
  LanguageName: "",
  LanguageCode: "ja"
}, Cg = {
  PageSize: "Tamanho da pgina",
  PageOrientation: "Orientao da pgina",
  Format: "Formato",
  DPI: "DPI",
  Generate: "Gerar",
  LanguageName: "Portugus",
  LanguageCode: "pt"
}, Mg = [
  Qp,
  vg,
  xg,
  bg,
  wg,
  Sg,
  Ag,
  Pg,
  Ig,
  kg,
  Tg,
  Lg,
  Cg
], Eg = (x) => Mg.find((f) => f.LanguageCode === x) ?? Qp;
function nr(x) {
  "@babel/helpers - typeof";
  return nr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
    return typeof f;
  } : function(f) {
    return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
  }, nr(x);
}
var Kn = Uint8Array, Ys = Uint16Array, Ju = Int32Array, Gh = new Kn([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), $h = new Kn([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), qu = new Kn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), tf = function(x, f) {
  for (var y = new Ys(31), b = 0; b < 31; ++b)
    y[b] = f += 1 << x[b - 1];
  for (var k = new Ju(y[30]), b = 1; b < 30; ++b)
    for (var P = y[b]; P < y[b + 1]; ++P)
      k[P] = P - y[b] << 5 | b;
  return { b: y, r: k };
}, ef = tf(Gh, 2), rf = ef.b, Uu = ef.r;
rf[28] = 258, Uu[258] = 28;
var nf = tf($h, 0), zg = nf.b, Cp = nf.r, Vu = new Ys(32768);
for (var wr = 0; wr < 32768; ++wr) {
  var kl = (wr & 43690) >> 1 | (wr & 21845) << 1;
  kl = (kl & 52428) >> 2 | (kl & 13107) << 2, kl = (kl & 61680) >> 4 | (kl & 3855) << 4, Vu[wr] = ((kl & 65280) >> 8 | (kl & 255) << 8) >> 1;
}
var Eo = function(x, f, y) {
  for (var b = x.length, k = 0, P = new Ys(f); k < b; ++k)
    x[k] && ++P[x[k] - 1];
  var v = new Ys(f);
  for (k = 1; k < f; ++k)
    v[k] = v[k - 1] + P[k - 1] << 1;
  var c;
  if (y) {
    c = new Ys(1 << f);
    var z = 15 - f;
    for (k = 0; k < b; ++k)
      if (x[k])
        for (var U = k << 4 | x[k], X = f - x[k], O = v[x[k] - 1]++ << X, j = O | (1 << X) - 1; O <= j; ++O)
          c[Vu[O] >> z] = U;
  } else
    for (c = new Ys(b), k = 0; k < b; ++k)
      x[k] && (c[k] = Vu[v[x[k] - 1]++] >> 15 - x[k]);
  return c;
}, Cl = new Kn(288);
for (var wr = 0; wr < 144; ++wr)
  Cl[wr] = 8;
for (var wr = 144; wr < 256; ++wr)
  Cl[wr] = 9;
for (var wr = 256; wr < 280; ++wr)
  Cl[wr] = 7;
for (var wr = 280; wr < 288; ++wr)
  Cl[wr] = 8;
var uh = new Kn(32);
for (var wr = 0; wr < 32; ++wr)
  uh[wr] = 5;
var Ng = /* @__PURE__ */ Eo(Cl, 9, 0), Dg = /* @__PURE__ */ Eo(Cl, 9, 1), Fg = /* @__PURE__ */ Eo(uh, 5, 0), Bg = /* @__PURE__ */ Eo(uh, 5, 1), zu = function(x) {
  for (var f = x[0], y = 1; y < x.length; ++y)
    x[y] > f && (f = x[y]);
  return f;
}, Oa = function(x, f, y) {
  var b = f / 8 | 0;
  return (x[b] | x[b + 1] << 8) >> (f & 7) & y;
}, Nu = function(x, f) {
  var y = f / 8 | 0;
  return (x[y] | x[y + 1] << 8 | x[y + 2] << 16) >> (f & 7);
}, Qu = function(x) {
  return (x + 7) / 8 | 0;
}, sf = function(x, f, y) {
  return (y == null || y > x.length) && (y = x.length), new Kn(x.subarray(f, y));
}, Rg = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], qa = function(x, f, y) {
  var b = new Error(f || Rg[x]);
  if (b.code = x, Error.captureStackTrace && Error.captureStackTrace(b, qa), !y)
    throw b;
  return b;
}, Og = function(x, f, y, b) {
  var k = x.length, P = 0;
  if (!k || f.f && !f.l)
    return y || new Kn(0);
  var v = !y, c = v || f.i != 2, z = f.i;
  v && (y = new Kn(k * 3));
  var U = function(be) {
    var Ie = y.length;
    if (be > Ie) {
      var Pe = new Kn(Math.max(Ie * 2, be));
      Pe.set(y), y = Pe;
    }
  }, X = f.f || 0, O = f.p || 0, j = f.b || 0, F = f.l, mt = f.d, ot = f.m, yt = f.n, st = k * 8;
  do {
    if (!F) {
      X = Oa(x, O, 1);
      var gt = Oa(x, O + 1, 3);
      if (O += 3, gt)
        if (gt == 1)
          F = Dg, mt = Bg, ot = 9, yt = 5;
        else if (gt == 2) {
          var zt = Oa(x, O, 31) + 257, Jt = Oa(x, O + 10, 15) + 4, Kt = zt + Oa(x, O + 5, 31) + 1;
          O += 14;
          for (var pe = new Kn(Kt), Ot = new Kn(19), kt = 0; kt < Jt; ++kt)
            Ot[qu[kt]] = Oa(x, O + kt * 3, 7);
          O += Jt * 3;
          for (var $t = zu(Ot), ae = (1 << $t) - 1, at = Eo(Ot, $t, 1), kt = 0; kt < Kt; ) {
            var lt = at[Oa(x, O, ae)];
            O += lt & 15;
            var It = lt >> 4;
            if (It < 16)
              pe[kt++] = It;
            else {
              var St = 0, Wt = 0;
              for (It == 16 ? (Wt = 3 + Oa(x, O, 3), O += 2, St = pe[kt - 1]) : It == 17 ? (Wt = 3 + Oa(x, O, 7), O += 3) : It == 18 && (Wt = 11 + Oa(x, O, 127), O += 7); Wt--; )
                pe[kt++] = St;
            }
          }
          var Xt = pe.subarray(0, zt), Ht = pe.subarray(zt);
          ot = zu(Xt), yt = zu(Ht), F = Eo(Xt, ot, 1), mt = Eo(Ht, yt, 1);
        } else
          qa(1);
      else {
        var It = Qu(O) + 4, jt = x[It - 4] | x[It - 3] << 8, ee = It + jt;
        if (ee > k) {
          z && qa(0);
          break;
        }
        c && U(j + jt), y.set(x.subarray(It, ee), j), f.b = j += jt, f.p = O = ee * 8, f.f = X;
        continue;
      }
      if (O > st) {
        z && qa(0);
        break;
      }
    }
    c && U(j + 131072);
    for (var ie = (1 << ot) - 1, Se = (1 << yt) - 1, K = O; ; K = O) {
      var St = F[Nu(x, O) & ie], pt = St >> 4;
      if (O += St & 15, O > st) {
        z && qa(0);
        break;
      }
      if (St || qa(2), pt < 256)
        y[j++] = pt;
      else if (pt == 256) {
        K = O, F = null;
        break;
      } else {
        var xt = pt - 254;
        if (pt > 264) {
          var kt = pt - 257, Tt = Gh[kt];
          xt = Oa(x, O, (1 << Tt) - 1) + rf[kt], O += Tt;
        }
        var Et = mt[Nu(x, O) & Se], Rt = Et >> 4;
        Et || qa(3), O += Et & 15;
        var Ht = zg[Rt];
        if (Rt > 3) {
          var Tt = $h[Rt];
          Ht += Nu(x, O) & (1 << Tt) - 1, O += Tt;
        }
        if (O > st) {
          z && qa(0);
          break;
        }
        c && U(j + 131072);
        var qt = j + xt;
        if (j < Ht) {
          var Gt = P - Ht, we = Math.min(Ht, qt);
          for (Gt + j < 0 && qa(3); j < we; ++j)
            y[j] = b[Gt + j];
        }
        for (; j < qt; ++j)
          y[j] = y[j - Ht];
      }
    }
    f.l = F, f.p = K, f.b = j, f.f = X, F && (X = 1, f.m = ot, f.d = mt, f.n = yt);
  } while (!X);
  return j != y.length && v ? sf(y, 0, j) : y.subarray(0, j);
}, ll = function(x, f, y) {
  y <<= f & 7;
  var b = f / 8 | 0;
  x[b] |= y, x[b + 1] |= y >> 8;
}, oh = function(x, f, y) {
  y <<= f & 7;
  var b = f / 8 | 0;
  x[b] |= y, x[b + 1] |= y >> 8, x[b + 2] |= y >> 16;
}, Du = function(x, f) {
  for (var y = [], b = 0; b < x.length; ++b)
    x[b] && y.push({ s: b, f: x[b] });
  var k = y.length, P = y.slice();
  if (!k)
    return { t: of, l: 0 };
  if (k == 1) {
    var v = new Kn(y[0].s + 1);
    return v[y[0].s] = 1, { t: v, l: 1 };
  }
  y.sort(function(Kt, pe) {
    return Kt.f - pe.f;
  }), y.push({ s: -1, f: 25001 });
  var c = y[0], z = y[1], U = 0, X = 1, O = 2;
  for (y[0] = { s: -1, f: c.f + z.f, l: c, r: z }; X != k - 1; )
    c = y[y[U].f < y[O].f ? U++ : O++], z = y[U != X && y[U].f < y[O].f ? U++ : O++], y[X++] = { s: -1, f: c.f + z.f, l: c, r: z };
  for (var j = P[0].s, b = 1; b < k; ++b)
    P[b].s > j && (j = P[b].s);
  var F = new Ys(j + 1), mt = Gu(y[X - 1], F, 0);
  if (mt > f) {
    var b = 0, ot = 0, yt = mt - f, st = 1 << yt;
    for (P.sort(function(pe, Ot) {
      return F[Ot.s] - F[pe.s] || pe.f - Ot.f;
    }); b < k; ++b) {
      var gt = P[b].s;
      if (F[gt] > f)
        ot += st - (1 << mt - F[gt]), F[gt] = f;
      else
        break;
    }
    for (ot >>= yt; ot > 0; ) {
      var zt = P[b].s;
      F[zt] < f ? ot -= 1 << f - F[zt]++ - 1 : ++b;
    }
    for (; b >= 0 && ot; --b) {
      var Jt = P[b].s;
      F[Jt] == f && (--F[Jt], ++ot);
    }
    mt = f;
  }
  return { t: new Kn(F), l: mt };
}, Gu = function(x, f, y) {
  return x.s == -1 ? Math.max(Gu(x.l, f, y + 1), Gu(x.r, f, y + 1)) : f[x.s] = y;
}, Mp = function(x) {
  for (var f = x.length; f && !x[--f]; )
    ;
  for (var y = new Ys(++f), b = 0, k = x[0], P = 1, v = function(z) {
    y[b++] = z;
  }, c = 1; c <= f; ++c)
    if (x[c] == k && c != f)
      ++P;
    else {
      if (!k && P > 2) {
        for (; P > 138; P -= 138)
          v(32754);
        P > 2 && (v(P > 10 ? P - 11 << 5 | 28690 : P - 3 << 5 | 12305), P = 0);
      } else if (P > 3) {
        for (v(k), --P; P > 6; P -= 6)
          v(8304);
        P > 2 && (v(P - 3 << 5 | 8208), P = 0);
      }
      for (; P--; )
        v(k);
      P = 1, k = x[c];
    }
  return { c: y.subarray(0, b), n: f };
}, lh = function(x, f) {
  for (var y = 0, b = 0; b < f.length; ++b)
    y += x[b] * f[b];
  return y;
}, af = function(x, f, y) {
  var b = y.length, k = Qu(f + 2);
  x[k] = b & 255, x[k + 1] = b >> 8, x[k + 2] = x[k] ^ 255, x[k + 3] = x[k + 1] ^ 255;
  for (var P = 0; P < b; ++P)
    x[k + P + 4] = y[P];
  return (k + 4 + b) * 8;
}, Ep = function(x, f, y, b, k, P, v, c, z, U, X) {
  ll(f, X++, y), ++k[256];
  for (var O = Du(k, 15), j = O.t, F = O.l, mt = Du(P, 15), ot = mt.t, yt = mt.l, st = Mp(j), gt = st.c, zt = st.n, Jt = Mp(ot), Kt = Jt.c, pe = Jt.n, Ot = new Ys(19), kt = 0; kt < gt.length; ++kt)
    ++Ot[gt[kt] & 31];
  for (var kt = 0; kt < Kt.length; ++kt)
    ++Ot[Kt[kt] & 31];
  for (var $t = Du(Ot, 7), ae = $t.t, at = $t.l, lt = 19; lt > 4 && !ae[qu[lt - 1]]; --lt)
    ;
  var It = U + 5 << 3, St = lh(k, Cl) + lh(P, uh) + v, Wt = lh(k, j) + lh(P, ot) + v + 14 + 3 * lt + lh(Ot, ae) + 2 * Ot[16] + 3 * Ot[17] + 7 * Ot[18];
  if (z >= 0 && It <= St && It <= Wt)
    return af(f, X, x.subarray(z, z + U));
  var Xt, Ht, jt, ee;
  if (ll(f, X, 1 + (Wt < St)), X += 2, Wt < St) {
    Xt = Eo(j, F, 0), Ht = j, jt = Eo(ot, yt, 0), ee = ot;
    var ie = Eo(ae, at, 0);
    ll(f, X, zt - 257), ll(f, X + 5, pe - 1), ll(f, X + 10, lt - 4), X += 14;
    for (var kt = 0; kt < lt; ++kt)
      ll(f, X + 3 * kt, ae[qu[kt]]);
    X += 3 * lt;
    for (var Se = [gt, Kt], K = 0; K < 2; ++K)
      for (var pt = Se[K], kt = 0; kt < pt.length; ++kt) {
        var xt = pt[kt] & 31;
        ll(f, X, ie[xt]), X += ae[xt], xt > 15 && (ll(f, X, pt[kt] >> 5 & 127), X += pt[kt] >> 12);
      }
  } else
    Xt = Ng, Ht = Cl, jt = Fg, ee = uh;
  for (var kt = 0; kt < c; ++kt) {
    var Tt = b[kt];
    if (Tt > 255) {
      var xt = Tt >> 18 & 31;
      oh(f, X, Xt[xt + 257]), X += Ht[xt + 257], xt > 7 && (ll(f, X, Tt >> 23 & 31), X += Gh[xt]);
      var Et = Tt & 31;
      oh(f, X, jt[Et]), X += ee[Et], Et > 3 && (oh(f, X, Tt >> 5 & 8191), X += $h[Et]);
    } else
      oh(f, X, Xt[Tt]), X += Ht[Tt];
  }
  return oh(f, X, Xt[256]), X + Ht[256];
}, jg = /* @__PURE__ */ new Ju([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), of = /* @__PURE__ */ new Kn(0), qg = function(x, f, y, b, k, P) {
  var v = P.z || x.length, c = new Kn(b + v + 5 * (1 + Math.ceil(v / 7e3)) + k), z = c.subarray(b, c.length - k), U = P.l, X = (P.r || 0) & 7;
  if (f) {
    X && (z[0] = P.r >> 3);
    for (var O = jg[f - 1], j = O >> 13, F = O & 8191, mt = (1 << y) - 1, ot = P.p || new Ys(32768), yt = P.h || new Ys(mt + 1), st = Math.ceil(y / 3), gt = 2 * st, zt = function(ti) {
      return (x[ti] ^ x[ti + 1] << st ^ x[ti + 2] << gt) & mt;
    }, Jt = new Ju(25e3), Kt = new Ys(288), pe = new Ys(32), Ot = 0, kt = 0, $t = P.i || 0, ae = 0, at = P.w || 0, lt = 0; $t + 2 < v; ++$t) {
      var It = zt($t), St = $t & 32767, Wt = yt[It];
      if (ot[St] = Wt, yt[It] = St, at <= $t) {
        var Xt = v - $t;
        if ((Ot > 7e3 || ae > 24576) && (Xt > 423 || !U)) {
          X = Ep(x, z, 0, Jt, Kt, pe, kt, ae, lt, $t - lt, X), ae = Ot = kt = 0, lt = $t;
          for (var Ht = 0; Ht < 286; ++Ht)
            Kt[Ht] = 0;
          for (var Ht = 0; Ht < 30; ++Ht)
            pe[Ht] = 0;
        }
        var jt = 2, ee = 0, ie = F, Se = St - Wt & 32767;
        if (Xt > 2 && It == zt($t - Se))
          for (var K = Math.min(j, Xt) - 1, pt = Math.min(32767, $t), xt = Math.min(258, Xt); Se <= pt && --ie && St != Wt; ) {
            if (x[$t + jt] == x[$t + jt - Se]) {
              for (var Tt = 0; Tt < xt && x[$t + Tt] == x[$t + Tt - Se]; ++Tt)
                ;
              if (Tt > jt) {
                if (jt = Tt, ee = Se, Tt > K)
                  break;
                for (var Et = Math.min(Se, Tt - 2), Rt = 0, Ht = 0; Ht < Et; ++Ht) {
                  var qt = $t - Se + Ht & 32767, Gt = ot[qt], we = qt - Gt & 32767;
                  we > Rt && (Rt = we, Wt = qt);
                }
              }
            }
            St = Wt, Wt = ot[St], Se += St - Wt & 32767;
          }
        if (ee) {
          Jt[ae++] = 268435456 | Uu[jt] << 18 | Cp[ee];
          var be = Uu[jt] & 31, Ie = Cp[ee] & 31;
          kt += Gh[be] + $h[Ie], ++Kt[257 + be], ++pe[Ie], at = $t + jt, ++Ot;
        } else
          Jt[ae++] = x[$t], ++Kt[x[$t]];
      }
    }
    for ($t = Math.max($t, at); $t < v; ++$t)
      Jt[ae++] = x[$t], ++Kt[x[$t]];
    X = Ep(x, z, U, Jt, Kt, pe, kt, ae, lt, $t - lt, X), U || (P.r = X & 7 | z[X / 8 | 0] << 3, X -= 7, P.h = yt, P.p = ot, P.i = $t, P.w = at);
  } else {
    for (var $t = P.w || 0; $t < v + U; $t += 65535) {
      var Pe = $t + 65535;
      Pe >= v && (z[X / 8 | 0] = U, Pe = v), X = af(z, X + 1, x.subarray($t, Pe));
    }
    P.i = v;
  }
  return sf(c, 0, b + Qu(X) + k);
}, lf = function() {
  var x = 1, f = 0;
  return {
    p: function(y) {
      for (var b = x, k = f, P = y.length | 0, v = 0; v != P; ) {
        for (var c = Math.min(v + 2655, P); v < c; ++v)
          k += b += y[v];
        b = (b & 65535) + 15 * (b >> 16), k = (k & 65535) + 15 * (k >> 16);
      }
      x = b, f = k;
    },
    d: function() {
      return x %= 65521, f %= 65521, (x & 255) << 24 | (x & 65280) << 8 | (f & 255) << 8 | f >> 8;
    }
  };
}, Ug = function(x, f, y, b, k) {
  if (!k && (k = { l: 1 }, f.dictionary)) {
    var P = f.dictionary.subarray(-32768), v = new Kn(P.length + x.length);
    v.set(P), v.set(x, P.length), x = v, k.w = P.length;
  }
  return qg(x, f.level == null ? 6 : f.level, f.mem == null ? k.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(x.length))) * 1.5) : 20 : 12 + f.mem, y, b, k);
}, cf = function(x, f, y) {
  for (; y; ++f)
    x[f] = y, y >>>= 8;
}, Vg = function(x, f) {
  var y = f.level, b = y == 0 ? 0 : y < 6 ? 1 : y == 9 ? 3 : 2;
  if (x[0] = 120, x[1] = b << 6 | (f.dictionary && 32), x[1] |= 31 - (x[0] << 8 | x[1]) % 31, f.dictionary) {
    var k = lf();
    k.p(f.dictionary), cf(x, 2, k.d());
  }
}, Gg = function(x, f) {
  return ((x[0] & 15) != 8 || x[0] >> 4 > 7 || (x[0] << 8 | x[1]) % 31) && qa(6, "invalid zlib data"), (x[1] >> 5 & 1) == +!f && qa(6, "invalid zlib data: " + (x[1] & 32 ? "need" : "unexpected") + " dictionary"), (x[1] >> 3 & 4) + 2;
};
function $u(x, f) {
  f || (f = {});
  var y = lf();
  y.p(x);
  var b = Ug(x, f, f.dictionary ? 6 : 2, 4);
  return Vg(b, f), cf(b, b.length - 4, y.d()), b;
}
function $g(x, f) {
  return Og(x.subarray(Gg(x, f), -4), { i: 2 }, f, f);
}
var Zg = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Wg = 0;
try {
  Zg.decode(of, { stream: !0 }), Wg = 1;
} catch {
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2021 yWorks GmbH, http://www.yworks.com
 *               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var vi = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function Fu() {
  vi.console && typeof vi.console.log == "function" && vi.console.log.apply(vi.console, arguments);
}
var dr = { log: Fu, warn: function(x) {
  vi.console && (typeof vi.console.warn == "function" ? vi.console.warn.apply(vi.console, arguments) : Fu.call(null, arguments));
}, error: function(x) {
  vi.console && (typeof vi.console.error == "function" ? vi.console.error.apply(vi.console, arguments) : Fu(x));
} };
function Bu(x, f, y) {
  var b = new XMLHttpRequest();
  b.open("GET", x), b.responseType = "blob", b.onload = function() {
    Jl(b.response, f, y);
  }, b.onerror = function() {
    dr.error("could not download file");
  }, b.send();
}
function zp(x) {
  var f = new XMLHttpRequest();
  f.open("HEAD", x, !1);
  try {
    f.send();
  } catch {
  }
  return f.status >= 200 && f.status <= 299;
}
function Nh(x) {
  try {
    x.dispatchEvent(new MouseEvent("click"));
  } catch {
    var f = document.createEvent("MouseEvents");
    f.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), x.dispatchEvent(f);
  }
}
var ch, Zu, Jl = vi.saveAs || ((typeof window > "u" ? "undefined" : nr(window)) !== "object" || window !== vi ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(x, f, y) {
  var b = vi.URL || vi.webkitURL, k = document.createElement("a");
  f = f || x.name || "download", k.download = f, k.rel = "noopener", typeof x == "string" ? (k.href = x, k.origin !== location.origin ? zp(k.href) ? Bu(x, f, y) : Nh(k, k.target = "_blank") : Nh(k)) : (k.href = b.createObjectURL(x), setTimeout(function() {
    b.revokeObjectURL(k.href);
  }, 4e4), setTimeout(function() {
    Nh(k);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(x, f, y) {
  if (f = f || x.name || "download", typeof x == "string") if (zp(x)) Bu(x, f, y);
  else {
    var b = document.createElement("a");
    b.href = x, b.target = "_blank", setTimeout(function() {
      Nh(b);
    });
  }
  else navigator.msSaveOrOpenBlob(function(k, P) {
    return P === void 0 ? P = { autoBom: !1 } : nr(P) !== "object" && (dr.warn("Deprecated: Expected third argument to be a object"), P = { autoBom: !P }), P.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(k.type) ? new Blob(["\uFEFF", k], { type: k.type }) : k;
  }(x, y), f);
} : function(x, f, y, b) {
  if ((b = b || open("", "_blank")) && (b.document.title = b.document.body.innerText = "downloading..."), typeof x == "string") return Bu(x, f, y);
  var k = x.type === "application/octet-stream", P = /constructor/i.test(vi.HTMLElement) || vi.safari, v = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((v || k && P) && (typeof FileReader > "u" ? "undefined" : nr(FileReader)) === "object") {
    var c = new FileReader();
    c.onloadend = function() {
      var X = c.result;
      X = v ? X : X.replace(/^data:[^;]*;/, "data:attachment/file;"), b ? b.location.href = X : location = X, b = null;
    }, c.readAsDataURL(x);
  } else {
    var z = vi.URL || vi.webkitURL, U = z.createObjectURL(x);
    b ? b.location = U : location.href = U, b = null, setTimeout(function() {
      z.revokeObjectURL(U);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function hf(x) {
  var f;
  x = x || "", this.ok = !1, x.charAt(0) == "#" && (x = x.substr(1, 6)), x = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[x = (x = x.replace(/ /g, "")).toLowerCase()] || x;
  for (var y = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(c) {
    return [parseInt(c[1]), parseInt(c[2]), parseInt(c[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(c) {
    return [parseInt(c[1], 16), parseInt(c[2], 16), parseInt(c[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(c) {
    return [parseInt(c[1] + c[1], 16), parseInt(c[2] + c[2], 16), parseInt(c[3] + c[3], 16)];
  } }], b = 0; b < y.length; b++) {
    var k = y[b].re, P = y[b].process, v = k.exec(x);
    v && (f = P(v), this.r = f[0], this.g = f[1], this.b = f[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var c = this.r.toString(16), z = this.g.toString(16), U = this.b.toString(16);
    return c.length == 1 && (c = "0" + c), z.length == 1 && (z = "0" + z), U.length == 1 && (U = "0" + U), "#" + c + z + U;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function Ru(x, f) {
  var y = x[0], b = x[1], k = x[2], P = x[3];
  y = Wn(y, b, k, P, f[0], 7, -680876936), P = Wn(P, y, b, k, f[1], 12, -389564586), k = Wn(k, P, y, b, f[2], 17, 606105819), b = Wn(b, k, P, y, f[3], 22, -1044525330), y = Wn(y, b, k, P, f[4], 7, -176418897), P = Wn(P, y, b, k, f[5], 12, 1200080426), k = Wn(k, P, y, b, f[6], 17, -1473231341), b = Wn(b, k, P, y, f[7], 22, -45705983), y = Wn(y, b, k, P, f[8], 7, 1770035416), P = Wn(P, y, b, k, f[9], 12, -1958414417), k = Wn(k, P, y, b, f[10], 17, -42063), b = Wn(b, k, P, y, f[11], 22, -1990404162), y = Wn(y, b, k, P, f[12], 7, 1804603682), P = Wn(P, y, b, k, f[13], 12, -40341101), k = Wn(k, P, y, b, f[14], 17, -1502002290), y = Xn(y, b = Wn(b, k, P, y, f[15], 22, 1236535329), k, P, f[1], 5, -165796510), P = Xn(P, y, b, k, f[6], 9, -1069501632), k = Xn(k, P, y, b, f[11], 14, 643717713), b = Xn(b, k, P, y, f[0], 20, -373897302), y = Xn(y, b, k, P, f[5], 5, -701558691), P = Xn(P, y, b, k, f[10], 9, 38016083), k = Xn(k, P, y, b, f[15], 14, -660478335), b = Xn(b, k, P, y, f[4], 20, -405537848), y = Xn(y, b, k, P, f[9], 5, 568446438), P = Xn(P, y, b, k, f[14], 9, -1019803690), k = Xn(k, P, y, b, f[3], 14, -187363961), b = Xn(b, k, P, y, f[8], 20, 1163531501), y = Xn(y, b, k, P, f[13], 5, -1444681467), P = Xn(P, y, b, k, f[2], 9, -51403784), k = Xn(k, P, y, b, f[7], 14, 1735328473), y = Hn(y, b = Xn(b, k, P, y, f[12], 20, -1926607734), k, P, f[5], 4, -378558), P = Hn(P, y, b, k, f[8], 11, -2022574463), k = Hn(k, P, y, b, f[11], 16, 1839030562), b = Hn(b, k, P, y, f[14], 23, -35309556), y = Hn(y, b, k, P, f[1], 4, -1530992060), P = Hn(P, y, b, k, f[4], 11, 1272893353), k = Hn(k, P, y, b, f[7], 16, -155497632), b = Hn(b, k, P, y, f[10], 23, -1094730640), y = Hn(y, b, k, P, f[13], 4, 681279174), P = Hn(P, y, b, k, f[0], 11, -358537222), k = Hn(k, P, y, b, f[3], 16, -722521979), b = Hn(b, k, P, y, f[6], 23, 76029189), y = Hn(y, b, k, P, f[9], 4, -640364487), P = Hn(P, y, b, k, f[12], 11, -421815835), k = Hn(k, P, y, b, f[15], 16, 530742520), y = Yn(y, b = Hn(b, k, P, y, f[2], 23, -995338651), k, P, f[0], 6, -198630844), P = Yn(P, y, b, k, f[7], 10, 1126891415), k = Yn(k, P, y, b, f[14], 15, -1416354905), b = Yn(b, k, P, y, f[5], 21, -57434055), y = Yn(y, b, k, P, f[12], 6, 1700485571), P = Yn(P, y, b, k, f[3], 10, -1894986606), k = Yn(k, P, y, b, f[10], 15, -1051523), b = Yn(b, k, P, y, f[1], 21, -2054922799), y = Yn(y, b, k, P, f[8], 6, 1873313359), P = Yn(P, y, b, k, f[15], 10, -30611744), k = Yn(k, P, y, b, f[6], 15, -1560198380), b = Yn(b, k, P, y, f[13], 21, 1309151649), y = Yn(y, b, k, P, f[4], 6, -145523070), P = Yn(P, y, b, k, f[11], 10, -1120210379), k = Yn(k, P, y, b, f[2], 15, 718787259), b = Yn(b, k, P, y, f[9], 21, -343485551), x[0] = Ll(y, x[0]), x[1] = Ll(b, x[1]), x[2] = Ll(k, x[2]), x[3] = Ll(P, x[3]);
}
function Zh(x, f, y, b, k, P) {
  return f = Ll(Ll(f, x), Ll(b, P)), Ll(f << k | f >>> 32 - k, y);
}
function Wn(x, f, y, b, k, P, v) {
  return Zh(f & y | ~f & b, x, f, k, P, v);
}
function Xn(x, f, y, b, k, P, v) {
  return Zh(f & b | y & ~b, x, f, k, P, v);
}
function Hn(x, f, y, b, k, P, v) {
  return Zh(f ^ y ^ b, x, f, k, P, v);
}
function Yn(x, f, y, b, k, P, v) {
  return Zh(y ^ (f | ~b), x, f, k, P, v);
}
function uf(x) {
  var f, y = x.length, b = [1732584193, -271733879, -1732584194, 271733878];
  for (f = 64; f <= x.length; f += 64) Ru(b, Xg(x.substring(f - 64, f)));
  x = x.substring(f - 64);
  var k = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (f = 0; f < x.length; f++) k[f >> 2] |= x.charCodeAt(f) << (f % 4 << 3);
  if (k[f >> 2] |= 128 << (f % 4 << 3), f > 55) for (Ru(b, k), f = 0; f < 16; f++) k[f] = 0;
  return k[14] = 8 * y, Ru(b, k), b;
}
function Xg(x) {
  var f, y = [];
  for (f = 0; f < 64; f += 4) y[f >> 2] = x.charCodeAt(f) + (x.charCodeAt(f + 1) << 8) + (x.charCodeAt(f + 2) << 16) + (x.charCodeAt(f + 3) << 24);
  return y;
}
ch = vi.atob.bind(vi), Zu = vi.btoa.bind(vi);
var Np = "0123456789abcdef".split("");
function Hg(x) {
  for (var f = "", y = 0; y < 4; y++) f += Np[x >> 8 * y + 4 & 15] + Np[x >> 8 * y & 15];
  return f;
}
function Yg(x) {
  return String.fromCharCode((255 & x) >> 0, (65280 & x) >> 8, (16711680 & x) >> 16, (4278190080 & x) >> 24);
}
function Wu(x) {
  return uf(x).map(Yg).join("");
}
var Kg = function(x) {
  for (var f = 0; f < x.length; f++) x[f] = Hg(x[f]);
  return x.join("");
}(uf("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Ll(x, f) {
  if (Kg) {
    var y = (65535 & x) + (65535 & f);
    return (x >> 16) + (f >> 16) + (y >> 16) << 16 | 65535 & y;
  }
  return x + f & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function Xu(x, f) {
  var y, b, k, P;
  if (x !== y) {
    for (var v = (k = x, P = 1 + (256 / x.length >> 0), new Array(P + 1).join(k)), c = [], z = 0; z < 256; z++) c[z] = z;
    var U = 0;
    for (z = 0; z < 256; z++) {
      var X = c[z];
      U = (U + X + v.charCodeAt(z)) % 256, c[z] = c[U], c[U] = X;
    }
    y = x, b = c;
  } else c = b;
  var O = f.length, j = 0, F = 0, mt = "";
  for (z = 0; z < O; z++) F = (F + (X = c[j = (j + 1) % 256])) % 256, c[j] = c[F], c[F] = X, v = c[(c[j] + c[F]) % 256], mt += String.fromCharCode(f.charCodeAt(z) ^ v);
  return mt;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var Dp = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function Tc(x, f, y, b) {
  this.v = 1, this.r = 2;
  var k = 192;
  x.forEach(function(c) {
    if (Dp.perm !== void 0) throw new Error("Invalid permission: " + c);
    k += Dp[c];
  }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
  var P = (f + this.padding).substr(0, 32), v = (y + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(P, v), this.P = -(1 + (255 ^ k)), this.encryptionKey = Wu(P + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(b)).substr(0, 5), this.U = Xu(this.encryptionKey, this.padding);
}
function Lc(x) {
  if (/[^\u0000-\u00ff]/.test(x)) throw new Error("Invalid PDF Name Object: " + x + ", Only accept ASCII characters.");
  for (var f = "", y = x.length, b = 0; b < y; b++) {
    var k = x.charCodeAt(b);
    k < 33 || k === 35 || k === 37 || k === 40 || k === 41 || k === 47 || k === 60 || k === 62 || k === 91 || k === 93 || k === 123 || k === 125 || k > 126 ? f += "#" + ("0" + k.toString(16)).slice(-2) : f += x[b];
  }
  return f;
}
function Fp(x) {
  if (nr(x) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var f = {};
  this.subscribe = function(y, b, k) {
    if (k = k || !1, typeof y != "string" || typeof b != "function" || typeof k != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    f.hasOwnProperty(y) || (f[y] = {});
    var P = Math.random().toString(35);
    return f[y][P] = [b, !!k], P;
  }, this.unsubscribe = function(y) {
    for (var b in f) if (f[b][y]) return delete f[b][y], Object.keys(f[b]).length === 0 && delete f[b], !0;
    return !1;
  }, this.publish = function(y) {
    if (f.hasOwnProperty(y)) {
      var b = Array.prototype.slice.call(arguments, 1), k = [];
      for (var P in f[y]) {
        var v = f[y][P];
        try {
          v[0].apply(x, b);
        } catch (c) {
          vi.console && dr.error("jsPDF PubSub Error", c.message, c);
        }
        v[1] && k.push(P);
      }
      k.length && k.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return f;
  };
}
function Uh(x) {
  if (!(this instanceof Uh)) return new Uh(x);
  var f = "opacity,stroke-opacity".split(",");
  for (var y in x) x.hasOwnProperty(y) && f.indexOf(y) >= 0 && (this[y] = x[y]);
  this.id = "", this.objectNumber = -1;
}
function df(x, f) {
  this.gState = x, this.matrix = f, this.id = "", this.objectNumber = -1;
}
function Ql(x, f, y, b, k) {
  if (!(this instanceof Ql)) return new Ql(x, f, y, b, k);
  this.type = x === "axial" ? 2 : 3, this.coords = f, this.colors = y, df.call(this, b, k);
}
function Cc(x, f, y, b, k) {
  if (!(this instanceof Cc)) return new Cc(x, f, y, b, k);
  this.boundingBox = x, this.xStep = f, this.yStep = y, this.stream = "", this.cloneIndex = 0, df.call(this, b, k);
}
function _i(x) {
  var f, y = typeof arguments[0] == "string" ? arguments[0] : "p", b = arguments[1], k = arguments[2], P = arguments[3], v = [], c = 1, z = 16, U = "S", X = null;
  nr(x = x || {}) === "object" && (y = x.orientation, b = x.unit || b, k = x.format || k, P = x.compress || x.compressPdf || P, (X = x.encryption || null) !== null && (X.userPassword = X.userPassword || "", X.ownerPassword = X.ownerPassword || "", X.userPermissions = X.userPermissions || []), c = typeof x.userUnit == "number" ? Math.abs(x.userUnit) : 1, x.precision !== void 0 && (f = x.precision), x.floatPrecision !== void 0 && (z = x.floatPrecision), U = x.defaultPathOperation || "S"), v = x.filters || (P === !0 ? ["FlateEncode"] : v), b = b || "mm", y = ("" + (y || "P")).toLowerCase();
  var O = x.putOnlyUsedFonts || !1, j = {}, F = { internal: {}, __private__: {} };
  F.__private__.PubSub = Fp;
  var mt = "1.3", ot = F.__private__.getPdfVersion = function() {
    return mt;
  };
  F.__private__.setPdfVersion = function(T) {
    mt = T;
  };
  var yt = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  F.__private__.getPageFormats = function() {
    return yt;
  };
  var st = F.__private__.getPageFormat = function(T) {
    return yt[T];
  };
  k = k || "a4";
  var gt = { COMPAT: "compat", ADVANCED: "advanced" }, zt = gt.COMPAT;
  function Jt() {
    this.saveGraphicsState(), Y(new At(Te, 0, 0, -Te, 0, ia() * Te).toString() + " cm"), this.setFontSize(this.getFontSize() / Te), U = "n", zt = gt.ADVANCED;
  }
  function Kt() {
    this.restoreGraphicsState(), U = "S", zt = gt.COMPAT;
  }
  var pe = F.__private__.combineFontStyleAndFontWeight = function(T, H) {
    if (T == "bold" && H == "normal" || T == "bold" && H == 400 || T == "normal" && H == "italic" || T == "bold" && H == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return H && (T = H == 400 || H === "normal" ? T === "italic" ? "italic" : "normal" : H != 700 && H !== "bold" || T !== "normal" ? (H == 700 ? "bold" : H) + "" + T : "bold"), T;
  };
  F.advancedAPI = function(T) {
    var H = zt === gt.COMPAT;
    return H && Jt.call(this), typeof T != "function" || (T(this), H && Kt.call(this)), this;
  }, F.compatAPI = function(T) {
    var H = zt === gt.ADVANCED;
    return H && Kt.call(this), typeof T != "function" || (T(this), H && Jt.call(this)), this;
  }, F.isAdvancedAPI = function() {
    return zt === gt.ADVANCED;
  };
  var Ot, kt = function(T) {
    if (zt !== gt.ADVANCED) throw new Error(T + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, $t = F.roundToPrecision = F.__private__.roundToPrecision = function(T, H) {
    var ft = f || H;
    if (isNaN(T) || isNaN(ft)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return T.toFixed(ft).replace(/0+$/, "");
  };
  Ot = F.hpf = F.__private__.hpf = typeof z == "number" ? function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return $t(T, z);
  } : z === "smart" ? function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return $t(T, T > -1 && T < 1 ? 16 : 5);
  } : function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return $t(T, 16);
  };
  var ae = F.f2 = F.__private__.f2 = function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.f2");
    return $t(T, 2);
  }, at = F.__private__.f3 = function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.f3");
    return $t(T, 3);
  }, lt = F.scale = F.__private__.scale = function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.scale");
    return zt === gt.COMPAT ? T * Te : zt === gt.ADVANCED ? T : void 0;
  }, It = function(T) {
    return zt === gt.COMPAT ? ia() - T : zt === gt.ADVANCED ? T : void 0;
  }, St = function(T) {
    return lt(It(T));
  };
  F.__private__.setPrecision = F.setPrecision = function(T) {
    typeof parseInt(T, 10) == "number" && (f = parseInt(T, 10));
  };
  var Wt, Xt = "00000000000000000000000000000000", Ht = F.__private__.getFileId = function() {
    return Xt;
  }, jt = F.__private__.setFileId = function(T) {
    return Xt = T !== void 0 && /^[a-fA-F0-9]{32}$/.test(T) ? T.toUpperCase() : Xt.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), X !== null && (mr = new Tc(X.userPermissions, X.userPassword, X.ownerPassword, Xt)), Xt;
  };
  F.setFileId = function(T) {
    return jt(T), this;
  }, F.getFileId = function() {
    return Ht();
  };
  var ee = F.__private__.convertDateToPDFDate = function(T) {
    var H = T.getTimezoneOffset(), ft = H < 0 ? "+" : "-", Ct = Math.floor(Math.abs(H / 60)), Ft = Math.abs(H % 60), Yt = [ft, xt(Ct), "'", xt(Ft), "'"].join("");
    return ["D:", T.getFullYear(), xt(T.getMonth() + 1), xt(T.getDate()), xt(T.getHours()), xt(T.getMinutes()), xt(T.getSeconds()), Yt].join("");
  }, ie = F.__private__.convertPDFDateToDate = function(T) {
    var H = parseInt(T.substr(2, 4), 10), ft = parseInt(T.substr(6, 2), 10) - 1, Ct = parseInt(T.substr(8, 2), 10), Ft = parseInt(T.substr(10, 2), 10), Yt = parseInt(T.substr(12, 2), 10), ye = parseInt(T.substr(14, 2), 10);
    return new Date(H, ft, Ct, Ft, Yt, ye, 0);
  }, Se = F.__private__.setCreationDate = function(T) {
    var H;
    if (T === void 0 && (T = /* @__PURE__ */ new Date()), T instanceof Date) H = ee(T);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(T)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      H = T;
    }
    return Wt = H;
  }, K = F.__private__.getCreationDate = function(T) {
    var H = Wt;
    return T === "jsDate" && (H = ie(Wt)), H;
  };
  F.setCreationDate = function(T) {
    return Se(T), this;
  }, F.getCreationDate = function(T) {
    return K(T);
  };
  var pt, xt = F.__private__.padd2 = function(T) {
    return ("0" + parseInt(T)).slice(-2);
  }, Tt = F.__private__.padd2Hex = function(T) {
    return ("00" + (T = T.toString())).substr(T.length);
  }, Et = 0, Rt = [], qt = [], Gt = 0, we = [], be = [], Ie = !1, Pe = qt, ti = function() {
    Et = 0, Gt = 0, qt = [], Rt = [], we = [], xi = me(), Ke = me();
  };
  F.__private__.setCustomOutputDestination = function(T) {
    Ie = !0, Pe = T;
  };
  var Qt = function(T) {
    Ie || (Pe = T);
  };
  F.__private__.resetCustomOutputDestination = function() {
    Ie = !1, Pe = qt;
  };
  var Y = F.__private__.out = function(T) {
    return T = T.toString(), Gt += T.length + 1, Pe.push(T), Pe;
  }, ui = F.__private__.write = function(T) {
    return Y(arguments.length === 1 ? T.toString() : Array.prototype.join.call(arguments, " "));
  }, Ge = F.__private__.getArrayBuffer = function(T) {
    for (var H = T.length, ft = new ArrayBuffer(H), Ct = new Uint8Array(ft); H--; ) Ct[H] = T.charCodeAt(H);
    return ft;
  }, se = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  F.__private__.getStandardFonts = function() {
    return se;
  };
  var _e = x.fontSize || 16;
  F.__private__.setFontSize = F.setFontSize = function(T) {
    return _e = zt === gt.ADVANCED ? T / Te : T, this;
  };
  var ze, ke = F.__private__.getFontSize = F.getFontSize = function() {
    return zt === gt.COMPAT ? _e : _e * Te;
  }, Ze = x.R2L || !1;
  F.__private__.setR2L = F.setR2L = function(T) {
    return Ze = T, this;
  }, F.__private__.getR2L = F.getR2L = function() {
    return Ze;
  };
  var di, ai = F.__private__.setZoomMode = function(T) {
    var H = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(T)) ze = T;
    else if (isNaN(T)) {
      if (H.indexOf(T) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + T + '" is not recognized.');
      ze = T;
    } else ze = parseInt(T, 10);
  };
  F.__private__.getZoomMode = function() {
    return ze;
  };
  var wi, Ei = F.__private__.setPageMode = function(T) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(T) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + T + '" is not recognized.');
    di = T;
  };
  F.__private__.getPageMode = function() {
    return di;
  };
  var oe = F.__private__.setLayoutMode = function(T) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(T) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + T + '" is not recognized.');
    wi = T;
  };
  F.__private__.getLayoutMode = function() {
    return wi;
  }, F.__private__.setDisplayMode = F.setDisplayMode = function(T, H, ft) {
    return ai(T), oe(H), Ei(ft), this;
  };
  var ei = { title: "", subject: "", author: "", keywords: "", creator: "" };
  F.__private__.getDocumentProperty = function(T) {
    if (Object.keys(ei).indexOf(T) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return ei[T];
  }, F.__private__.getDocumentProperties = function() {
    return ei;
  }, F.__private__.setDocumentProperties = F.setProperties = F.setDocumentProperties = function(T) {
    for (var H in ei) ei.hasOwnProperty(H) && T[H] && (ei[H] = T[H]);
    return this;
  }, F.__private__.setDocumentProperty = function(T, H) {
    if (Object.keys(ei).indexOf(T) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return ei[T] = H;
  };
  var oi, Te, cr, le, si, Ce = {}, zi = {}, Sr = [], Ee = {}, Xr = {}, Vi = {}, Mr = {}, Er = null, ut = 0, V = [], Z = new Fp(F), et = x.hotfixes || [], ct = {}, Pt = {}, Mt = [], At = function T(H, ft, Ct, Ft, Yt, ye) {
    if (!(this instanceof T)) return new T(H, ft, Ct, Ft, Yt, ye);
    isNaN(H) && (H = 1), isNaN(ft) && (ft = 0), isNaN(Ct) && (Ct = 0), isNaN(Ft) && (Ft = 1), isNaN(Yt) && (Yt = 0), isNaN(ye) && (ye = 0), this._matrix = [H, ft, Ct, Ft, Yt, ye];
  };
  Object.defineProperty(At.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(T) {
    this._matrix[0] = T;
  } }), Object.defineProperty(At.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(T) {
    this._matrix[1] = T;
  } }), Object.defineProperty(At.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(T) {
    this._matrix[2] = T;
  } }), Object.defineProperty(At.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(T) {
    this._matrix[3] = T;
  } }), Object.defineProperty(At.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(T) {
    this._matrix[4] = T;
  } }), Object.defineProperty(At.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(T) {
    this._matrix[5] = T;
  } }), Object.defineProperty(At.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(T) {
    this._matrix[0] = T;
  } }), Object.defineProperty(At.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(T) {
    this._matrix[1] = T;
  } }), Object.defineProperty(At.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(T) {
    this._matrix[2] = T;
  } }), Object.defineProperty(At.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(T) {
    this._matrix[3] = T;
  } }), Object.defineProperty(At.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(T) {
    this._matrix[4] = T;
  } }), Object.defineProperty(At.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(T) {
    this._matrix[5] = T;
  } }), Object.defineProperty(At.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(At.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(At.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(At.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), At.prototype.join = function(T) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(Ot).join(T);
  }, At.prototype.multiply = function(T) {
    var H = T.sx * this.sx + T.shy * this.shx, ft = T.sx * this.shy + T.shy * this.sy, Ct = T.shx * this.sx + T.sy * this.shx, Ft = T.shx * this.shy + T.sy * this.sy, Yt = T.tx * this.sx + T.ty * this.shx + this.tx, ye = T.tx * this.shy + T.ty * this.sy + this.ty;
    return new At(H, ft, Ct, Ft, Yt, ye);
  }, At.prototype.decompose = function() {
    var T = this.sx, H = this.shy, ft = this.shx, Ct = this.sy, Ft = this.tx, Yt = this.ty, ye = Math.sqrt(T * T + H * H), Be = (T /= ye) * ft + (H /= ye) * Ct;
    ft -= T * Be, Ct -= H * Be;
    var Je = Math.sqrt(ft * ft + Ct * Ct);
    return Be /= Je, T * (Ct /= Je) < H * (ft /= Je) && (T = -T, H = -H, Be = -Be, ye = -ye), { scale: new At(ye, 0, 0, Je, 0, 0), translate: new At(1, 0, 0, 1, Ft, Yt), rotate: new At(T, H, -H, T, 0, 0), skew: new At(1, 0, Be, 1, 0, 0) };
  }, At.prototype.toString = function(T) {
    return this.join(" ");
  }, At.prototype.inversed = function() {
    var T = this.sx, H = this.shy, ft = this.shx, Ct = this.sy, Ft = this.tx, Yt = this.ty, ye = 1 / (T * Ct - H * ft), Be = Ct * ye, Je = -H * ye, mi = -ft * ye, gi = T * ye;
    return new At(Be, Je, mi, gi, -Be * Ft - mi * Yt, -Je * Ft - gi * Yt);
  }, At.prototype.applyToPoint = function(T) {
    var H = T.x * this.sx + T.y * this.shx + this.tx, ft = T.x * this.shy + T.y * this.sy + this.ty;
    return new Bn(H, ft);
  }, At.prototype.applyToRectangle = function(T) {
    var H = this.applyToPoint(T), ft = this.applyToPoint(new Bn(T.x + T.w, T.y + T.h));
    return new no(H.x, H.y, ft.x - H.x, ft.y - H.y);
  }, At.prototype.clone = function() {
    var T = this.sx, H = this.shy, ft = this.shx, Ct = this.sy, Ft = this.tx, Yt = this.ty;
    return new At(T, H, ft, Ct, Ft, Yt);
  }, F.Matrix = At;
  var bt = F.matrixMult = function(T, H) {
    return H.multiply(T);
  }, Ut = new At(1, 0, 0, 1, 0, 0);
  F.unitMatrix = F.identityMatrix = Ut;
  var te = function(T, H) {
    if (!Xr[T]) {
      var ft = (H instanceof Ql ? "Sh" : "P") + (Object.keys(Ee).length + 1).toString(10);
      H.id = ft, Xr[T] = ft, Ee[ft] = H, Z.publish("addPattern", H);
    }
  };
  F.ShadingPattern = Ql, F.TilingPattern = Cc, F.addShadingPattern = function(T, H) {
    return kt("addShadingPattern()"), te(T, H), this;
  }, F.beginTilingPattern = function(T) {
    kt("beginTilingPattern()"), Uo(T.boundingBox[0], T.boundingBox[1], T.boundingBox[2] - T.boundingBox[0], T.boundingBox[3] - T.boundingBox[1], T.matrix);
  }, F.endTilingPattern = function(T, H) {
    kt("endTilingPattern()"), H.stream = be[pt].join(`
`), te(T, H), Z.publish("endTilingPattern", H), Mt.pop().restore();
  };
  var Bt = F.__private__.newObject = function() {
    var T = me();
    return Ne(T, !0), T;
  }, me = F.__private__.newObjectDeferred = function() {
    return Et++, Rt[Et] = function() {
      return Gt;
    }, Et;
  }, Ne = function(T, H) {
    return H = typeof H == "boolean" && H, Rt[T] = Gt, H && Y(T + " 0 obj"), T;
  }, $e = F.__private__.newAdditionalObject = function() {
    var T = { objId: me(), content: "" };
    return we.push(T), T;
  }, xi = me(), Ke = me(), yi = F.__private__.decodeColorString = function(T) {
    var H = T.split(" ");
    if (H.length !== 2 || H[1] !== "g" && H[1] !== "G")
      H.length === 5 && (H[4] === "k" || H[4] === "K") && (H = [(1 - H[0]) * (1 - H[3]), (1 - H[1]) * (1 - H[3]), (1 - H[2]) * (1 - H[3]), "r"]);
    else {
      var ft = parseFloat(H[0]);
      H = [ft, ft, ft, "r"];
    }
    for (var Ct = "#", Ft = 0; Ft < 3; Ft++) Ct += ("0" + Math.floor(255 * parseFloat(H[Ft])).toString(16)).slice(-2);
    return Ct;
  }, pi = F.__private__.encodeColorString = function(T) {
    var H;
    typeof T == "string" && (T = { ch1: T });
    var ft = T.ch1, Ct = T.ch2, Ft = T.ch3, Yt = T.ch4, ye = T.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof ft == "string" && ft.charAt(0) !== "#") {
      var Be = new hf(ft);
      if (Be.ok) ft = Be.toHex();
      else if (!/^\d*\.?\d*$/.test(ft)) throw new Error('Invalid color "' + ft + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof ft == "string" && /^#[0-9A-Fa-f]{3}$/.test(ft) && (ft = "#" + ft[1] + ft[1] + ft[2] + ft[2] + ft[3] + ft[3]), typeof ft == "string" && /^#[0-9A-Fa-f]{6}$/.test(ft)) {
      var Je = parseInt(ft.substr(1), 16);
      ft = Je >> 16 & 255, Ct = Je >> 8 & 255, Ft = 255 & Je;
    }
    if (Ct === void 0 || Yt === void 0 && ft === Ct && Ct === Ft) if (typeof ft == "string") H = ft + " " + ye[0];
    else switch (T.precision) {
      case 2:
        H = ae(ft / 255) + " " + ye[0];
        break;
      case 3:
      default:
        H = at(ft / 255) + " " + ye[0];
    }
    else if (Yt === void 0 || nr(Yt) === "object") {
      if (Yt && !isNaN(Yt.a) && Yt.a === 0) return H = ["1.", "1.", "1.", ye[1]].join(" ");
      if (typeof ft == "string") H = [ft, Ct, Ft, ye[1]].join(" ");
      else switch (T.precision) {
        case 2:
          H = [ae(ft / 255), ae(Ct / 255), ae(Ft / 255), ye[1]].join(" ");
          break;
        default:
        case 3:
          H = [at(ft / 255), at(Ct / 255), at(Ft / 255), ye[1]].join(" ");
      }
    } else if (typeof ft == "string") H = [ft, Ct, Ft, Yt, ye[2]].join(" ");
    else switch (T.precision) {
      case 2:
        H = [ae(ft), ae(Ct), ae(Ft), ae(Yt), ye[2]].join(" ");
        break;
      case 3:
      default:
        H = [at(ft), at(Ct), at(Ft), at(Yt), ye[2]].join(" ");
    }
    return H;
  }, Zi = F.__private__.getFilters = function() {
    return v;
  }, Bi = F.__private__.putStream = function(T) {
    var H = (T = T || {}).data || "", ft = T.filters || Zi(), Ct = T.alreadyAppliedFilters || [], Ft = T.addLength1 || !1, Yt = H.length, ye = T.objectId, Be = function(Kr) {
      return Kr;
    };
    if (X !== null && ye === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    X !== null && (Be = mr.encryptor(ye, 0));
    var Je = {};
    ft === !0 && (ft = ["FlateEncode"]);
    var mi = T.additionalKeyValues || [], gi = (Je = _i.API.processDataByFilters !== void 0 ? _i.API.processDataByFilters(H, ft) : { data: H, reverseChain: [] }).reverseChain + (Array.isArray(Ct) ? Ct.join(" ") : Ct.toString());
    if (Je.data.length !== 0 && (mi.push({ key: "Length", value: Je.data.length }), Ft === !0 && mi.push({ key: "Length1", value: Yt })), gi.length != 0) if (gi.split("/").length - 1 == 1) mi.push({ key: "Filter", value: gi });
    else {
      mi.push({ key: "Filter", value: "[" + gi + "]" });
      for (var ki = 0; ki < mi.length; ki += 1) if (mi[ki].key === "DecodeParms") {
        for (var Qi = [], vr = 0; vr < Je.reverseChain.split("/").length - 1; vr += 1) Qi.push("null");
        Qi.push(mi[ki].value), mi[ki].value = "[" + Qi.join(" ") + "]";
      }
    }
    Y("<<");
    for (var Ai = 0; Ai < mi.length; Ai++) Y("/" + mi[Ai].key + " " + mi[Ai].value);
    Y(">>"), Je.data.length !== 0 && (Y("stream"), Y(Be(Je.data)), Y("endstream"));
  }, li = F.__private__.putPage = function(T) {
    var H = T.number, ft = T.data, Ct = T.objId, Ft = T.contentsObjId;
    Ne(Ct, !0), Y("<</Type /Page"), Y("/Parent " + T.rootDictionaryObjId + " 0 R"), Y("/Resources " + T.resourceDictionaryObjId + " 0 R"), Y("/MediaBox [" + parseFloat(Ot(T.mediaBox.bottomLeftX)) + " " + parseFloat(Ot(T.mediaBox.bottomLeftY)) + " " + Ot(T.mediaBox.topRightX) + " " + Ot(T.mediaBox.topRightY) + "]"), T.cropBox !== null && Y("/CropBox [" + Ot(T.cropBox.bottomLeftX) + " " + Ot(T.cropBox.bottomLeftY) + " " + Ot(T.cropBox.topRightX) + " " + Ot(T.cropBox.topRightY) + "]"), T.bleedBox !== null && Y("/BleedBox [" + Ot(T.bleedBox.bottomLeftX) + " " + Ot(T.bleedBox.bottomLeftY) + " " + Ot(T.bleedBox.topRightX) + " " + Ot(T.bleedBox.topRightY) + "]"), T.trimBox !== null && Y("/TrimBox [" + Ot(T.trimBox.bottomLeftX) + " " + Ot(T.trimBox.bottomLeftY) + " " + Ot(T.trimBox.topRightX) + " " + Ot(T.trimBox.topRightY) + "]"), T.artBox !== null && Y("/ArtBox [" + Ot(T.artBox.bottomLeftX) + " " + Ot(T.artBox.bottomLeftY) + " " + Ot(T.artBox.topRightX) + " " + Ot(T.artBox.topRightY) + "]"), typeof T.userUnit == "number" && T.userUnit !== 1 && Y("/UserUnit " + T.userUnit), Z.publish("putPage", { objId: Ct, pageContext: V[H], pageNumber: H, page: ft }), Y("/Contents " + Ft + " 0 R"), Y(">>"), Y("endobj");
    var Yt = ft.join(`
`);
    return zt === gt.ADVANCED && (Yt += `
Q`), Ne(Ft, !0), Bi({ data: Yt, filters: Zi(), objectId: Ft }), Y("endobj"), Ct;
  }, Di = F.__private__.putPages = function() {
    var T, H, ft = [];
    for (T = 1; T <= ut; T++) V[T].objId = me(), V[T].contentsObjId = me();
    for (T = 1; T <= ut; T++) ft.push(li({ number: T, data: be[T], objId: V[T].objId, contentsObjId: V[T].contentsObjId, mediaBox: V[T].mediaBox, cropBox: V[T].cropBox, bleedBox: V[T].bleedBox, trimBox: V[T].trimBox, artBox: V[T].artBox, userUnit: V[T].userUnit, rootDictionaryObjId: xi, resourceDictionaryObjId: Ke }));
    Ne(xi, !0), Y("<</Type /Pages");
    var Ct = "/Kids [";
    for (H = 0; H < ut; H++) Ct += ft[H] + " 0 R ";
    Y(Ct + "]"), Y("/Count " + ut), Y(">>"), Y("endobj"), Z.publish("postPutPages");
  }, Gi = function(T) {
    Z.publish("putFont", { font: T, out: Y, newObject: Bt, putStream: Bi }), T.isAlreadyPutted !== !0 && (T.objectNumber = Bt(), Y("<<"), Y("/Type /Font"), Y("/BaseFont /" + Lc(T.postScriptName)), Y("/Subtype /Type1"), typeof T.encoding == "string" && Y("/Encoding /" + T.encoding), Y("/FirstChar 32"), Y("/LastChar 255"), Y(">>"), Y("endobj"));
  }, hr = function() {
    for (var T in Ce) Ce.hasOwnProperty(T) && (O === !1 || O === !0 && j.hasOwnProperty(T)) && Gi(Ce[T]);
  }, pr = function(T) {
    T.objectNumber = Bt();
    var H = [];
    H.push({ key: "Type", value: "/XObject" }), H.push({ key: "Subtype", value: "/Form" }), H.push({ key: "BBox", value: "[" + [Ot(T.x), Ot(T.y), Ot(T.x + T.width), Ot(T.y + T.height)].join(" ") + "]" }), H.push({ key: "Matrix", value: "[" + T.matrix.toString() + "]" });
    var ft = T.pages[1].join(`
`);
    Bi({ data: ft, additionalKeyValues: H, objectId: T.objectNumber }), Y("endobj");
  }, Ar = function() {
    for (var T in ct) ct.hasOwnProperty(T) && pr(ct[T]);
  }, Es = function(T, H) {
    var ft, Ct = [], Ft = 1 / (H - 1);
    for (ft = 0; ft < 1; ft += Ft) Ct.push(ft);
    if (Ct.push(1), T[0].offset != 0) {
      var Yt = { offset: 0, color: T[0].color };
      T.unshift(Yt);
    }
    if (T[T.length - 1].offset != 1) {
      var ye = { offset: 1, color: T[T.length - 1].color };
      T.push(ye);
    }
    for (var Be = "", Je = 0, mi = 0; mi < Ct.length; mi++) {
      for (ft = Ct[mi]; ft > T[Je + 1].offset; ) Je++;
      var gi = T[Je].offset, ki = (ft - gi) / (T[Je + 1].offset - gi), Qi = T[Je].color, vr = T[Je + 1].color;
      Be += Tt(Math.round((1 - ki) * Qi[0] + ki * vr[0]).toString(16)) + Tt(Math.round((1 - ki) * Qi[1] + ki * vr[1]).toString(16)) + Tt(Math.round((1 - ki) * Qi[2] + ki * vr[2]).toString(16));
    }
    return Be.trim();
  }, Ri = function(T, H) {
    H || (H = 21);
    var ft = Bt(), Ct = Es(T.colors, H), Ft = [];
    Ft.push({ key: "FunctionType", value: "0" }), Ft.push({ key: "Domain", value: "[0.0 1.0]" }), Ft.push({ key: "Size", value: "[" + H + "]" }), Ft.push({ key: "BitsPerSample", value: "8" }), Ft.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Ft.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), Bi({ data: Ct, additionalKeyValues: Ft, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: ft }), Y("endobj"), T.objectNumber = Bt(), Y("<< /ShadingType " + T.type), Y("/ColorSpace /DeviceRGB");
    var Yt = "/Coords [" + Ot(parseFloat(T.coords[0])) + " " + Ot(parseFloat(T.coords[1])) + " ";
    T.type === 2 ? Yt += Ot(parseFloat(T.coords[2])) + " " + Ot(parseFloat(T.coords[3])) : Yt += Ot(parseFloat(T.coords[2])) + " " + Ot(parseFloat(T.coords[3])) + " " + Ot(parseFloat(T.coords[4])) + " " + Ot(parseFloat(T.coords[5])), Y(Yt += "]"), T.matrix && Y("/Matrix [" + T.matrix.toString() + "]"), Y("/Function " + ft + " 0 R"), Y("/Extend [true true]"), Y(">>"), Y("endobj");
  }, No = function(T, H) {
    var ft = me(), Ct = Bt();
    H.push({ resourcesOid: ft, objectOid: Ct }), T.objectNumber = Ct;
    var Ft = [];
    Ft.push({ key: "Type", value: "/Pattern" }), Ft.push({ key: "PatternType", value: "1" }), Ft.push({ key: "PaintType", value: "1" }), Ft.push({ key: "TilingType", value: "1" }), Ft.push({ key: "BBox", value: "[" + T.boundingBox.map(Ot).join(" ") + "]" }), Ft.push({ key: "XStep", value: Ot(T.xStep) }), Ft.push({ key: "YStep", value: Ot(T.yStep) }), Ft.push({ key: "Resources", value: ft + " 0 R" }), T.matrix && Ft.push({ key: "Matrix", value: "[" + T.matrix.toString() + "]" }), Bi({ data: T.stream, additionalKeyValues: Ft, objectId: T.objectNumber }), Y("endobj");
  }, Ks = function(T) {
    var H;
    for (H in Ee) Ee.hasOwnProperty(H) && (Ee[H] instanceof Ql ? Ri(Ee[H]) : Ee[H] instanceof Cc && No(Ee[H], T));
  }, Hr = function(T) {
    for (var H in T.objectNumber = Bt(), Y("<<"), T) switch (H) {
      case "opacity":
        Y("/ca " + ae(T[H]));
        break;
      case "stroke-opacity":
        Y("/CA " + ae(T[H]));
    }
    Y(">>"), Y("endobj");
  }, ln = function() {
    var T;
    for (T in Vi) Vi.hasOwnProperty(T) && Hr(Vi[T]);
  }, Do = function() {
    for (var T in Y("/XObject <<"), ct) ct.hasOwnProperty(T) && ct[T].objectNumber >= 0 && Y("/" + T + " " + ct[T].objectNumber + " 0 R");
    Z.publish("putXobjectDict"), Y(">>");
  }, mn = function() {
    mr.oid = Bt(), Y("<<"), Y("/Filter /Standard"), Y("/V " + mr.v), Y("/R " + mr.r), Y("/U <" + mr.toHexString(mr.U) + ">"), Y("/O <" + mr.toHexString(mr.O) + ">"), Y("/P " + mr.P), Y(">>"), Y("endobj");
  }, Yr = function() {
    for (var T in Y("/Font <<"), Ce) Ce.hasOwnProperty(T) && (O === !1 || O === !0 && j.hasOwnProperty(T)) && Y("/" + T + " " + Ce[T].objectNumber + " 0 R");
    Y(">>");
  }, Js = function() {
    if (Object.keys(Ee).length > 0) {
      for (var T in Y("/Shading <<"), Ee) Ee.hasOwnProperty(T) && Ee[T] instanceof Ql && Ee[T].objectNumber >= 0 && Y("/" + T + " " + Ee[T].objectNumber + " 0 R");
      Z.publish("putShadingPatternDict"), Y(">>");
    }
  }, Dn = function(T) {
    if (Object.keys(Ee).length > 0) {
      for (var H in Y("/Pattern <<"), Ee) Ee.hasOwnProperty(H) && Ee[H] instanceof F.TilingPattern && Ee[H].objectNumber >= 0 && Ee[H].objectNumber < T && Y("/" + H + " " + Ee[H].objectNumber + " 0 R");
      Z.publish("putTilingPatternDict"), Y(">>");
    }
  }, fr = function() {
    if (Object.keys(Vi).length > 0) {
      var T;
      for (T in Y("/ExtGState <<"), Vi) Vi.hasOwnProperty(T) && Vi[T].objectNumber >= 0 && Y("/" + T + " " + Vi[T].objectNumber + " 0 R");
      Z.publish("putGStateDict"), Y(">>");
    }
  }, Ji = function(T) {
    Ne(T.resourcesOid, !0), Y("<<"), Y("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), Yr(), Js(), Dn(T.objectOid), fr(), Do(), Y(">>"), Y("endobj");
  }, gn = function() {
    var T = [];
    hr(), ln(), Ar(), Ks(T), Z.publish("putResources"), T.forEach(Ji), Ji({ resourcesOid: Ke, objectOid: Number.MAX_SAFE_INTEGER }), Z.publish("postPutResources");
  }, sr = function() {
    Z.publish("putAdditionalObjects");
    for (var T = 0; T < we.length; T++) {
      var H = we[T];
      Ne(H.objId, !0), Y(H.content), Y("endobj");
    }
    Z.publish("postPutAdditionalObjects");
  }, va = function(T) {
    zi[T.fontName] = zi[T.fontName] || {}, zi[T.fontName][T.fontStyle] = T.id;
  }, cn = function(T, H, ft, Ct, Ft) {
    var Yt = { id: "F" + (Object.keys(Ce).length + 1).toString(10), postScriptName: T, fontName: H, fontStyle: ft, encoding: Ct, isStandardFont: Ft || !1, metadata: {} };
    return Z.publish("addFont", { font: Yt, instance: this }), Ce[Yt.id] = Yt, va(Yt), Yt.id;
  }, Fo = function(T) {
    for (var H = 0, ft = se.length; H < ft; H++) {
      var Ct = cn.call(this, T[H][0], T[H][1], T[H][2], se[H][3], !0);
      O === !1 && (j[Ct] = !0);
      var Ft = T[H][0].split("-");
      va({ id: Ct, fontName: Ft[0], fontStyle: Ft[1] || "" });
    }
    Z.publish("addFonts", { fonts: Ce, dictionary: zi });
  }, _r = function(T) {
    return T.foo = function() {
      try {
        return T.apply(this, arguments);
      } catch (Ct) {
        var H = Ct.stack || "";
        ~H.indexOf(" at ") && (H = H.split(" at ")[1]);
        var ft = "Error in function " + H.split(`
`)[0].split("<")[0] + ": " + Ct.message;
        if (!vi.console) throw new Error(ft);
        vi.console.error(ft, Ct), vi.alert && alert(ft);
      }
    }, T.foo.bar = T, T.foo;
  }, Ga = function(T, H) {
    var ft, Ct, Ft, Yt, ye, Be, Je, mi, gi;
    if (Ft = (H = H || {}).sourceEncoding || "Unicode", ye = H.outputEncoding, (H.autoencode || ye) && Ce[oi].metadata && Ce[oi].metadata[Ft] && Ce[oi].metadata[Ft].encoding && (Yt = Ce[oi].metadata[Ft].encoding, !ye && Ce[oi].encoding && (ye = Ce[oi].encoding), !ye && Yt.codePages && (ye = Yt.codePages[0]), typeof ye == "string" && (ye = Yt[ye]), ye)) {
      for (Je = !1, Be = [], ft = 0, Ct = T.length; ft < Ct; ft++) (mi = ye[T.charCodeAt(ft)]) ? Be.push(String.fromCharCode(mi)) : Be.push(T[ft]), Be[ft].charCodeAt(0) >> 8 && (Je = !0);
      T = Be.join("");
    }
    for (ft = T.length; Je === void 0 && ft !== 0; ) T.charCodeAt(ft - 1) >> 8 && (Je = !0), ft--;
    if (!Je) return T;
    for (Be = H.noBOM ? [] : [254, 255], ft = 0, Ct = T.length; ft < Ct; ft++) {
      if ((gi = (mi = T.charCodeAt(ft)) >> 8) >> 8) throw new Error("Character at position " + ft + " of string '" + T + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Be.push(gi), Be.push(mi - (gi << 8));
    }
    return String.fromCharCode.apply(void 0, Be);
  }, Rr = F.__private__.pdfEscape = F.pdfEscape = function(T, H) {
    return Ga(T, H).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, Jn = F.__private__.beginPage = function(T) {
    be[++ut] = [], V[ut] = { objId: 0, contentsObjId: 0, userUnit: Number(c), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(T[0]), topRightY: Number(T[1]) } }, $a(ut), Qt(be[pt]);
  }, Qn = function(T, H) {
    var ft, Ct, Ft;
    switch (y = H || y, typeof T == "string" && (ft = st(T.toLowerCase()), Array.isArray(ft) && (Ct = ft[0], Ft = ft[1])), Array.isArray(T) && (Ct = T[0] * Te, Ft = T[1] * Te), isNaN(Ct) && (Ct = k[0], Ft = k[1]), (Ct > 14400 || Ft > 14400) && (dr.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), Ct = Math.min(14400, Ct), Ft = Math.min(14400, Ft)), k = [Ct, Ft], y.substr(0, 1)) {
      case "l":
        Ft > Ct && (k = [Ft, Ct]);
        break;
      case "p":
        Ct > Ft && (k = [Ft, Ct]);
    }
    Jn(k), ul(Sa), Y(is), io !== 0 && Y(io + " J"), ro !== 0 && Y(ro + " j"), Z.publish("addPage", { pageNumber: ut });
  }, Fi = function(T) {
    T > 0 && T <= ut && (be.splice(T, 1), V.splice(T, 1), ut--, pt > ut && (pt = ut), this.setPage(pt));
  }, $a = function(T) {
    T > 0 && T <= ut && (pt = T);
  }, Bo = F.__private__.getNumberOfPages = F.getNumberOfPages = function() {
    return be.length - 1;
  }, zs = function(T, H, ft) {
    var Ct, Ft = void 0;
    return ft = ft || {}, T = T !== void 0 ? T : Ce[oi].fontName, H = H !== void 0 ? H : Ce[oi].fontStyle, Ct = T.toLowerCase(), zi[Ct] !== void 0 && zi[Ct][H] !== void 0 ? Ft = zi[Ct][H] : zi[T] !== void 0 && zi[T][H] !== void 0 ? Ft = zi[T][H] : ft.disableWarning === !1 && dr.warn("Unable to look up font label for font '" + T + "', '" + H + "'. Refer to getFontList() for available fonts."), Ft || ft.noFallback || (Ft = zi.times[H]) == null && (Ft = zi.times.normal), Ft;
  }, Ro = F.__private__.putInfo = function() {
    var T = Bt(), H = function(Ct) {
      return Ct;
    };
    for (var ft in X !== null && (H = mr.encryptor(T, 0)), Y("<<"), Y("/Producer (" + Rr(H("jsPDF " + _i.version)) + ")"), ei) ei.hasOwnProperty(ft) && ei[ft] && Y("/" + ft.substr(0, 1).toUpperCase() + ft.substr(1) + " (" + Rr(H(ei[ft])) + ")");
    Y("/CreationDate (" + Rr(H(Wt)) + ")"), Y(">>"), Y("endobj");
  }, Qs = F.__private__.putCatalog = function(T) {
    var H = (T = T || {}).rootDictionaryObjId || xi;
    switch (Bt(), Y("<<"), Y("/Type /Catalog"), Y("/Pages " + H + " 0 R"), ze || (ze = "fullwidth"), ze) {
      case "fullwidth":
        Y("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        Y("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        Y("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        Y("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var ft = "" + ze;
        ft.substr(ft.length - 1) === "%" && (ze = parseInt(ze) / 100), typeof ze == "number" && Y("/OpenAction [3 0 R /XYZ null null " + ae(ze) + "]");
    }
    switch (wi || (wi = "continuous"), wi) {
      case "continuous":
        Y("/PageLayout /OneColumn");
        break;
      case "single":
        Y("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        Y("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        Y("/PageLayout /TwoColumnRight");
    }
    di && Y("/PageMode /" + di), Z.publish("putCatalog"), Y(">>"), Y("endobj");
  }, xa = F.__private__.putTrailer = function() {
    Y("trailer"), Y("<<"), Y("/Size " + (Et + 1)), Y("/Root " + Et + " 0 R"), Y("/Info " + (Et - 1) + " 0 R"), X !== null && Y("/Encrypt " + mr.oid + " 0 R"), Y("/ID [ <" + Xt + "> <" + Xt + "> ]"), Y(">>");
  }, Za = F.__private__.putHeader = function() {
    Y("%PDF-" + mt), Y("%");
  }, ta = F.__private__.putXRef = function() {
    var T = "0000000000";
    Y("xref"), Y("0 " + (Et + 1)), Y("0000000000 65535 f ");
    for (var H = 1; H <= Et; H++)
      typeof Rt[H] == "function" ? Y((T + Rt[H]()).slice(-10) + " 00000 n ") : Rt[H] !== void 0 ? Y((T + Rt[H]).slice(-10) + " 00000 n ") : Y("0000000000 00000 n ");
  }, fs = F.__private__.buildDocument = function() {
    ti(), Qt(qt), Z.publish("buildDocument"), Za(), Di(), sr(), gn(), X !== null && mn(), Ro(), Qs();
    var T = Gt;
    return ta(), xa(), Y("startxref"), Y("" + T), Y("%%EOF"), Qt(be[pt]), qt.join(`
`);
  }, Wa = F.__private__.getBlob = function(T) {
    return new Blob([Ge(T)], { type: "application/pdf" });
  }, ba = F.output = F.__private__.output = _r(function(T, H) {
    switch (typeof (H = H || {}) == "string" ? H = { filename: H } : H.filename = H.filename || "generated.pdf", T) {
      case void 0:
        return fs();
      case "save":
        F.save(H.filename);
        break;
      case "arraybuffer":
        return Ge(fs());
      case "blob":
        return Wa(fs());
      case "bloburi":
      case "bloburl":
        if (vi.URL !== void 0 && typeof vi.URL.createObjectURL == "function") return vi.URL && vi.URL.createObjectURL(Wa(fs())) || void 0;
        dr.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var ft = "", Ct = fs();
        try {
          ft = Zu(Ct);
        } catch {
          ft = Zu(unescape(encodeURIComponent(Ct)));
        }
        return "data:application/pdf;filename=" + H.filename + ";base64," + ft;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(vi) === "[object Window]") {
          var Ft = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", Yt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          H.pdfObjectUrl && (Ft = H.pdfObjectUrl, Yt = "");
          var ye = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + Ft + '"' + Yt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(H) + ");<\/script></body></html>", Be = vi.open();
          return Be !== null && Be.document.write(ye), Be;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(vi) === "[object Window]") {
          var Je = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (H.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + H.filename + '" width="500px" height="400px" /></body></html>', mi = vi.open();
          if (mi !== null) {
            mi.document.write(Je);
            var gi = this;
            mi.document.documentElement.querySelector("#pdfViewer").onload = function() {
              mi.document.title = H.filename, mi.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(gi.output("bloburl"));
            };
          }
          return mi;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(vi) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var ki = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", H) + '"></iframe></body></html>', Qi = vi.open();
        if (Qi !== null && (Qi.document.write(ki), Qi.document.title = H.filename), Qi || typeof safari > "u") return Qi;
        break;
      case "datauri":
      case "dataurl":
        return vi.document.location.href = this.output("datauristring", H);
      default:
        return null;
    }
  }), cl = function(T) {
    return Array.isArray(et) === !0 && et.indexOf(T) > -1;
  };
  switch (b) {
    case "pt":
      Te = 1;
      break;
    case "mm":
      Te = 72 / 25.4;
      break;
    case "cm":
      Te = 72 / 2.54;
      break;
    case "in":
      Te = 72;
      break;
    case "px":
      Te = cl("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Te = 12;
      break;
    case "ex":
      Te = 6;
      break;
    default:
      if (typeof b != "number") throw new Error("Invalid unit: " + b);
      Te = b;
  }
  var mr = null;
  Se(), jt();
  var wa = function(T) {
    return X !== null ? mr.encryptor(T, 0) : function(H) {
      return H;
    };
  }, Or = F.__private__.getPageInfo = F.getPageInfo = function(T) {
    if (isNaN(T) || T % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: V[T].objId, pageNumber: T, pageContext: V[T] };
  }, He = F.__private__.getPageInfoByObjId = function(T) {
    if (isNaN(T) || T % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var H in V) if (V[H].objId === T) break;
    return Or(H);
  }, Xa = F.__private__.getCurrentPageInfo = F.getCurrentPageInfo = function() {
    return { objId: V[pt].objId, pageNumber: pt, pageContext: V[pt] };
  };
  F.addPage = function() {
    return Qn.apply(this, arguments), this;
  }, F.setPage = function() {
    return $a.apply(this, arguments), Qt.call(this, be[pt]), this;
  }, F.insertPage = function(T) {
    return this.addPage(), this.movePage(pt, T), this;
  }, F.movePage = function(T, H) {
    var ft, Ct;
    if (T > H) {
      ft = be[T], Ct = V[T];
      for (var Ft = T; Ft > H; Ft--) be[Ft] = be[Ft - 1], V[Ft] = V[Ft - 1];
      be[H] = ft, V[H] = Ct, this.setPage(H);
    } else if (T < H) {
      ft = be[T], Ct = V[T];
      for (var Yt = T; Yt < H; Yt++) be[Yt] = be[Yt + 1], V[Yt] = V[Yt + 1];
      be[H] = ft, V[H] = Ct, this.setPage(H);
    }
    return this;
  }, F.deletePage = function() {
    return Fi.apply(this, arguments), this;
  }, F.__private__.text = F.text = function(T, H, ft, Ct, Ft) {
    var Yt, ye, Be, Je, mi, gi, ki, Qi, vr, Ai = (Ct = Ct || {}).scope || this;
    if (typeof T == "number" && typeof H == "number" && (typeof ft == "string" || Array.isArray(ft))) {
      var Kr = ft;
      ft = H, H = T, T = Kr;
    }
    if (arguments[3] instanceof At ? (kt("The transform parameter of text() with a Matrix value"), vr = Ft) : (Be = arguments[4], Je = arguments[5], nr(ki = arguments[3]) === "object" && ki !== null || (typeof Be == "string" && (Je = Be, Be = null), typeof ki == "string" && (Je = ki, ki = null), typeof ki == "number" && (Be = ki, ki = null), Ct = { flags: ki, angle: Be, align: Je })), isNaN(H) || isNaN(ft) || T == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (T.length === 0) return Ai;
    var Ye = "", yn = !1, Ci = typeof Ct.lineHeightFactor == "number" ? Ct.lineHeightFactor : Ds, Mi = Ai.internal.scaleFactor;
    function _s(Ii) {
      return Ii = Ii.split("	").join(Array(Ct.TabLen || 9).join(" ")), Rr(Ii, ki);
    }
    function Fs(Ii) {
      for (var Oi, gr = Ii.concat(), Ir = [], $i = gr.length; $i--; ) typeof (Oi = gr.shift()) == "string" ? Ir.push(Oi) : Array.isArray(Ii) && (Oi.length === 1 || Oi[1] === void 0 && Oi[2] === void 0) ? Ir.push(Oi[0]) : Ir.push([Oi[0], Oi[1], Oi[2]]);
      return Ir;
    }
    function Bs(Ii, Oi) {
      var gr;
      if (typeof Ii == "string") gr = Oi(Ii)[0];
      else if (Array.isArray(Ii)) {
        for (var Ir, $i, un = Ii.concat(), Nr = [], ca = un.length; ca--; ) typeof (Ir = un.shift()) == "string" ? Nr.push(Oi(Ir)[0]) : Array.isArray(Ir) && typeof Ir[0] == "string" && ($i = Oi(Ir[0], Ir[1], Ir[2]), Nr.push([$i[0], $i[1], $i[2]]));
        gr = Nr;
      }
      return gr;
    }
    var ra = !1, rs = !0;
    if (typeof T == "string") ra = !0;
    else if (Array.isArray(T)) {
      var vs = T.concat();
      ye = [];
      for (var jr, Lr = vs.length; Lr--; ) (typeof (jr = vs.shift()) != "string" || Array.isArray(jr) && typeof jr[0] != "string") && (rs = !1);
      ra = rs;
    }
    if (ra === !1) throw new Error('Type of text must be string or Array. "' + T + '" is not recognized.');
    typeof T == "string" && (T = T.match(/[\r?\n]/) ? T.split(/\r\n|\r|\n/g) : [T]);
    var na = _e / Ai.internal.scaleFactor, sa = na * (Ci - 1);
    switch (Ct.baseline) {
      case "bottom":
        ft -= sa;
        break;
      case "top":
        ft += na - sa;
        break;
      case "hanging":
        ft += na - 2 * sa;
        break;
      case "middle":
        ft += na / 2 - sa;
    }
    if ((gi = Ct.maxWidth || 0) > 0 && (typeof T == "string" ? T = Ai.splitTextToSize(T, gi) : Object.prototype.toString.call(T) === "[object Array]" && (T = T.reduce(function(Ii, Oi) {
      return Ii.concat(Ai.splitTextToSize(Oi, gi));
    }, []))), Yt = { text: T, x: H, y: ft, options: Ct, mutex: { pdfEscape: Rr, activeFontKey: oi, fonts: Ce, activeFontSize: _e } }, Z.publish("preProcessText", Yt), T = Yt.text, Be = (Ct = Yt.options).angle, !(vr instanceof At) && Be && typeof Be == "number") {
      Be *= Math.PI / 180, Ct.rotationDirection === 0 && (Be = -Be), zt === gt.ADVANCED && (Be = -Be);
      var Rn = Math.cos(Be), Rs = Math.sin(Be);
      vr = new At(Rn, Rs, -Rs, Rn, 0, 0);
    } else Be && Be instanceof At && (vr = Be);
    zt !== gt.ADVANCED || vr || (vr = Ut), (mi = Ct.charSpace || ea) !== void 0 && (Ye += Ot(lt(mi)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (Qi = Ct.horizontalScale) !== void 0 && (Ye += Ot(100 * Qi) + ` Tz
`), Ct.lang;
    var zr = -1, aa = Ct.renderingMode !== void 0 ? Ct.renderingMode : Ct.stroke, Os = Ai.internal.getCurrentPageInfo().pageContext;
    switch (aa) {
      case 0:
      case !1:
      case "fill":
        zr = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        zr = 1;
        break;
      case 2:
      case "fillThenStroke":
        zr = 2;
        break;
      case 3:
      case "invisible":
        zr = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        zr = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        zr = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        zr = 6;
        break;
      case 7:
      case "addToPathForClipping":
        zr = 7;
    }
    var Ia = Os.usedRenderingMode !== void 0 ? Os.usedRenderingMode : -1;
    zr !== -1 ? Ye += zr + ` Tr
` : Ia !== -1 && (Ye += `0 Tr
`), zr !== -1 && (Os.usedRenderingMode = zr), Je = Ct.align || "left";
    var qr, ns = _e * Ci, Go = Ai.internal.pageSize.getWidth(), oo = Ce[oi];
    mi = Ct.charSpace || ea, gi = Ct.maxWidth || 0, ki = Object.assign({ autoencode: !0, noBOM: !0 }, Ct.flags);
    var Pi = [], xs = function(Ii) {
      return Ai.getStringUnitWidth(Ii, { font: oo, charSpace: mi, fontSize: _e, doKerning: !1 }) * _e / Mi;
    };
    if (Object.prototype.toString.call(T) === "[object Array]") {
      var _n;
      ye = Fs(T), Je !== "left" && (qr = ye.map(xs));
      var Jr, In = 0;
      if (Je === "right") {
        H -= qr[0], T = [], Lr = ye.length;
        for (var bs = 0; bs < Lr; bs++) bs === 0 ? (Jr = Si(H), _n = Fn(ft)) : (Jr = lt(In - qr[bs]), _n = -ns), T.push([ye[bs], Jr, _n]), In = qr[bs];
      } else if (Je === "center") {
        H -= qr[0] / 2, T = [], Lr = ye.length;
        for (var On = 0; On < Lr; On++) On === 0 ? (Jr = Si(H), _n = Fn(ft)) : (Jr = lt((In - qr[On]) / 2), _n = -ns), T.push([ye[On], Jr, _n]), In = qr[On];
      } else if (Je === "left") {
        T = [], Lr = ye.length;
        for (var ka = 0; ka < Lr; ka++) T.push(ye[ka]);
      } else if (Je === "justify" && oo.encoding === "Identity-H") {
        T = [], Lr = ye.length, gi = gi !== 0 ? gi : Go;
        for (var ws = 0, ar = 0; ar < Lr; ar++) if (_n = ar === 0 ? Fn(ft) : -ns, Jr = ar === 0 ? Si(H) : ws, ar < Lr - 1) {
          var oa = lt((gi - qr[ar]) / (ye[ar].split(" ").length - 1)), Pr = ye[ar].split(" ");
          T.push([Pr[0] + " ", Jr, _n]), ws = 0;
          for (var Ur = 1; Ur < Pr.length; Ur++) {
            var ss = (xs(Pr[Ur - 1] + " " + Pr[Ur]) - xs(Pr[Ur])) * Mi + oa;
            Ur == Pr.length - 1 ? T.push([Pr[Ur], ss, 0]) : T.push([Pr[Ur] + " ", ss, 0]), ws -= ss;
          }
        } else T.push([ye[ar], Jr, _n]);
        T.push(["", ws, 0]);
      } else {
        if (Je !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (T = [], Lr = ye.length, gi = gi !== 0 ? gi : Go, ar = 0; ar < Lr; ar++) _n = ar === 0 ? Fn(ft) : -ns, Jr = ar === 0 ? Si(H) : 0, ar < Lr - 1 ? Pi.push(Ot(lt((gi - qr[ar]) / (ye[ar].split(" ").length - 1)))) : Pi.push(0), T.push([ye[ar], Jr, _n]);
      }
    }
    var lo = typeof Ct.R2L == "boolean" ? Ct.R2L : Ze;
    lo === !0 && (T = Bs(T, function(Ii, Oi, gr) {
      return [Ii.split("").reverse().join(""), Oi, gr];
    })), Yt = { text: T, x: H, y: ft, options: Ct, mutex: { pdfEscape: Rr, activeFontKey: oi, fonts: Ce, activeFontSize: _e } }, Z.publish("postProcessText", Yt), T = Yt.text, yn = Yt.mutex.isHex || !1;
    var Ss = Ce[oi].encoding;
    Ss !== "WinAnsiEncoding" && Ss !== "StandardEncoding" || (T = Bs(T, function(Ii, Oi, gr) {
      return [_s(Ii), Oi, gr];
    })), ye = Fs(T), T = [];
    for (var as, As, os, js = 0, co = 1, la = Array.isArray(ye[0]) ? co : js, ls = "", Ta = function(Ii, Oi, gr) {
      var Ir = "";
      return gr instanceof At ? (gr = typeof Ct.angle == "number" ? bt(gr, new At(1, 0, 0, 1, Ii, Oi)) : bt(new At(1, 0, 0, 1, Ii, Oi), gr), zt === gt.ADVANCED && (gr = bt(new At(1, 0, 0, -1, 0, 0), gr)), Ir = gr.join(" ") + ` Tm
`) : Ir = Ot(Ii) + " " + Ot(Oi) + ` Td
`, Ir;
    }, Qr = 0; Qr < ye.length; Qr++) {
      switch (ls = "", la) {
        case co:
          os = (yn ? "<" : "(") + ye[Qr][0] + (yn ? ">" : ")"), as = parseFloat(ye[Qr][1]), As = parseFloat(ye[Qr][2]);
          break;
        case js:
          os = (yn ? "<" : "(") + ye[Qr] + (yn ? ">" : ")"), as = Si(H), As = Fn(ft);
      }
      Pi !== void 0 && Pi[Qr] !== void 0 && (ls = Pi[Qr] + ` Tw
`), Qr === 0 ? T.push(ls + Ta(as, As, vr) + os) : la === js ? T.push(ls + os) : la === co && T.push(ls + Ta(as, As, vr) + os);
    }
    T = la === js ? T.join(` Tj
T* `) : T.join(` Tj
`), T += ` Tj
`;
    var tn = `BT
/`;
    return tn += oi + " " + _e + ` Tf
`, tn += Ot(_e * Ci) + ` TL
`, tn += Aa + `
`, tn += Ye, tn += T, Y(tn += "ET"), j[oi] = !0, Ai;
  };
  var Ha = F.__private__.clip = F.clip = function(T) {
    return Y(T === "evenodd" ? "W*" : "W"), this;
  };
  F.clipEvenOdd = function() {
    return Ha("evenodd");
  }, F.__private__.discardPath = F.discardPath = function() {
    return Y("n"), this;
  };
  var An = F.__private__.isValidStyle = function(T) {
    var H = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(T) !== -1 && (H = !0), H;
  };
  F.__private__.setDefaultPathOperation = F.setDefaultPathOperation = function(T) {
    return An(T) && (U = T), this;
  };
  var Oo = F.__private__.getStyle = F.getStyle = function(T) {
    var H = U;
    switch (T) {
      case "D":
      case "S":
        H = "S";
        break;
      case "F":
        H = "f";
        break;
      case "FD":
      case "DF":
        H = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        H = T;
    }
    return H;
  }, Ns = F.close = function() {
    return Y("h"), this;
  };
  F.stroke = function() {
    return Y("S"), this;
  }, F.fill = function(T) {
    return Ya("f", T), this;
  }, F.fillEvenOdd = function(T) {
    return Ya("f*", T), this;
  }, F.fillStroke = function(T) {
    return Ya("B", T), this;
  }, F.fillStrokeEvenOdd = function(T) {
    return Ya("B*", T), this;
  };
  var Ya = function(T, H) {
    nr(H) === "object" ? El(H, T) : Y(T);
  }, Ka = function(T) {
    T === null || zt === gt.ADVANCED && T === void 0 || (T = Oo(T), Y(T));
  };
  function hl(T, H, ft, Ct, Ft) {
    var Yt = new Cc(H || this.boundingBox, ft || this.xStep, Ct || this.yStep, this.gState, Ft || this.matrix);
    Yt.stream = this.stream;
    var ye = T + "$$" + this.cloneIndex++ + "$$";
    return te(ye, Yt), Yt;
  }
  var El = function(T, H) {
    var ft = Xr[T.key], Ct = Ee[ft];
    if (Ct instanceof Ql) Y("q"), Y(zl(H)), Ct.gState && F.setGState(Ct.gState), Y(T.matrix.toString() + " cm"), Y("/" + ft + " sh"), Y("Q");
    else if (Ct instanceof Cc) {
      var Ft = new At(1, 0, 0, -1, 0, ia());
      T.matrix && (Ft = Ft.multiply(T.matrix || Ut), ft = hl.call(Ct, T.key, T.boundingBox, T.xStep, T.yStep, Ft).id), Y("q"), Y("/Pattern cs"), Y("/" + ft + " scn"), Ct.gState && F.setGState(Ct.gState), Y(H), Y("Q");
    }
  }, zl = function(T) {
    switch (T) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, Ja = F.moveTo = function(T, H) {
    return Y(Ot(lt(T)) + " " + Ot(St(H)) + " m"), this;
  }, ts = F.lineTo = function(T, H) {
    return Y(Ot(lt(T)) + " " + Ot(St(H)) + " l"), this;
  }, ms = F.curveTo = function(T, H, ft, Ct, Ft, Yt) {
    return Y([Ot(lt(T)), Ot(St(H)), Ot(lt(ft)), Ot(St(Ct)), Ot(lt(Ft)), Ot(St(Yt)), "c"].join(" ")), this;
  };
  F.__private__.line = F.line = function(T, H, ft, Ct, Ft) {
    if (isNaN(T) || isNaN(H) || isNaN(ft) || isNaN(Ct) || !An(Ft)) throw new Error("Invalid arguments passed to jsPDF.line");
    return zt === gt.COMPAT ? this.lines([[ft - T, Ct - H]], T, H, [1, 1], Ft || "S") : this.lines([[ft - T, Ct - H]], T, H, [1, 1]).stroke();
  }, F.__private__.lines = F.lines = function(T, H, ft, Ct, Ft, Yt) {
    var ye, Be, Je, mi, gi, ki, Qi, vr, Ai, Kr, Ye, yn;
    if (typeof T == "number" && (yn = ft, ft = H, H = T, T = yn), Ct = Ct || [1, 1], Yt = Yt || !1, isNaN(H) || isNaN(ft) || !Array.isArray(T) || !Array.isArray(Ct) || !An(Ft) || typeof Yt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (Ja(H, ft), ye = Ct[0], Be = Ct[1], mi = T.length, Kr = H, Ye = ft, Je = 0; Je < mi; Je++) (gi = T[Je]).length === 2 ? (Kr = gi[0] * ye + Kr, Ye = gi[1] * Be + Ye, ts(Kr, Ye)) : (ki = gi[0] * ye + Kr, Qi = gi[1] * Be + Ye, vr = gi[2] * ye + Kr, Ai = gi[3] * Be + Ye, Kr = gi[4] * ye + Kr, Ye = gi[5] * Be + Ye, ms(ki, Qi, vr, Ai, Kr, Ye));
    return Yt && Ns(), Ka(Ft), this;
  }, F.path = function(T) {
    for (var H = 0; H < T.length; H++) {
      var ft = T[H], Ct = ft.c;
      switch (ft.op) {
        case "m":
          Ja(Ct[0], Ct[1]);
          break;
        case "l":
          ts(Ct[0], Ct[1]);
          break;
        case "c":
          ms.apply(this, Ct);
          break;
        case "h":
          Ns();
      }
    }
    return this;
  }, F.__private__.rect = F.rect = function(T, H, ft, Ct, Ft) {
    if (isNaN(T) || isNaN(H) || isNaN(ft) || isNaN(Ct) || !An(Ft)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return zt === gt.COMPAT && (Ct = -Ct), Y([Ot(lt(T)), Ot(St(H)), Ot(lt(ft)), Ot(lt(Ct)), "re"].join(" ")), Ka(Ft), this;
  }, F.__private__.triangle = F.triangle = function(T, H, ft, Ct, Ft, Yt, ye) {
    if (isNaN(T) || isNaN(H) || isNaN(ft) || isNaN(Ct) || isNaN(Ft) || isNaN(Yt) || !An(ye)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[ft - T, Ct - H], [Ft - ft, Yt - Ct], [T - Ft, H - Yt]], T, H, [1, 1], ye, !0), this;
  }, F.__private__.roundedRect = F.roundedRect = function(T, H, ft, Ct, Ft, Yt, ye) {
    if (isNaN(T) || isNaN(H) || isNaN(ft) || isNaN(Ct) || isNaN(Ft) || isNaN(Yt) || !An(ye)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Be = 4 / 3 * (Math.SQRT2 - 1);
    return Ft = Math.min(Ft, 0.5 * ft), Yt = Math.min(Yt, 0.5 * Ct), this.lines([[ft - 2 * Ft, 0], [Ft * Be, 0, Ft, Yt - Yt * Be, Ft, Yt], [0, Ct - 2 * Yt], [0, Yt * Be, -Ft * Be, Yt, -Ft, Yt], [2 * Ft - ft, 0], [-Ft * Be, 0, -Ft, -Yt * Be, -Ft, -Yt], [0, 2 * Yt - Ct], [0, -Yt * Be, Ft * Be, -Yt, Ft, -Yt]], T + Ft, H, [1, 1], ye, !0), this;
  }, F.__private__.ellipse = F.ellipse = function(T, H, ft, Ct, Ft) {
    if (isNaN(T) || isNaN(H) || isNaN(ft) || isNaN(Ct) || !An(Ft)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var Yt = 4 / 3 * (Math.SQRT2 - 1) * ft, ye = 4 / 3 * (Math.SQRT2 - 1) * Ct;
    return Ja(T + ft, H), ms(T + ft, H - ye, T + Yt, H - Ct, T, H - Ct), ms(T - Yt, H - Ct, T - ft, H - ye, T - ft, H), ms(T - ft, H + ye, T - Yt, H + Ct, T, H + Ct), ms(T + Yt, H + Ct, T + ft, H + ye, T + ft, H), Ka(Ft), this;
  }, F.__private__.circle = F.circle = function(T, H, ft, Ct) {
    if (isNaN(T) || isNaN(H) || isNaN(ft) || !An(Ct)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(T, H, ft, ft, Ct);
  }, F.setFont = function(T, H, ft) {
    return ft && (H = pe(H, ft)), oi = zs(T, H, { disableWarning: !1 }), this;
  };
  var Qa = F.__private__.getFont = F.getFont = function() {
    return Ce[zs.apply(F, arguments)];
  };
  F.__private__.getFontList = F.getFontList = function() {
    var T, H, ft = {};
    for (T in zi) if (zi.hasOwnProperty(T)) for (H in ft[T] = [], zi[T]) zi[T].hasOwnProperty(H) && ft[T].push(H);
    return ft;
  }, F.addFont = function(T, H, ft, Ct, Ft) {
    var Yt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && Yt.indexOf(arguments[3]) !== -1 ? Ft = arguments[3] : arguments[3] && Yt.indexOf(arguments[3]) == -1 && (ft = pe(ft, Ct)), Ft = Ft || "Identity-H", cn.call(this, T, H, ft, Ft);
  };
  var Ds, Sa = x.lineWidth || 0.200025, hn = F.__private__.getLineWidth = F.getLineWidth = function() {
    return Sa;
  }, ul = F.__private__.setLineWidth = F.setLineWidth = function(T) {
    return Sa = T, Y(Ot(lt(T)) + " w"), this;
  };
  F.__private__.setLineDash = _i.API.setLineDash = _i.API.setLineDashPattern = function(T, H) {
    if (T = T || [], H = H || 0, isNaN(H) || !Array.isArray(T)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return T = T.map(function(ft) {
      return Ot(lt(ft));
    }).join(" "), H = Ot(lt(H)), Y("[" + T + "] " + H + " d"), this;
  };
  var to = F.__private__.getLineHeight = F.getLineHeight = function() {
    return _e * Ds;
  };
  F.__private__.getLineHeight = F.getLineHeight = function() {
    return _e * Ds;
  };
  var gs = F.__private__.setLineHeightFactor = F.setLineHeightFactor = function(T) {
    return typeof (T = T || 1.15) == "number" && (Ds = T), this;
  }, es = F.__private__.getLineHeightFactor = F.getLineHeightFactor = function() {
    return Ds;
  };
  gs(x.lineHeight);
  var Si = F.__private__.getHorizontalCoordinate = function(T) {
    return lt(T);
  }, Fn = F.__private__.getVerticalCoordinate = function(T) {
    return zt === gt.ADVANCED ? T : V[pt].mediaBox.topRightY - V[pt].mediaBox.bottomLeftY - lt(T);
  }, Nl = F.__private__.getHorizontalCoordinateString = F.getHorizontalCoordinateString = function(T) {
    return Ot(Si(T));
  }, Pn = F.__private__.getVerticalCoordinateString = F.getVerticalCoordinateString = function(T) {
    return Ot(Fn(T));
  }, is = x.strokeColor || "0 G";
  F.__private__.getStrokeColor = F.getDrawColor = function() {
    return yi(is);
  }, F.__private__.setStrokeColor = F.setDrawColor = function(T, H, ft, Ct) {
    return is = pi({ ch1: T, ch2: H, ch3: ft, ch4: Ct, pdfColorType: "draw", precision: 2 }), Y(is), this;
  };
  var eo = x.fillColor || "0 g";
  F.__private__.getFillColor = F.getFillColor = function() {
    return yi(eo);
  }, F.__private__.setFillColor = F.setFillColor = function(T, H, ft, Ct) {
    return eo = pi({ ch1: T, ch2: H, ch3: ft, ch4: Ct, pdfColorType: "fill", precision: 2 }), Y(eo), this;
  };
  var Aa = x.textColor || "0 g", dl = F.__private__.getTextColor = F.getTextColor = function() {
    return yi(Aa);
  };
  F.__private__.setTextColor = F.setTextColor = function(T, H, ft, Ct) {
    return Aa = pi({ ch1: T, ch2: H, ch3: ft, ch4: Ct, pdfColorType: "text", precision: 3 }), this;
  };
  var ea = x.charSpace, pl = F.__private__.getCharSpace = F.getCharSpace = function() {
    return parseFloat(ea || 0);
  };
  F.__private__.setCharSpace = F.setCharSpace = function(T) {
    if (isNaN(T)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return ea = T, this;
  };
  var io = 0;
  F.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, F.__private__.setLineCap = F.setLineCap = function(T) {
    var H = F.CapJoinStyles[T];
    if (H === void 0) throw new Error("Line cap style of '" + T + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return io = H, Y(H + " J"), this;
  };
  var ro = 0;
  F.__private__.setLineJoin = F.setLineJoin = function(T) {
    var H = F.CapJoinStyles[T];
    if (H === void 0) throw new Error("Line join style of '" + T + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return ro = H, Y(H + " j"), this;
  }, F.__private__.setLineMiterLimit = F.__private__.setMiterLimit = F.setLineMiterLimit = F.setMiterLimit = function(T) {
    if (T = T || 0, isNaN(T)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return Y(Ot(lt(T)) + " M"), this;
  }, F.GState = Uh, F.setGState = function(T) {
    (T = typeof T == "string" ? Vi[Mr[T]] : jo(null, T)).equals(Er) || (Y("/" + T.id + " gs"), Er = T);
  };
  var jo = function(T, H) {
    if (!T || !Mr[T]) {
      var ft = !1;
      for (var Ct in Vi) if (Vi.hasOwnProperty(Ct) && Vi[Ct].equals(H)) {
        ft = !0;
        break;
      }
      if (ft) H = Vi[Ct];
      else {
        var Ft = "GS" + (Object.keys(Vi).length + 1).toString(10);
        Vi[Ft] = H, H.id = Ft;
      }
      return T && (Mr[T] = H.id), Z.publish("addGState", H), H;
    }
  };
  F.addGState = function(T, H) {
    return jo(T, H), this;
  }, F.saveGraphicsState = function() {
    return Y("q"), Sr.push({ key: oi, size: _e, color: Aa }), this;
  }, F.restoreGraphicsState = function() {
    Y("Q");
    var T = Sr.pop();
    return oi = T.key, _e = T.size, Aa = T.color, Er = null, this;
  }, F.setCurrentTransformationMatrix = function(T) {
    return Y(T.toString() + " cm"), this;
  }, F.comment = function(T) {
    return Y("#" + T), this;
  };
  var Bn = function(T, H) {
    var ft = T || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return ft;
    }, set: function(Yt) {
      isNaN(Yt) || (ft = parseFloat(Yt));
    } });
    var Ct = H || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return Ct;
    }, set: function(Yt) {
      isNaN(Yt) || (Ct = parseFloat(Yt));
    } });
    var Ft = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return Ft;
    }, set: function(Yt) {
      Ft = Yt.toString();
    } }), this;
  }, no = function(T, H, ft, Ct) {
    Bn.call(this, T, H), this.type = "rect";
    var Ft = ft || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return Ft;
    }, set: function(ye) {
      isNaN(ye) || (Ft = parseFloat(ye));
    } });
    var Yt = Ct || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return Yt;
    }, set: function(ye) {
      isNaN(ye) || (Yt = parseFloat(ye));
    } }), this;
  }, qo = function() {
    this.page = ut, this.currentPage = pt, this.pages = be.slice(0), this.pagesContext = V.slice(0), this.x = cr, this.y = le, this.matrix = si, this.width = ys(pt), this.height = ia(pt), this.outputDestination = Pe, this.id = "", this.objectNumber = -1;
  };
  qo.prototype.restore = function() {
    ut = this.page, pt = this.currentPage, V = this.pagesContext, be = this.pages, cr = this.x, le = this.y, si = this.matrix, Vo(pt, this.width), ao(pt, this.height), Pe = this.outputDestination;
  };
  var Uo = function(T, H, ft, Ct, Ft) {
    Mt.push(new qo()), ut = pt = 0, be = [], cr = T, le = H, si = Ft, Jn([ft, Ct]);
  }, Pa = function(T) {
    if (Pt[T]) Mt.pop().restore();
    else {
      var H = new qo(), ft = "Xo" + (Object.keys(ct).length + 1).toString(10);
      H.id = ft, Pt[T] = ft, ct[ft] = H, Z.publish("addFormObject", H), Mt.pop().restore();
    }
  };
  for (var so in F.beginFormObject = function(T, H, ft, Ct, Ft) {
    return Uo(T, H, ft, Ct, Ft), this;
  }, F.endFormObject = function(T) {
    return Pa(T), this;
  }, F.doFormObject = function(T, H) {
    var ft = ct[Pt[T]];
    return Y("q"), Y(H.toString() + " cm"), Y("/" + ft.id + " Do"), Y("Q"), this;
  }, F.getFormObject = function(T) {
    var H = ct[Pt[T]];
    return { x: H.x, y: H.y, width: H.width, height: H.height, matrix: H.matrix };
  }, F.save = function(T, H) {
    return T = T || "generated.pdf", (H = H || {}).returnPromise = H.returnPromise || !1, H.returnPromise === !1 ? (Jl(Wa(fs()), T), typeof Jl.unload == "function" && vi.setTimeout && setTimeout(Jl.unload, 911), this) : new Promise(function(ft, Ct) {
      try {
        var Ft = Jl(Wa(fs()), T);
        typeof Jl.unload == "function" && vi.setTimeout && setTimeout(Jl.unload, 911), ft(Ft);
      } catch (Yt) {
        Ct(Yt.message);
      }
    });
  }, _i.API) _i.API.hasOwnProperty(so) && (so === "events" && _i.API.events.length ? function(T, H) {
    var ft, Ct, Ft;
    for (Ft = H.length - 1; Ft !== -1; Ft--) ft = H[Ft][0], Ct = H[Ft][1], T.subscribe.apply(T, [ft].concat(typeof Ct == "function" ? [Ct] : Ct));
  }(Z, _i.API.events) : F[so] = _i.API[so]);
  var ys = F.getPageWidth = function(T) {
    return (V[T = T || pt].mediaBox.topRightX - V[T].mediaBox.bottomLeftX) / Te;
  }, Vo = F.setPageWidth = function(T, H) {
    V[T].mediaBox.topRightX = H * Te + V[T].mediaBox.bottomLeftX;
  }, ia = F.getPageHeight = function(T) {
    return (V[T = T || pt].mediaBox.topRightY - V[T].mediaBox.bottomLeftY) / Te;
  }, ao = F.setPageHeight = function(T, H) {
    V[T].mediaBox.topRightY = H * Te + V[T].mediaBox.bottomLeftY;
  };
  return F.internal = { pdfEscape: Rr, getStyle: Oo, getFont: Qa, getFontSize: ke, getCharSpace: pl, getTextColor: dl, getLineHeight: to, getLineHeightFactor: es, getLineWidth: hn, write: ui, getHorizontalCoordinate: Si, getVerticalCoordinate: Fn, getCoordinateString: Nl, getVerticalCoordinateString: Pn, collections: {}, newObject: Bt, newAdditionalObject: $e, newObjectDeferred: me, newObjectDeferredBegin: Ne, getFilters: Zi, putStream: Bi, events: Z, scaleFactor: Te, pageSize: { getWidth: function() {
    return ys(pt);
  }, setWidth: function(T) {
    Vo(pt, T);
  }, getHeight: function() {
    return ia(pt);
  }, setHeight: function(T) {
    ao(pt, T);
  } }, encryptionOptions: X, encryption: mr, getEncryptor: wa, output: ba, getNumberOfPages: Bo, pages: be, out: Y, f2: ae, f3: at, getPageInfo: Or, getPageInfoByObjId: He, getCurrentPageInfo: Xa, getPDFVersion: ot, Point: Bn, Rectangle: no, Matrix: At, hasHotfix: cl }, Object.defineProperty(F.internal.pageSize, "width", { get: function() {
    return ys(pt);
  }, set: function(T) {
    Vo(pt, T);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(F.internal.pageSize, "height", { get: function() {
    return ia(pt);
  }, set: function(T) {
    ao(pt, T);
  }, enumerable: !0, configurable: !0 }), Fo.call(F, se), oi = "F1", Qn(k, y), Z.publish("initialized"), F;
}
Tc.prototype.lsbFirstWord = function(x) {
  return String.fromCharCode(x >> 0 & 255, x >> 8 & 255, x >> 16 & 255, x >> 24 & 255);
}, Tc.prototype.toHexString = function(x) {
  return x.split("").map(function(f) {
    return ("0" + (255 & f.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, Tc.prototype.hexToBytes = function(x) {
  for (var f = [], y = 0; y < x.length; y += 2) f.push(String.fromCharCode(parseInt(x.substr(y, 2), 16)));
  return f.join("");
}, Tc.prototype.processOwnerPassword = function(x, f) {
  return Xu(Wu(f).substr(0, 5), x);
}, Tc.prototype.encryptor = function(x, f) {
  var y = Wu(this.encryptionKey + String.fromCharCode(255 & x, x >> 8 & 255, x >> 16 & 255, 255 & f, f >> 8 & 255)).substr(0, 10);
  return function(b) {
    return Xu(y, b);
  };
}, Uh.prototype.equals = function(x) {
  var f, y = "id,objectNumber,equals";
  if (!x || nr(x) !== nr(this)) return !1;
  var b = 0;
  for (f in this) if (!(y.indexOf(f) >= 0)) {
    if (this.hasOwnProperty(f) && !x.hasOwnProperty(f) || this[f] !== x[f]) return !1;
    b++;
  }
  for (f in x) x.hasOwnProperty(f) && y.indexOf(f) < 0 && b--;
  return b === 0;
}, _i.API = { events: [] }, _i.version = "2.5.2";
var Br = _i.API, td = 1, rc = function(x) {
  return x.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, Ic = function(x) {
  return x.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, Ti = function(x) {
  return x.toFixed(2);
}, Tl = function(x) {
  return x.toFixed(5);
};
Br.__acroform__ = {};
var Ms = function(x, f) {
  x.prototype = Object.create(f.prototype), x.prototype.constructor = x;
}, Bp = function(x) {
  return x * td;
}, Co = function(x) {
  var f = new ff(), y = Xe.internal.getHeight(x) || 0, b = Xe.internal.getWidth(x) || 0;
  return f.BBox = [0, 0, Number(Ti(b)), Number(Ti(y))], f;
}, Jg = Br.__acroform__.setBit = function(x, f) {
  if (x = x || 0, f = f || 0, isNaN(x) || isNaN(f)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return x |= 1 << f;
}, Qg = Br.__acroform__.clearBit = function(x, f) {
  if (x = x || 0, f = f || 0, isNaN(x) || isNaN(f)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return x &= ~(1 << f);
}, t0 = Br.__acroform__.getBit = function(x, f) {
  if (isNaN(x) || isNaN(f)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return x & 1 << f ? 1 : 0;
}, $r = Br.__acroform__.getBitForPdf = function(x, f) {
  if (isNaN(x) || isNaN(f)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return t0(x, f - 1);
}, Zr = Br.__acroform__.setBitForPdf = function(x, f) {
  if (isNaN(x) || isNaN(f)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return Jg(x, f - 1);
}, Wr = Br.__acroform__.clearBitForPdf = function(x, f) {
  if (isNaN(x) || isNaN(f)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Qg(x, f - 1);
}, e0 = Br.__acroform__.calculateCoordinates = function(x, f) {
  var y = f.internal.getHorizontalCoordinate, b = f.internal.getVerticalCoordinate, k = x[0], P = x[1], v = x[2], c = x[3], z = {};
  return z.lowerLeft_X = y(k) || 0, z.lowerLeft_Y = b(P + c) || 0, z.upperRight_X = y(k + v) || 0, z.upperRight_Y = b(P) || 0, [Number(Ti(z.lowerLeft_X)), Number(Ti(z.lowerLeft_Y)), Number(Ti(z.upperRight_X)), Number(Ti(z.upperRight_Y))];
}, i0 = function(x) {
  if (x.appearanceStreamContent) return x.appearanceStreamContent;
  if (x.V || x.DV) {
    var f = [], y = x._V || x.DV, b = Hu(x, y), k = x.scope.internal.getFont(x.fontName, x.fontStyle).id;
    f.push("/Tx BMC"), f.push("q"), f.push("BT"), f.push(x.scope.__private__.encodeColorString(x.color)), f.push("/" + k + " " + Ti(b.fontSize) + " Tf"), f.push("1 0 0 1 0 0 Tm"), f.push(b.text), f.push("ET"), f.push("Q"), f.push("EMC");
    var P = Co(x);
    return P.scope = x.scope, P.stream = f.join(`
`), P;
  }
}, Hu = function(x, f) {
  var y = x.fontSize === 0 ? x.maxFontSize : x.fontSize, b = { text: "", fontSize: "" }, k = (f = (f = f.substr(0, 1) == "(" ? f.substr(1) : f).substr(f.length - 1) == ")" ? f.substr(0, f.length - 1) : f).split(" ");
  k = x.multiline ? k.map(function(at) {
    return at.split(`
`);
  }) : k.map(function(at) {
    return [at];
  });
  var P = y, v = Xe.internal.getHeight(x) || 0;
  v = v < 0 ? -v : v;
  var c = Xe.internal.getWidth(x) || 0;
  c = c < 0 ? -c : c;
  var z = function(at, lt, It) {
    if (at + 1 < k.length) {
      var St = lt + " " + k[at + 1][0];
      return Dh(St, x, It).width <= c - 4;
    }
    return !1;
  };
  P++;
  t: for (; P > 0; ) {
    f = "", P--;
    var U, X, O = Dh("3", x, P).height, j = x.multiline ? v - P : (v - O) / 2, F = j += 2, mt = 0, ot = 0, yt = 0;
    if (P <= 0) {
      f = `(...) Tj
`, f += "% Width of Text: " + Dh(f, x, P = 12).width + ", FieldWidth:" + c + `
`;
      break;
    }
    for (var st = "", gt = 0, zt = 0; zt < k.length; zt++) if (k.hasOwnProperty(zt)) {
      var Jt = !1;
      if (k[zt].length !== 1 && yt !== k[zt].length - 1) {
        if ((O + 2) * (gt + 2) + 2 > v) continue t;
        st += k[zt][yt], Jt = !0, ot = zt, zt--;
      } else {
        st = (st += k[zt][yt] + " ").substr(st.length - 1) == " " ? st.substr(0, st.length - 1) : st;
        var Kt = parseInt(zt), pe = z(Kt, st, P), Ot = zt >= k.length - 1;
        if (pe && !Ot) {
          st += " ", yt = 0;
          continue;
        }
        if (pe || Ot) {
          if (Ot) ot = Kt;
          else if (x.multiline && (O + 2) * (gt + 2) + 2 > v) continue t;
        } else {
          if (!x.multiline || (O + 2) * (gt + 2) + 2 > v) continue t;
          ot = Kt;
        }
      }
      for (var kt = "", $t = mt; $t <= ot; $t++) {
        var ae = k[$t];
        if (x.multiline) {
          if ($t === ot) {
            kt += ae[yt] + " ", yt = (yt + 1) % ae.length;
            continue;
          }
          if ($t === mt) {
            kt += ae[ae.length - 1] + " ";
            continue;
          }
        }
        kt += ae[0] + " ";
      }
      switch (kt = kt.substr(kt.length - 1) == " " ? kt.substr(0, kt.length - 1) : kt, X = Dh(kt, x, P).width, x.textAlign) {
        case "right":
          U = c - X - 2;
          break;
        case "center":
          U = (c - X) / 2;
          break;
        case "left":
        default:
          U = 2;
      }
      f += Ti(U) + " " + Ti(F) + ` Td
`, f += "(" + rc(kt) + `) Tj
`, f += -Ti(U) + ` 0 Td
`, F = -(P + 2), X = 0, mt = Jt ? ot : ot + 1, gt++, st = "";
    }
    break;
  }
  return b.text = f, b.fontSize = P, b;
}, Dh = function(x, f, y) {
  var b = f.scope.internal.getFont(f.fontName, f.fontStyle), k = f.scope.getStringUnitWidth(x, { font: b, fontSize: parseFloat(y), charSpace: 0 }) * parseFloat(y);
  return { height: f.scope.getStringUnitWidth("3", { font: b, fontSize: parseFloat(y), charSpace: 0 }) * parseFloat(y) * 1.5, width: k };
}, r0 = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, n0 = function(x, f) {
  var y = { type: "reference", object: x };
  f.internal.getPageInfo(x.page).pageContext.annotations.find(function(b) {
    return b.type === y.type && b.object === y.object;
  }) === void 0 && f.internal.getPageInfo(x.page).pageContext.annotations.push(y);
}, s0 = function(x, f) {
  for (var y in x) if (x.hasOwnProperty(y)) {
    var b = y, k = x[y];
    f.internal.newObjectDeferredBegin(k.objId, !0), nr(k) === "object" && typeof k.putStream == "function" && k.putStream(), delete x[b];
  }
}, a0 = function(x, f) {
  if (f.scope = x, x.internal !== void 0 && (x.internal.acroformPlugin === void 0 || x.internal.acroformPlugin.isInitialized === !1)) {
    if (Ua.FieldNum = 0, x.internal.acroformPlugin = JSON.parse(JSON.stringify(r0)), x.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    td = x.internal.scaleFactor, x.internal.acroformPlugin.acroFormDictionaryRoot = new mf(), x.internal.acroformPlugin.acroFormDictionaryRoot.scope = x, x.internal.acroformPlugin.acroFormDictionaryRoot._eventID = x.internal.events.subscribe("postPutResources", function() {
      (function(y) {
        y.internal.events.unsubscribe(y.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete y.internal.acroformPlugin.acroFormDictionaryRoot._eventID, y.internal.acroformPlugin.printedOut = !0;
      })(x);
    }), x.internal.events.subscribe("buildDocument", function() {
      (function(y) {
        y.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var b = y.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var k in b) if (b.hasOwnProperty(k)) {
          var P = b[k];
          P.objId = void 0, P.hasAnnotation && n0(P, y);
        }
      })(x);
    }), x.internal.events.subscribe("putCatalog", function() {
      (function(y) {
        if (y.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        y.internal.write("/AcroForm " + y.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(x);
    }), x.internal.events.subscribe("postPutPages", function(y) {
      (function(b, k) {
        var P = !b;
        for (var v in b || (k.internal.newObjectDeferredBegin(k.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), k.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), b = b || k.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (b.hasOwnProperty(v)) {
          var c = b[v], z = [], U = c.Rect;
          if (c.Rect && (c.Rect = e0(c.Rect, k)), k.internal.newObjectDeferredBegin(c.objId, !0), c.DA = Xe.createDefaultAppearanceStream(c), nr(c) === "object" && typeof c.getKeyValueListForStream == "function" && (z = c.getKeyValueListForStream()), c.Rect = U, c.hasAppearanceStream && !c.appearanceStreamContent) {
            var X = i0(c);
            z.push({ key: "AP", value: "<</N " + X + ">>" }), k.internal.acroformPlugin.xForms.push(X);
          }
          if (c.appearanceStreamContent) {
            var O = "";
            for (var j in c.appearanceStreamContent) if (c.appearanceStreamContent.hasOwnProperty(j)) {
              var F = c.appearanceStreamContent[j];
              if (O += "/" + j + " ", O += "<<", Object.keys(F).length >= 1 || Array.isArray(F)) {
                for (var v in F) if (F.hasOwnProperty(v)) {
                  var mt = F[v];
                  typeof mt == "function" && (mt = mt.call(k, c)), O += "/" + v + " " + mt + " ", k.internal.acroformPlugin.xForms.indexOf(mt) >= 0 || k.internal.acroformPlugin.xForms.push(mt);
                }
              } else typeof (mt = F) == "function" && (mt = mt.call(k, c)), O += "/" + v + " " + mt, k.internal.acroformPlugin.xForms.indexOf(mt) >= 0 || k.internal.acroformPlugin.xForms.push(mt);
              O += ">>";
            }
            z.push({ key: "AP", value: `<<
` + O + ">>" });
          }
          k.internal.putStream({ additionalKeyValues: z, objectId: c.objId }), k.internal.out("endobj");
        }
        P && s0(k.internal.acroformPlugin.xForms, k);
      })(y, x);
    }), x.internal.acroformPlugin.isInitialized = !0;
  }
}, pf = Br.__acroform__.arrayToPdfArray = function(x, f, y) {
  var b = function(v) {
    return v;
  };
  if (Array.isArray(x)) {
    for (var k = "[", P = 0; P < x.length; P++) switch (P !== 0 && (k += " "), nr(x[P])) {
      case "boolean":
      case "number":
      case "object":
        k += x[P].toString();
        break;
      case "string":
        x[P].substr(0, 1) !== "/" ? (f !== void 0 && y && (b = y.internal.getEncryptor(f)), k += "(" + rc(b(x[P].toString())) + ")") : k += x[P].toString();
    }
    return k += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Ou = function(x, f, y) {
  var b = function(k) {
    return k;
  };
  return f !== void 0 && y && (b = y.internal.getEncryptor(f)), (x = x || "").toString(), x = "(" + rc(b(x)) + ")";
}, Mo = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(x) {
    this._objId = x;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
Mo.prototype.toString = function() {
  return this.objId + " 0 R";
}, Mo.prototype.putStream = function() {
  var x = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: x, objectId: this.objId }), this.scope.internal.out("endobj");
}, Mo.prototype.getKeyValueListForStream = function() {
  var x = [], f = Object.getOwnPropertyNames(this).filter(function(P) {
    return P != "content" && P != "appearanceStreamContent" && P != "scope" && P != "objId" && P.substring(0, 1) != "_";
  });
  for (var y in f) if (Object.getOwnPropertyDescriptor(this, f[y]).configurable === !1) {
    var b = f[y], k = this[b];
    k && (Array.isArray(k) ? x.push({ key: b, value: pf(k, this.objId, this.scope) }) : k instanceof Mo ? (k.scope = this.scope, x.push({ key: b, value: k.objId + " 0 R" })) : typeof k != "function" && x.push({ key: b, value: k }));
  }
  return x;
};
var ff = function() {
  Mo.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var x, f = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return f;
  }, set: function(y) {
    f = y;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(y) {
    x = y.trim();
  }, get: function() {
    return x || null;
  } });
};
Ms(ff, Mo);
var mf = function() {
  Mo.call(this);
  var x, f = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return f.length > 0 ? f : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return f;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (x) {
      var y = function(b) {
        return b;
      };
      return this.scope && (y = this.scope.internal.getEncryptor(this.objId)), "(" + rc(y(x)) + ")";
    }
  }, set: function(y) {
    x = y;
  } });
};
Ms(mf, Mo);
var Ua = function x() {
  Mo.call(this);
  var f = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return f;
  }, set: function(st) {
    if (isNaN(st)) throw new Error('Invalid value "' + st + '" for attribute F supplied.');
    f = st;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(f, 3);
  }, set: function(st) {
    st ? this.F = Zr(f, 3) : this.F = Wr(f, 3);
  } });
  var y = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return y;
  }, set: function(st) {
    if (isNaN(st)) throw new Error('Invalid value "' + st + '" for attribute Ff supplied.');
    y = st;
  } });
  var b = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (b.length !== 0) return b;
  }, set: function(st) {
    b = st !== void 0 ? st : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !b || isNaN(b[0]) ? 0 : b[0];
  }, set: function(st) {
    b[0] = st;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !b || isNaN(b[1]) ? 0 : b[1];
  }, set: function(st) {
    b[1] = st;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !b || isNaN(b[2]) ? 0 : b[2];
  }, set: function(st) {
    b[2] = st;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !b || isNaN(b[3]) ? 0 : b[3];
  }, set: function(st) {
    b[3] = st;
  } });
  var k = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return k;
  }, set: function(st) {
    switch (st) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        k = st;
        break;
      default:
        throw new Error('Invalid value "' + st + '" for attribute FT supplied.');
    }
  } });
  var P = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!P || P.length < 1) {
      if (this instanceof Vh) return;
      P = "FieldObject" + x.FieldNum++;
    }
    var st = function(gt) {
      return gt;
    };
    return this.scope && (st = this.scope.internal.getEncryptor(this.objId)), "(" + rc(st(P)) + ")";
  }, set: function(st) {
    P = st.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return P;
  }, set: function(st) {
    P = st;
  } });
  var v = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return v;
  }, set: function(st) {
    v = st;
  } });
  var c = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return c;
  }, set: function(st) {
    c = st;
  } });
  var z = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return z;
  }, set: function(st) {
    z = st;
  } });
  var U = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return U === void 0 ? 50 / td : U;
  }, set: function(st) {
    U = st;
  } });
  var X = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return X;
  }, set: function(st) {
    X = st;
  } });
  var O = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!O || this instanceof Vh || this instanceof ec)) return Ou(O, this.objId, this.scope);
  }, set: function(st) {
    st = st.toString(), O = st;
  } });
  var j = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (j) return this instanceof Sn ? j : Ou(j, this.objId, this.scope);
  }, set: function(st) {
    st = st.toString(), j = this instanceof Sn ? st : st.substr(0, 1) === "(" ? Ic(st.substr(1, st.length - 2)) : Ic(st);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Sn ? Ic(j.substr(1, j.length - 1)) : j;
  }, set: function(st) {
    st = st.toString(), j = this instanceof Sn ? "/" + st : st;
  } });
  var F = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (F) return F;
  }, set: function(st) {
    this.V = st;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (F) return this instanceof Sn ? F : Ou(F, this.objId, this.scope);
  }, set: function(st) {
    st = st.toString(), F = this instanceof Sn ? st : st.substr(0, 1) === "(" ? Ic(st.substr(1, st.length - 2)) : Ic(st);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof Sn ? Ic(F.substr(1, F.length - 1)) : F;
  }, set: function(st) {
    st = st.toString(), F = this instanceof Sn ? "/" + st : st;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var mt, ot = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return ot;
  }, set: function(st) {
    st = !!st, ot = st;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (mt) return mt;
  }, set: function(st) {
    mt = st;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 1);
  }, set: function(st) {
    st ? this.Ff = Zr(this.Ff, 1) : this.Ff = Wr(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 2);
  }, set: function(st) {
    st ? this.Ff = Zr(this.Ff, 2) : this.Ff = Wr(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 3);
  }, set: function(st) {
    st ? this.Ff = Zr(this.Ff, 3) : this.Ff = Wr(this.Ff, 3);
  } });
  var yt = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (yt !== null) return yt;
  }, set: function(st) {
    if ([0, 1, 2].indexOf(st) === -1) throw new Error('Invalid value "' + st + '" for attribute Q supplied.');
    yt = st;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var st;
    switch (yt) {
      case 0:
      default:
        st = "left";
        break;
      case 1:
        st = "center";
        break;
      case 2:
        st = "right";
    }
    return st;
  }, configurable: !0, enumerable: !0, set: function(st) {
    switch (st) {
      case "right":
      case 2:
        yt = 2;
        break;
      case "center":
      case 1:
        yt = 1;
        break;
      case "left":
      case 0:
      default:
        yt = 0;
    }
  } });
};
Ms(Ua, Mo);
var Mc = function() {
  Ua.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var x = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return x;
  }, set: function(y) {
    x = y;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return x;
  }, set: function(y) {
    x = y;
  } });
  var f = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return pf(f, this.objId, this.scope);
  }, set: function(y) {
    var b, k;
    k = [], typeof (b = y) == "string" && (k = function(P, v, c) {
      c || (c = 1);
      for (var z, U = []; z = v.exec(P); ) U.push(z[c]);
      return U;
    }(b, /\((.*?)\)/g)), f = k;
  } }), this.getOptions = function() {
    return f;
  }, this.setOptions = function(y) {
    f = y, this.sort && f.sort();
  }, this.addOption = function(y) {
    y = (y = y || "").toString(), f.push(y), this.sort && f.sort();
  }, this.removeOption = function(y, b) {
    for (b = b || !1, y = (y = y || "").toString(); f.indexOf(y) !== -1 && (f.splice(f.indexOf(y), 1), b !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 18);
  }, set: function(y) {
    y ? this.Ff = Zr(this.Ff, 18) : this.Ff = Wr(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 19);
  }, set: function(y) {
    this.combo === !0 && (y ? this.Ff = Zr(this.Ff, 19) : this.Ff = Wr(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 20);
  }, set: function(y) {
    y ? (this.Ff = Zr(this.Ff, 20), f.sort()) : this.Ff = Wr(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 22);
  }, set: function(y) {
    y ? this.Ff = Zr(this.Ff, 22) : this.Ff = Wr(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 23);
  }, set: function(y) {
    y ? this.Ff = Zr(this.Ff, 23) : this.Ff = Wr(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 27);
  }, set: function(y) {
    y ? this.Ff = Zr(this.Ff, 27) : this.Ff = Wr(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Ms(Mc, Ua);
var Ec = function() {
  Mc.call(this), this.fontName = "helvetica", this.combo = !1;
};
Ms(Ec, Mc);
var zc = function() {
  Ec.call(this), this.combo = !0;
};
Ms(zc, Ec);
var Rh = function() {
  zc.call(this), this.edit = !0;
};
Ms(Rh, zc);
var Sn = function() {
  Ua.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 15);
  }, set: function(y) {
    y ? this.Ff = Zr(this.Ff, 15) : this.Ff = Wr(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 16);
  }, set: function(y) {
    y ? this.Ff = Zr(this.Ff, 16) : this.Ff = Wr(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 17);
  }, set: function(y) {
    y ? this.Ff = Zr(this.Ff, 17) : this.Ff = Wr(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 26);
  }, set: function(y) {
    y ? this.Ff = Zr(this.Ff, 26) : this.Ff = Wr(this.Ff, 26);
  } });
  var x, f = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var y = function(P) {
      return P;
    };
    if (this.scope && (y = this.scope.internal.getEncryptor(this.objId)), Object.keys(f).length !== 0) {
      var b, k = [];
      for (b in k.push("<<"), f) k.push("/" + b + " (" + rc(y(f[b])) + ")");
      return k.push(">>"), k.join(`
`);
    }
  }, set: function(y) {
    nr(y) === "object" && (f = y);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return f.CA || "";
  }, set: function(y) {
    typeof y == "string" && (f.CA = y);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return x;
  }, set: function(y) {
    x = y;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return x.substr(1, x.length - 1);
  }, set: function(y) {
    x = "/" + y;
  } });
};
Ms(Sn, Ua);
var Oh = function() {
  Sn.call(this), this.pushButton = !0;
};
Ms(Oh, Sn);
var Nc = function() {
  Sn.call(this), this.radio = !0, this.pushButton = !1;
  var x = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return x;
  }, set: function(f) {
    x = f !== void 0 ? f : [];
  } });
};
Ms(Nc, Sn);
var Vh = function() {
  var x, f;
  Ua.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return x;
  }, set: function(k) {
    x = k;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return f;
  }, set: function(k) {
    f = k;
  } });
  var y, b = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var k = function(c) {
      return c;
    };
    this.scope && (k = this.scope.internal.getEncryptor(this.objId));
    var P, v = [];
    for (P in v.push("<<"), b) v.push("/" + P + " (" + rc(k(b[P])) + ")");
    return v.push(">>"), v.join(`
`);
  }, set: function(k) {
    nr(k) === "object" && (b = k);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return b.CA || "";
  }, set: function(k) {
    typeof k == "string" && (b.CA = k);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return y;
  }, set: function(k) {
    y = k;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return y.substr(1, y.length - 1);
  }, set: function(k) {
    y = "/" + k;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Xe.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Ms(Vh, Ua), Nc.prototype.setAppearance = function(x) {
  if (!("createAppearanceStream" in x) || !("getCA" in x)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var f in this.Kids) if (this.Kids.hasOwnProperty(f)) {
    var y = this.Kids[f];
    y.appearanceStreamContent = x.createAppearanceStream(y.optionName), y.caption = x.getCA();
  }
}, Nc.prototype.createOption = function(x) {
  var f = new Vh();
  return f.Parent = this, f.optionName = x, this.Kids.push(f), o0.call(this.scope, f), f;
};
var jh = function() {
  Sn.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Xe.CheckBox.createAppearanceStream();
};
Ms(jh, Sn);
var ec = function() {
  Ua.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 13);
  }, set: function(f) {
    f ? this.Ff = Zr(this.Ff, 13) : this.Ff = Wr(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 21);
  }, set: function(f) {
    f ? this.Ff = Zr(this.Ff, 21) : this.Ff = Wr(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 23);
  }, set: function(f) {
    f ? this.Ff = Zr(this.Ff, 23) : this.Ff = Wr(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 24);
  }, set: function(f) {
    f ? this.Ff = Zr(this.Ff, 24) : this.Ff = Wr(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 25);
  }, set: function(f) {
    f ? this.Ff = Zr(this.Ff, 25) : this.Ff = Wr(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 26);
  }, set: function(f) {
    f ? this.Ff = Zr(this.Ff, 26) : this.Ff = Wr(this.Ff, 26);
  } });
  var x = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return x;
  }, set: function(f) {
    x = f;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return x;
  }, set: function(f) {
    Number.isInteger(f) && (x = f);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Ms(ec, Ua);
var qh = function() {
  ec.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!$r(this.Ff, 14);
  }, set: function(x) {
    x ? this.Ff = Zr(this.Ff, 14) : this.Ff = Wr(this.Ff, 14);
  } }), this.password = !0;
};
Ms(qh, ec);
var Xe = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: Xe.CheckBox.YesNormal }, D: { On: Xe.CheckBox.YesPushDown, Off: Xe.CheckBox.OffPushDown } };
}, YesPushDown: function(x) {
  var f = Co(x);
  f.scope = x.scope;
  var y = [], b = x.scope.internal.getFont(x.fontName, x.fontStyle).id, k = x.scope.__private__.encodeColorString(x.color), P = Hu(x, x.caption);
  return y.push("0.749023 g"), y.push("0 0 " + Ti(Xe.internal.getWidth(x)) + " " + Ti(Xe.internal.getHeight(x)) + " re"), y.push("f"), y.push("BMC"), y.push("q"), y.push("0 0 1 rg"), y.push("/" + b + " " + Ti(P.fontSize) + " Tf " + k), y.push("BT"), y.push(P.text), y.push("ET"), y.push("Q"), y.push("EMC"), f.stream = y.join(`
`), f;
}, YesNormal: function(x) {
  var f = Co(x);
  f.scope = x.scope;
  var y = x.scope.internal.getFont(x.fontName, x.fontStyle).id, b = x.scope.__private__.encodeColorString(x.color), k = [], P = Xe.internal.getHeight(x), v = Xe.internal.getWidth(x), c = Hu(x, x.caption);
  return k.push("1 g"), k.push("0 0 " + Ti(v) + " " + Ti(P) + " re"), k.push("f"), k.push("q"), k.push("0 0 1 rg"), k.push("0 0 " + Ti(v - 1) + " " + Ti(P - 1) + " re"), k.push("W"), k.push("n"), k.push("0 g"), k.push("BT"), k.push("/" + y + " " + Ti(c.fontSize) + " Tf " + b), k.push(c.text), k.push("ET"), k.push("Q"), f.stream = k.join(`
`), f;
}, OffPushDown: function(x) {
  var f = Co(x);
  f.scope = x.scope;
  var y = [];
  return y.push("0.749023 g"), y.push("0 0 " + Ti(Xe.internal.getWidth(x)) + " " + Ti(Xe.internal.getHeight(x)) + " re"), y.push("f"), f.stream = y.join(`
`), f;
} }, RadioButton: { Circle: { createAppearanceStream: function(x) {
  var f = { D: { Off: Xe.RadioButton.Circle.OffPushDown }, N: {} };
  return f.N[x] = Xe.RadioButton.Circle.YesNormal, f.D[x] = Xe.RadioButton.Circle.YesPushDown, f;
}, getCA: function() {
  return "l";
}, YesNormal: function(x) {
  var f = Co(x);
  f.scope = x.scope;
  var y = [], b = Xe.internal.getWidth(x) <= Xe.internal.getHeight(x) ? Xe.internal.getWidth(x) / 4 : Xe.internal.getHeight(x) / 4;
  b = Number((0.9 * b).toFixed(5));
  var k = Xe.internal.Bezier_C, P = Number((b * k).toFixed(5));
  return y.push("q"), y.push("1 0 0 1 " + Tl(Xe.internal.getWidth(x) / 2) + " " + Tl(Xe.internal.getHeight(x) / 2) + " cm"), y.push(b + " 0 m"), y.push(b + " " + P + " " + P + " " + b + " 0 " + b + " c"), y.push("-" + P + " " + b + " -" + b + " " + P + " -" + b + " 0 c"), y.push("-" + b + " -" + P + " -" + P + " -" + b + " 0 -" + b + " c"), y.push(P + " -" + b + " " + b + " -" + P + " " + b + " 0 c"), y.push("f"), y.push("Q"), f.stream = y.join(`
`), f;
}, YesPushDown: function(x) {
  var f = Co(x);
  f.scope = x.scope;
  var y = [], b = Xe.internal.getWidth(x) <= Xe.internal.getHeight(x) ? Xe.internal.getWidth(x) / 4 : Xe.internal.getHeight(x) / 4;
  b = Number((0.9 * b).toFixed(5));
  var k = Number((2 * b).toFixed(5)), P = Number((k * Xe.internal.Bezier_C).toFixed(5)), v = Number((b * Xe.internal.Bezier_C).toFixed(5));
  return y.push("0.749023 g"), y.push("q"), y.push("1 0 0 1 " + Tl(Xe.internal.getWidth(x) / 2) + " " + Tl(Xe.internal.getHeight(x) / 2) + " cm"), y.push(k + " 0 m"), y.push(k + " " + P + " " + P + " " + k + " 0 " + k + " c"), y.push("-" + P + " " + k + " -" + k + " " + P + " -" + k + " 0 c"), y.push("-" + k + " -" + P + " -" + P + " -" + k + " 0 -" + k + " c"), y.push(P + " -" + k + " " + k + " -" + P + " " + k + " 0 c"), y.push("f"), y.push("Q"), y.push("0 g"), y.push("q"), y.push("1 0 0 1 " + Tl(Xe.internal.getWidth(x) / 2) + " " + Tl(Xe.internal.getHeight(x) / 2) + " cm"), y.push(b + " 0 m"), y.push(b + " " + v + " " + v + " " + b + " 0 " + b + " c"), y.push("-" + v + " " + b + " -" + b + " " + v + " -" + b + " 0 c"), y.push("-" + b + " -" + v + " -" + v + " -" + b + " 0 -" + b + " c"), y.push(v + " -" + b + " " + b + " -" + v + " " + b + " 0 c"), y.push("f"), y.push("Q"), f.stream = y.join(`
`), f;
}, OffPushDown: function(x) {
  var f = Co(x);
  f.scope = x.scope;
  var y = [], b = Xe.internal.getWidth(x) <= Xe.internal.getHeight(x) ? Xe.internal.getWidth(x) / 4 : Xe.internal.getHeight(x) / 4;
  b = Number((0.9 * b).toFixed(5));
  var k = Number((2 * b).toFixed(5)), P = Number((k * Xe.internal.Bezier_C).toFixed(5));
  return y.push("0.749023 g"), y.push("q"), y.push("1 0 0 1 " + Tl(Xe.internal.getWidth(x) / 2) + " " + Tl(Xe.internal.getHeight(x) / 2) + " cm"), y.push(k + " 0 m"), y.push(k + " " + P + " " + P + " " + k + " 0 " + k + " c"), y.push("-" + P + " " + k + " -" + k + " " + P + " -" + k + " 0 c"), y.push("-" + k + " -" + P + " -" + P + " -" + k + " 0 -" + k + " c"), y.push(P + " -" + k + " " + k + " -" + P + " " + k + " 0 c"), y.push("f"), y.push("Q"), f.stream = y.join(`
`), f;
} }, Cross: { createAppearanceStream: function(x) {
  var f = { D: { Off: Xe.RadioButton.Cross.OffPushDown }, N: {} };
  return f.N[x] = Xe.RadioButton.Cross.YesNormal, f.D[x] = Xe.RadioButton.Cross.YesPushDown, f;
}, getCA: function() {
  return "8";
}, YesNormal: function(x) {
  var f = Co(x);
  f.scope = x.scope;
  var y = [], b = Xe.internal.calculateCross(x);
  return y.push("q"), y.push("1 1 " + Ti(Xe.internal.getWidth(x) - 2) + " " + Ti(Xe.internal.getHeight(x) - 2) + " re"), y.push("W"), y.push("n"), y.push(Ti(b.x1.x) + " " + Ti(b.x1.y) + " m"), y.push(Ti(b.x2.x) + " " + Ti(b.x2.y) + " l"), y.push(Ti(b.x4.x) + " " + Ti(b.x4.y) + " m"), y.push(Ti(b.x3.x) + " " + Ti(b.x3.y) + " l"), y.push("s"), y.push("Q"), f.stream = y.join(`
`), f;
}, YesPushDown: function(x) {
  var f = Co(x);
  f.scope = x.scope;
  var y = Xe.internal.calculateCross(x), b = [];
  return b.push("0.749023 g"), b.push("0 0 " + Ti(Xe.internal.getWidth(x)) + " " + Ti(Xe.internal.getHeight(x)) + " re"), b.push("f"), b.push("q"), b.push("1 1 " + Ti(Xe.internal.getWidth(x) - 2) + " " + Ti(Xe.internal.getHeight(x) - 2) + " re"), b.push("W"), b.push("n"), b.push(Ti(y.x1.x) + " " + Ti(y.x1.y) + " m"), b.push(Ti(y.x2.x) + " " + Ti(y.x2.y) + " l"), b.push(Ti(y.x4.x) + " " + Ti(y.x4.y) + " m"), b.push(Ti(y.x3.x) + " " + Ti(y.x3.y) + " l"), b.push("s"), b.push("Q"), f.stream = b.join(`
`), f;
}, OffPushDown: function(x) {
  var f = Co(x);
  f.scope = x.scope;
  var y = [];
  return y.push("0.749023 g"), y.push("0 0 " + Ti(Xe.internal.getWidth(x)) + " " + Ti(Xe.internal.getHeight(x)) + " re"), y.push("f"), f.stream = y.join(`
`), f;
} } }, createDefaultAppearanceStream: function(x) {
  var f = x.scope.internal.getFont(x.fontName, x.fontStyle).id, y = x.scope.__private__.encodeColorString(x.color);
  return "/" + f + " " + x.fontSize + " Tf " + y;
} };
Xe.internal = { Bezier_C: 0.551915024494, calculateCross: function(x) {
  var f = Xe.internal.getWidth(x), y = Xe.internal.getHeight(x), b = Math.min(f, y);
  return { x1: { x: (f - b) / 2, y: (y - b) / 2 + b }, x2: { x: (f - b) / 2 + b, y: (y - b) / 2 }, x3: { x: (f - b) / 2, y: (y - b) / 2 }, x4: { x: (f - b) / 2 + b, y: (y - b) / 2 + b } };
} }, Xe.internal.getWidth = function(x) {
  var f = 0;
  return nr(x) === "object" && (f = Bp(x.Rect[2])), f;
}, Xe.internal.getHeight = function(x) {
  var f = 0;
  return nr(x) === "object" && (f = Bp(x.Rect[3])), f;
};
var o0 = Br.addField = function(x) {
  if (a0(this, x), !(x instanceof Ua)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var f;
  return (f = x).scope.internal.acroformPlugin.printedOut && (f.scope.internal.acroformPlugin.printedOut = !1, f.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), f.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(f), x.page = x.scope.internal.getCurrentPageInfo().pageNumber, this;
};
Br.AcroFormChoiceField = Mc, Br.AcroFormListBox = Ec, Br.AcroFormComboBox = zc, Br.AcroFormEditBox = Rh, Br.AcroFormButton = Sn, Br.AcroFormPushButton = Oh, Br.AcroFormRadioButton = Nc, Br.AcroFormCheckBox = jh, Br.AcroFormTextField = ec, Br.AcroFormPasswordField = qh, Br.AcroFormAppearance = Xe, Br.AcroForm = { ChoiceField: Mc, ListBox: Ec, ComboBox: zc, EditBox: Rh, Button: Sn, PushButton: Oh, RadioButton: Nc, CheckBox: jh, TextField: ec, PasswordField: qh, Appearance: Xe }, _i.AcroForm = { ChoiceField: Mc, ListBox: Ec, ComboBox: zc, EditBox: Rh, Button: Sn, PushButton: Oh, RadioButton: Nc, CheckBox: jh, TextField: ec, PasswordField: qh, Appearance: Xe };
function gf(x) {
  return x.reduce(function(f, y, b) {
    return f[y] = b, f;
  }, {});
}
(function(x) {
  x.__addimage__ = {};
  var f = "UNKNOWN", y = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, b = x.__addimage__.getImageFileTypeByImageData = function(at, lt) {
    var It, St, Wt, Xt, Ht, jt = f;
    if ((lt = lt || f) === "RGBA" || at.data !== void 0 && at.data instanceof Uint8ClampedArray && "height" in at && "width" in at) return "RGBA";
    if (pe(at)) for (Ht in y) for (Wt = y[Ht], It = 0; It < Wt.length; It += 1) {
      for (Xt = !0, St = 0; St < Wt[It].length; St += 1) if (Wt[It][St] !== void 0 && Wt[It][St] !== at[St]) {
        Xt = !1;
        break;
      }
      if (Xt === !0) {
        jt = Ht;
        break;
      }
    }
    else for (Ht in y) for (Wt = y[Ht], It = 0; It < Wt.length; It += 1) {
      for (Xt = !0, St = 0; St < Wt[It].length; St += 1) if (Wt[It][St] !== void 0 && Wt[It][St] !== at.charCodeAt(St)) {
        Xt = !1;
        break;
      }
      if (Xt === !0) {
        jt = Ht;
        break;
      }
    }
    return jt === f && lt !== f && (jt = lt), jt;
  }, k = function at(lt) {
    for (var It = this.internal.write, St = this.internal.putStream, Wt = (0, this.internal.getFilters)(); Wt.indexOf("FlateEncode") !== -1; ) Wt.splice(Wt.indexOf("FlateEncode"), 1);
    lt.objectId = this.internal.newObject();
    var Xt = [];
    if (Xt.push({ key: "Type", value: "/XObject" }), Xt.push({ key: "Subtype", value: "/Image" }), Xt.push({ key: "Width", value: lt.width }), Xt.push({ key: "Height", value: lt.height }), lt.colorSpace === yt.INDEXED ? Xt.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (lt.palette.length / 3 - 1) + " " + ("sMask" in lt && lt.sMask !== void 0 ? lt.objectId + 2 : lt.objectId + 1) + " 0 R]" }) : (Xt.push({ key: "ColorSpace", value: "/" + lt.colorSpace }), lt.colorSpace === yt.DEVICE_CMYK && Xt.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), Xt.push({ key: "BitsPerComponent", value: lt.bitsPerComponent }), "decodeParameters" in lt && lt.decodeParameters !== void 0 && Xt.push({ key: "DecodeParms", value: "<<" + lt.decodeParameters + ">>" }), "transparency" in lt && Array.isArray(lt.transparency)) {
      for (var Ht = "", jt = 0, ee = lt.transparency.length; jt < ee; jt++) Ht += lt.transparency[jt] + " " + lt.transparency[jt] + " ";
      Xt.push({ key: "Mask", value: "[" + Ht + "]" });
    }
    lt.sMask !== void 0 && Xt.push({ key: "SMask", value: lt.objectId + 1 + " 0 R" });
    var ie = lt.filter !== void 0 ? ["/" + lt.filter] : void 0;
    if (St({ data: lt.data, additionalKeyValues: Xt, alreadyAppliedFilters: ie, objectId: lt.objectId }), It("endobj"), "sMask" in lt && lt.sMask !== void 0) {
      var Se = "/Predictor " + lt.predictor + " /Colors 1 /BitsPerComponent " + lt.bitsPerComponent + " /Columns " + lt.width, K = { width: lt.width, height: lt.height, colorSpace: "DeviceGray", bitsPerComponent: lt.bitsPerComponent, decodeParameters: Se, data: lt.sMask };
      "filter" in lt && (K.filter = lt.filter), at.call(this, K);
    }
    if (lt.colorSpace === yt.INDEXED) {
      var pt = this.internal.newObject();
      St({ data: kt(new Uint8Array(lt.palette)), objectId: pt }), It("endobj");
    }
  }, P = function() {
    var at = this.internal.collections.addImage_images;
    for (var lt in at) k.call(this, at[lt]);
  }, v = function() {
    var at, lt = this.internal.collections.addImage_images, It = this.internal.write;
    for (var St in lt) It("/I" + (at = lt[St]).index, at.objectId, "0", "R");
  }, c = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", P), this.internal.events.subscribe("putXobjectDict", v));
  }, z = function() {
    var at = this.internal.collections.addImage_images;
    return c.call(this), at;
  }, U = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, X = function(at) {
    return typeof x["process" + at.toUpperCase()] == "function";
  }, O = function(at) {
    return nr(at) === "object" && at.nodeType === 1;
  }, j = function(at, lt) {
    if (at.nodeName === "IMG" && at.hasAttribute("src")) {
      var It = "" + at.getAttribute("src");
      if (It.indexOf("data:image/") === 0) return ch(unescape(It).split("base64,").pop());
      var St = x.loadFile(It, !0);
      if (St !== void 0) return St;
    }
    if (at.nodeName === "CANVAS") {
      if (at.width === 0 || at.height === 0) throw new Error("Given canvas must have data. Canvas width: " + at.width + ", height: " + at.height);
      var Wt;
      switch (lt) {
        case "PNG":
          Wt = "image/png";
          break;
        case "WEBP":
          Wt = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          Wt = "image/jpeg";
      }
      return ch(at.toDataURL(Wt, 1).split("base64,").pop());
    }
  }, F = function(at) {
    var lt = this.internal.collections.addImage_images;
    if (lt) {
      for (var It in lt) if (at === lt[It].alias) return lt[It];
    }
  }, mt = function(at, lt, It) {
    return at || lt || (at = -96, lt = -96), at < 0 && (at = -1 * It.width * 72 / at / this.internal.scaleFactor), lt < 0 && (lt = -1 * It.height * 72 / lt / this.internal.scaleFactor), at === 0 && (at = lt * It.width / It.height), lt === 0 && (lt = at * It.height / It.width), [at, lt];
  }, ot = function(at, lt, It, St, Wt, Xt) {
    var Ht = mt.call(this, It, St, Wt), jt = this.internal.getCoordinateString, ee = this.internal.getVerticalCoordinateString, ie = z.call(this);
    if (It = Ht[0], St = Ht[1], ie[Wt.index] = Wt, Xt) {
      Xt *= Math.PI / 180;
      var Se = Math.cos(Xt), K = Math.sin(Xt), pt = function(Tt) {
        return Tt.toFixed(4);
      }, xt = [pt(Se), pt(K), pt(-1 * K), pt(Se), 0, 0, "cm"];
    }
    this.internal.write("q"), Xt ? (this.internal.write([1, "0", "0", 1, jt(at), ee(lt + St), "cm"].join(" ")), this.internal.write(xt.join(" ")), this.internal.write([jt(It), "0", "0", jt(St), "0", "0", "cm"].join(" "))) : this.internal.write([jt(It), "0", "0", jt(St), jt(at), ee(lt + St), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + Wt.index + " Do"), this.internal.write("Q");
  }, yt = x.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  x.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var st = x.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, gt = x.__addimage__.sHashCode = function(at) {
    var lt, It, St = 0;
    if (typeof at == "string") for (It = at.length, lt = 0; lt < It; lt++) St = (St << 5) - St + at.charCodeAt(lt), St |= 0;
    else if (pe(at)) for (It = at.byteLength / 2, lt = 0; lt < It; lt++) St = (St << 5) - St + at[lt], St |= 0;
    return St;
  }, zt = x.__addimage__.validateStringAsBase64 = function(at) {
    (at = at || "").toString().trim();
    var lt = !0;
    return at.length === 0 && (lt = !1), at.length % 4 != 0 && (lt = !1), /^[A-Za-z0-9+/]+$/.test(at.substr(0, at.length - 2)) === !1 && (lt = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(at.substr(-2)) === !1 && (lt = !1), lt;
  }, Jt = x.__addimage__.extractImageFromDataUrl = function(at) {
    var lt = (at = at || "").split("base64,"), It = null;
    if (lt.length === 2) {
      var St = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(lt[0]);
      Array.isArray(St) && (It = { mimeType: St[1], charset: St[2], data: lt[1] });
    }
    return It;
  }, Kt = x.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  x.__addimage__.isArrayBuffer = function(at) {
    return Kt() && at instanceof ArrayBuffer;
  };
  var pe = x.__addimage__.isArrayBufferView = function(at) {
    return Kt() && typeof Uint32Array < "u" && (at instanceof Int8Array || at instanceof Uint8Array || typeof Uint8ClampedArray < "u" && at instanceof Uint8ClampedArray || at instanceof Int16Array || at instanceof Uint16Array || at instanceof Int32Array || at instanceof Uint32Array || at instanceof Float32Array || at instanceof Float64Array);
  }, Ot = x.__addimage__.binaryStringToUint8Array = function(at) {
    for (var lt = at.length, It = new Uint8Array(lt), St = 0; St < lt; St++) It[St] = at.charCodeAt(St);
    return It;
  }, kt = x.__addimage__.arrayBufferToBinaryString = function(at) {
    for (var lt = "", It = pe(at) ? at : new Uint8Array(at), St = 0; St < It.length; St += 8192) lt += String.fromCharCode.apply(null, It.subarray(St, St + 8192));
    return lt;
  };
  x.addImage = function() {
    var at, lt, It, St, Wt, Xt, Ht, jt, ee;
    if (typeof arguments[1] == "number" ? (lt = f, It = arguments[1], St = arguments[2], Wt = arguments[3], Xt = arguments[4], Ht = arguments[5], jt = arguments[6], ee = arguments[7]) : (lt = arguments[1], It = arguments[2], St = arguments[3], Wt = arguments[4], Xt = arguments[5], Ht = arguments[6], jt = arguments[7], ee = arguments[8]), nr(at = arguments[0]) === "object" && !O(at) && "imageData" in at) {
      var ie = at;
      at = ie.imageData, lt = ie.format || lt || f, It = ie.x || It || 0, St = ie.y || St || 0, Wt = ie.w || ie.width || Wt, Xt = ie.h || ie.height || Xt, Ht = ie.alias || Ht, jt = ie.compression || jt, ee = ie.rotation || ie.angle || ee;
    }
    var Se = this.internal.getFilters();
    if (jt === void 0 && Se.indexOf("FlateEncode") !== -1 && (jt = "SLOW"), isNaN(It) || isNaN(St)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c.call(this);
    var K = $t.call(this, at, lt, Ht, jt);
    return ot.call(this, It, St, Wt, Xt, K, ee), this;
  };
  var $t = function(at, lt, It, St) {
    var Wt, Xt, Ht;
    if (typeof at == "string" && b(at) === f) {
      at = unescape(at);
      var jt = ae(at, !1);
      (jt !== "" || (jt = x.loadFile(at, !0)) !== void 0) && (at = jt);
    }
    if (O(at) && (at = j(at, lt)), lt = b(at, lt), !X(lt)) throw new Error("addImage does not support files of type '" + lt + "', please ensure that a plugin for '" + lt + "' support is added.");
    if (((Ht = It) == null || Ht.length === 0) && (It = function(ee) {
      return typeof ee == "string" || pe(ee) ? gt(ee) : pe(ee.data) ? gt(ee.data) : null;
    }(at)), (Wt = F.call(this, It)) || (Kt() && (at instanceof Uint8Array || lt === "RGBA" || (Xt = at, at = Ot(at))), Wt = this["process" + lt.toUpperCase()](at, U.call(this), It, function(ee) {
      return ee && typeof ee == "string" && (ee = ee.toUpperCase()), ee in x.image_compression ? ee : st.NONE;
    }(St), Xt)), !Wt) throw new Error("An unknown error occurred whilst processing the image.");
    return Wt;
  }, ae = x.__addimage__.convertBase64ToBinaryString = function(at, lt) {
    var It;
    lt = typeof lt != "boolean" || lt;
    var St, Wt = "";
    if (typeof at == "string") {
      St = (It = Jt(at)) !== null ? It.data : at;
      try {
        Wt = ch(St);
      } catch (Xt) {
        if (lt) throw zt(St) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + Xt.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return Wt;
  };
  x.getImageProperties = function(at) {
    var lt, It, St = "";
    if (O(at) && (at = j(at)), typeof at == "string" && b(at) === f && ((St = ae(at, !1)) === "" && (St = x.loadFile(at) || ""), at = St), It = b(at), !X(It)) throw new Error("addImage does not support files of type '" + It + "', please ensure that a plugin for '" + It + "' support is added.");
    if (!Kt() || at instanceof Uint8Array || (at = Ot(at)), !(lt = this["process" + It.toUpperCase()](at))) throw new Error("An unknown error occurred whilst processing the image");
    return lt.fileType = It, lt;
  };
})(_i.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var f = function(y) {
    if (y !== void 0 && y != "") return !0;
  };
  _i.API.events.push(["addPage", function(y) {
    this.internal.getPageInfo(y.pageNumber).pageContext.annotations = [];
  }]), x.events.push(["putPage", function(y) {
    for (var b, k, P, v = this.internal.getCoordinateString, c = this.internal.getVerticalCoordinateString, z = this.internal.getPageInfoByObjId(y.objId), U = y.pageContext.annotations, X = !1, O = 0; O < U.length && !X; O++) switch ((b = U[O]).type) {
      case "link":
        (f(b.options.url) || f(b.options.pageNumber)) && (X = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        X = !0;
    }
    if (X != 0) {
      this.internal.write("/Annots [");
      for (var j = 0; j < U.length; j++) {
        b = U[j];
        var F = this.internal.pdfEscape, mt = this.internal.getEncryptor(y.objId);
        switch (b.type) {
          case "reference":
            this.internal.write(" " + b.object.objId + " 0 R ");
            break;
          case "text":
            var ot = this.internal.newAdditionalObject(), yt = this.internal.newAdditionalObject(), st = this.internal.getEncryptor(ot.objId), gt = b.title || "Note";
            P = "<</Type /Annot /Subtype /Text " + (k = "/Rect [" + v(b.bounds.x) + " " + c(b.bounds.y + b.bounds.h) + " " + v(b.bounds.x + b.bounds.w) + " " + c(b.bounds.y) + "] ") + "/Contents (" + F(st(b.contents)) + ")", P += " /Popup " + yt.objId + " 0 R", P += " /P " + z.objId + " 0 R", P += " /T (" + F(st(gt)) + ") >>", ot.content = P;
            var zt = ot.objId + " 0 R";
            P = "<</Type /Annot /Subtype /Popup " + (k = "/Rect [" + v(b.bounds.x + 30) + " " + c(b.bounds.y + b.bounds.h) + " " + v(b.bounds.x + b.bounds.w + 30) + " " + c(b.bounds.y) + "] ") + " /Parent " + zt, b.open && (P += " /Open true"), P += " >>", yt.content = P, this.internal.write(ot.objId, "0 R", yt.objId, "0 R");
            break;
          case "freetext":
            k = "/Rect [" + v(b.bounds.x) + " " + c(b.bounds.y) + " " + v(b.bounds.x + b.bounds.w) + " " + c(b.bounds.y + b.bounds.h) + "] ";
            var Jt = b.color || "#000000";
            P = "<</Type /Annot /Subtype /FreeText " + k + "/Contents (" + F(mt(b.contents)) + ")", P += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + Jt + ")", P += " /Border [0 0 0]", P += " >>", this.internal.write(P);
            break;
          case "link":
            if (b.options.name) {
              var Kt = this.annotations._nameMap[b.options.name];
              b.options.pageNumber = Kt.page, b.options.top = Kt.y;
            } else b.options.top || (b.options.top = 0);
            if (k = "/Rect [" + b.finalBounds.x + " " + b.finalBounds.y + " " + b.finalBounds.w + " " + b.finalBounds.h + "] ", P = "", b.options.url) P = "<</Type /Annot /Subtype /Link " + k + "/Border [0 0 0] /A <</S /URI /URI (" + F(mt(b.options.url)) + ") >>";
            else if (b.options.pageNumber)
              switch (P = "<</Type /Annot /Subtype /Link " + k + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(b.options.pageNumber).objId + " 0 R", b.options.magFactor = b.options.magFactor || "XYZ", b.options.magFactor) {
                case "Fit":
                  P += " /Fit]";
                  break;
                case "FitH":
                  P += " /FitH " + b.options.top + "]";
                  break;
                case "FitV":
                  b.options.left = b.options.left || 0, P += " /FitV " + b.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var pe = c(b.options.top);
                  b.options.left = b.options.left || 0, b.options.zoom === void 0 && (b.options.zoom = 0), P += " /XYZ " + b.options.left + " " + pe + " " + b.options.zoom + "]";
              }
            P != "" && (P += " >>", this.internal.write(P));
        }
      }
      this.internal.write("]");
    }
  }]), x.createAnnotation = function(y) {
    var b = this.internal.getCurrentPageInfo();
    switch (y.type) {
      case "link":
        this.link(y.bounds.x, y.bounds.y, y.bounds.w, y.bounds.h, y);
        break;
      case "text":
      case "freetext":
        b.pageContext.annotations.push(y);
    }
  }, x.link = function(y, b, k, P, v) {
    var c = this.internal.getCurrentPageInfo(), z = this.internal.getCoordinateString, U = this.internal.getVerticalCoordinateString;
    c.pageContext.annotations.push({ finalBounds: { x: z(y), y: U(b), w: z(y + k), h: U(b + P) }, options: v, type: "link" });
  }, x.textWithLink = function(y, b, k, P) {
    var v, c, z = this.getTextWidth(y), U = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (P.maxWidth !== void 0) {
      c = P.maxWidth;
      var X = this.splitTextToSize(y, c).length;
      v = Math.ceil(U * X);
    } else c = z, v = U;
    return this.text(y, b, k, P), k += 0.2 * U, P.align === "center" && (b -= z / 2), P.align === "right" && (b -= z), this.link(b, k - U, c, v, P), z;
  }, x.getTextWidth = function(y) {
    var b = this.internal.getFontSize();
    return this.getStringUnitWidth(y) * b / this.internal.scaleFactor;
  };
}(_i.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var f = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, y = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, b = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, k = [1570, 1571, 1573, 1575];
  x.__arabicParser__ = {};
  var P = x.__arabicParser__.isInArabicSubstitutionA = function(ot) {
    return f[ot.charCodeAt(0)] !== void 0;
  }, v = x.__arabicParser__.isArabicLetter = function(ot) {
    return typeof ot == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(ot);
  }, c = x.__arabicParser__.isArabicEndLetter = function(ot) {
    return v(ot) && P(ot) && f[ot.charCodeAt(0)].length <= 2;
  }, z = x.__arabicParser__.isArabicAlfLetter = function(ot) {
    return v(ot) && k.indexOf(ot.charCodeAt(0)) >= 0;
  };
  x.__arabicParser__.arabicLetterHasIsolatedForm = function(ot) {
    return v(ot) && P(ot) && f[ot.charCodeAt(0)].length >= 1;
  };
  var U = x.__arabicParser__.arabicLetterHasFinalForm = function(ot) {
    return v(ot) && P(ot) && f[ot.charCodeAt(0)].length >= 2;
  };
  x.__arabicParser__.arabicLetterHasInitialForm = function(ot) {
    return v(ot) && P(ot) && f[ot.charCodeAt(0)].length >= 3;
  };
  var X = x.__arabicParser__.arabicLetterHasMedialForm = function(ot) {
    return v(ot) && P(ot) && f[ot.charCodeAt(0)].length == 4;
  }, O = x.__arabicParser__.resolveLigatures = function(ot) {
    var yt = 0, st = y, gt = "", zt = 0;
    for (yt = 0; yt < ot.length; yt += 1) st[ot.charCodeAt(yt)] !== void 0 ? (zt++, typeof (st = st[ot.charCodeAt(yt)]) == "number" && (gt += String.fromCharCode(st), st = y, zt = 0), yt === ot.length - 1 && (st = y, gt += ot.charAt(yt - (zt - 1)), yt -= zt - 1, zt = 0)) : (st = y, gt += ot.charAt(yt - zt), yt -= zt, zt = 0);
    return gt;
  };
  x.__arabicParser__.isArabicDiacritic = function(ot) {
    return ot !== void 0 && b[ot.charCodeAt(0)] !== void 0;
  };
  var j = x.__arabicParser__.getCorrectForm = function(ot, yt, st) {
    return v(ot) ? P(ot) === !1 ? -1 : !U(ot) || !v(yt) && !v(st) || !v(st) && c(yt) || c(ot) && !v(yt) || c(ot) && z(yt) || c(ot) && c(yt) ? 0 : X(ot) && v(yt) && !c(yt) && v(st) && U(st) ? 3 : c(ot) || !v(st) ? 1 : 2 : -1;
  }, F = function(ot) {
    var yt = 0, st = 0, gt = 0, zt = "", Jt = "", Kt = "", pe = (ot = ot || "").split("\\s+"), Ot = [];
    for (yt = 0; yt < pe.length; yt += 1) {
      for (Ot.push(""), st = 0; st < pe[yt].length; st += 1) zt = pe[yt][st], Jt = pe[yt][st - 1], Kt = pe[yt][st + 1], v(zt) ? (gt = j(zt, Jt, Kt), Ot[yt] += gt !== -1 ? String.fromCharCode(f[zt.charCodeAt(0)][gt]) : zt) : Ot[yt] += zt;
      Ot[yt] = O(Ot[yt]);
    }
    return Ot.join(" ");
  }, mt = x.__arabicParser__.processArabic = x.processArabic = function() {
    var ot, yt = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, st = [];
    if (Array.isArray(yt)) {
      var gt = 0;
      for (st = [], gt = 0; gt < yt.length; gt += 1) Array.isArray(yt[gt]) ? st.push([F(yt[gt][0]), yt[gt][1], yt[gt][2]]) : st.push([F(yt[gt])]);
      ot = st;
    } else ot = F(yt);
    return typeof arguments[0] == "string" ? ot : (arguments[0].text = ot, arguments[0]);
  };
  x.events.push(["preProcessText", mt]);
}(_i.API), _i.API.autoPrint = function(x) {
  var f;
  switch ((x = x || {}).variant = x.variant || "non-conform", x.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        f = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + f + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var f = function() {
    var y = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return y;
    }, set: function(c) {
      y = c;
    } });
    var b = 150;
    Object.defineProperty(this, "width", { get: function() {
      return b;
    }, set: function(c) {
      b = isNaN(c) || Number.isInteger(c) === !1 || c < 0 ? 150 : c, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = b + 1);
    } });
    var k = 300;
    Object.defineProperty(this, "height", { get: function() {
      return k;
    }, set: function(c) {
      k = isNaN(c) || Number.isInteger(c) === !1 || c < 0 ? 300 : c, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = k + 1);
    } });
    var P = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return P;
    }, set: function(c) {
      P = c;
    } });
    var v = {};
    Object.defineProperty(this, "style", { get: function() {
      return v;
    }, set: function(c) {
      v = c;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  f.prototype.getContext = function(y, b) {
    var k;
    if ((y = y || "2d") !== "2d") return null;
    for (k in b) this.pdf.context2d.hasOwnProperty(k) && (this.pdf.context2d[k] = b[k]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, f.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, x.events.push(["initialized", function() {
    this.canvas = new f(), this.canvas.pdf = this;
  }]);
}(_i.API), function(x) {
  var f = { left: 0, top: 0, bottom: 0, right: 0 }, y = !1, b = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, f), this.internal.__cell__.margins.width = this.getPageWidth(), k.call(this));
  }, k = function() {
    this.internal.__cell__.lastCell = new P(), this.internal.__cell__.pages = 1;
  }, P = function() {
    var z = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return z;
    }, set: function(ot) {
      z = ot;
    } });
    var U = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return U;
    }, set: function(ot) {
      U = ot;
    } });
    var X = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return X;
    }, set: function(ot) {
      X = ot;
    } });
    var O = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return O;
    }, set: function(ot) {
      O = ot;
    } });
    var j = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return j;
    }, set: function(ot) {
      j = ot;
    } });
    var F = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return F;
    }, set: function(ot) {
      F = ot;
    } });
    var mt = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return mt;
    }, set: function(ot) {
      mt = ot;
    } }), this;
  };
  P.prototype.clone = function() {
    return new P(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, P.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, x.setHeaderFunction = function(z) {
    return b.call(this), this.internal.__cell__.headerFunction = typeof z == "function" ? z : void 0, this;
  }, x.getTextDimensions = function(z, U) {
    b.call(this);
    var X = (U = U || {}).fontSize || this.getFontSize(), O = U.font || this.getFont(), j = U.scaleFactor || this.internal.scaleFactor, F = 0, mt = 0, ot = 0, yt = this;
    if (!Array.isArray(z) && typeof z != "string") {
      if (typeof z != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      z = String(z);
    }
    var st = U.maxWidth;
    st > 0 ? typeof z == "string" ? z = this.splitTextToSize(z, st) : Object.prototype.toString.call(z) === "[object Array]" && (z = z.reduce(function(zt, Jt) {
      return zt.concat(yt.splitTextToSize(Jt, st));
    }, [])) : z = Array.isArray(z) ? z : [z];
    for (var gt = 0; gt < z.length; gt++) F < (ot = this.getStringUnitWidth(z[gt], { font: O }) * X) && (F = ot);
    return F !== 0 && (mt = z.length), { w: F /= j, h: Math.max((mt * X * this.getLineHeightFactor() - X * (this.getLineHeightFactor() - 1)) / j, 0) };
  }, x.cellAddPage = function() {
    b.call(this), this.addPage();
    var z = this.internal.__cell__.margins || f;
    return this.internal.__cell__.lastCell = new P(z.left, z.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var v = x.cell = function() {
    var z;
    z = arguments[0] instanceof P ? arguments[0] : new P(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), b.call(this);
    var U = this.internal.__cell__.lastCell, X = this.internal.__cell__.padding, O = this.internal.__cell__.margins || f, j = this.internal.__cell__.tableHeaderRow, F = this.internal.__cell__.printHeaders;
    return U.lineNumber !== void 0 && (U.lineNumber === z.lineNumber ? (z.x = (U.x || 0) + (U.width || 0), z.y = U.y || 0) : U.y + U.height + z.height + O.bottom > this.getPageHeight() ? (this.cellAddPage(), z.y = O.top, F && j && (this.printHeaderRow(z.lineNumber, !0), z.y += j[0].height)) : z.y = U.y + U.height || z.y), z.text[0] !== void 0 && (this.rect(z.x, z.y, z.width, z.height, y === !0 ? "FD" : void 0), z.align === "right" ? this.text(z.text, z.x + z.width - X, z.y + X, { align: "right", baseline: "top" }) : z.align === "center" ? this.text(z.text, z.x + z.width / 2, z.y + X, { align: "center", baseline: "top", maxWidth: z.width - X - X }) : this.text(z.text, z.x + X, z.y + X, { align: "left", baseline: "top", maxWidth: z.width - X - X })), this.internal.__cell__.lastCell = z, this;
  };
  x.table = function(z, U, X, O, j) {
    if (b.call(this), !X) throw new Error("No data for PDF table.");
    var F, mt, ot, yt, st = [], gt = [], zt = [], Jt = {}, Kt = {}, pe = [], Ot = [], kt = (j = j || {}).autoSize || !1, $t = j.printHeaders !== !1, ae = j.css && j.css["font-size"] !== void 0 ? 16 * j.css["font-size"] : j.fontSize || 12, at = j.margins || Object.assign({ width: this.getPageWidth() }, f), lt = typeof j.padding == "number" ? j.padding : 3, It = j.headerBackgroundColor || "#c8c8c8", St = j.headerTextColor || "#000";
    if (k.call(this), this.internal.__cell__.printHeaders = $t, this.internal.__cell__.margins = at, this.internal.__cell__.table_font_size = ae, this.internal.__cell__.padding = lt, this.internal.__cell__.headerBackgroundColor = It, this.internal.__cell__.headerTextColor = St, this.setFontSize(ae), O == null) gt = st = Object.keys(X[0]), zt = st.map(function() {
      return "left";
    });
    else if (Array.isArray(O) && nr(O[0]) === "object") for (st = O.map(function(ie) {
      return ie.name;
    }), gt = O.map(function(ie) {
      return ie.prompt || ie.name || "";
    }), zt = O.map(function(ie) {
      return ie.align || "left";
    }), F = 0; F < O.length; F += 1) Kt[O[F].name] = O[F].width * (19.049976 / 25.4);
    else Array.isArray(O) && typeof O[0] == "string" && (gt = st = O, zt = st.map(function() {
      return "left";
    }));
    if (kt || Array.isArray(O) && typeof O[0] == "string") for (F = 0; F < st.length; F += 1) {
      for (Jt[yt = st[F]] = X.map(function(ie) {
        return ie[yt];
      }), this.setFont(void 0, "bold"), pe.push(this.getTextDimensions(gt[F], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), mt = Jt[yt], this.setFont(void 0, "normal"), ot = 0; ot < mt.length; ot += 1) pe.push(this.getTextDimensions(mt[ot], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      Kt[yt] = Math.max.apply(null, pe) + lt + lt, pe = [];
    }
    if ($t) {
      var Wt = {};
      for (F = 0; F < st.length; F += 1) Wt[st[F]] = {}, Wt[st[F]].text = gt[F], Wt[st[F]].align = zt[F];
      var Xt = c.call(this, Wt, Kt);
      Ot = st.map(function(ie) {
        return new P(z, U, Kt[ie], Xt, Wt[ie].text, void 0, Wt[ie].align);
      }), this.setTableHeaderRow(Ot), this.printHeaderRow(1, !1);
    }
    var Ht = O.reduce(function(ie, Se) {
      return ie[Se.name] = Se.align, ie;
    }, {});
    for (F = 0; F < X.length; F += 1) {
      "rowStart" in j && j.rowStart instanceof Function && j.rowStart({ row: F, data: X[F] }, this);
      var jt = c.call(this, X[F], Kt);
      for (ot = 0; ot < st.length; ot += 1) {
        var ee = X[F][st[ot]];
        "cellStart" in j && j.cellStart instanceof Function && j.cellStart({ row: F, col: ot, data: ee }, this), v.call(this, new P(z, U, Kt[st[ot]], jt, ee, F + 2, Ht[st[ot]]));
      }
    }
    return this.internal.__cell__.table_x = z, this.internal.__cell__.table_y = U, this;
  };
  var c = function(z, U) {
    var X = this.internal.__cell__.padding, O = this.internal.__cell__.table_font_size, j = this.internal.scaleFactor;
    return Object.keys(z).map(function(F) {
      var mt = z[F];
      return this.splitTextToSize(mt.hasOwnProperty("text") ? mt.text : mt, U[F] - X - X);
    }, this).map(function(F) {
      return this.getLineHeightFactor() * F.length * O / j + X + X;
    }, this).reduce(function(F, mt) {
      return Math.max(F, mt);
    }, 0);
  };
  x.setTableHeaderRow = function(z) {
    b.call(this), this.internal.__cell__.tableHeaderRow = z;
  }, x.printHeaderRow = function(z, U) {
    if (b.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var X;
    if (y = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var O = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new P(O[0], O[1], O[2], O[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var j = [], F = 0; F < this.internal.__cell__.tableHeaderRow.length; F += 1) {
      X = this.internal.__cell__.tableHeaderRow[F].clone(), U && (X.y = this.internal.__cell__.margins.top || 0, j.push(X)), X.lineNumber = z;
      var mt = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), v.call(this, X), this.setTextColor(mt);
    }
    j.length > 0 && this.setTableHeaderRow(j), this.setFont(void 0, "normal"), y = !1;
  };
}(_i.API);
var yf = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, _f = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Yu = gf(_f), vf = [100, 200, 300, 400, 500, 600, 700, 800, 900], l0 = gf(vf);
function Ku(x) {
  var f = x.family.replace(/"|'/g, "").toLowerCase(), y = function(P) {
    return yf[P = P || "normal"] ? P : "normal";
  }(x.style), b = function(P) {
    if (!P) return 400;
    if (typeof P == "number") return P >= 100 && P <= 900 && P % 100 == 0 ? P : 400;
    if (/^\d00$/.test(P)) return parseInt(P);
    switch (P) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(x.weight), k = function(P) {
    return typeof Yu[P = P || "normal"] == "number" ? P : "normal";
  }(x.stretch);
  return { family: f, style: y, weight: b, stretch: k, src: x.src || [], ref: x.ref || { name: f, style: [k, y, b].join(" ") } };
}
function Rp(x, f, y, b) {
  var k;
  for (k = y; k >= 0 && k < f.length; k += b) if (x[f[k]]) return x[f[k]];
  for (k = y; k >= 0 && k < f.length; k -= b) if (x[f[k]]) return x[f[k]];
}
var c0 = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Op = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function jp(x) {
  return [x.stretch, x.style, x.weight, x.family].join(" ");
}
function h0(x, f, y) {
  for (var b = (y = y || {}).defaultFontFamily || "times", k = Object.assign({}, c0, y.genericFontFamilies || {}), P = null, v = null, c = 0; c < f.length; ++c) if (k[(P = Ku(f[c])).family] && (P.family = k[P.family]), x.hasOwnProperty(P.family)) {
    v = x[P.family];
    break;
  }
  if (!(v = v || x[b])) throw new Error("Could not find a font-family for the rule '" + jp(P) + "' and default family '" + b + "'.");
  if (v = function(z, U) {
    if (U[z]) return U[z];
    var X = Yu[z], O = X <= Yu.normal ? -1 : 1, j = Rp(U, _f, X, O);
    if (!j) throw new Error("Could not find a matching font-stretch value for " + z);
    return j;
  }(P.stretch, v), v = function(z, U) {
    if (U[z]) return U[z];
    for (var X = yf[z], O = 0; O < X.length; ++O) if (U[X[O]]) return U[X[O]];
    throw new Error("Could not find a matching font-style for " + z);
  }(P.style, v), !(v = function(z, U) {
    if (U[z]) return U[z];
    if (z === 400 && U[500]) return U[500];
    if (z === 500 && U[400]) return U[400];
    var X = l0[z], O = Rp(U, vf, X, z < 400 ? -1 : 1);
    if (!O) throw new Error("Could not find a matching font-weight for value " + z);
    return O;
  }(P.weight, v))) throw new Error("Failed to resolve a font for the rule '" + jp(P) + "'.");
  return v;
}
function qp(x) {
  return x.trimLeft();
}
function u0(x, f) {
  for (var y = 0; y < x.length; ) {
    if (x.charAt(y) === f) return [x.substring(0, y), x.substring(y + 1)];
    y += 1;
  }
  return null;
}
function d0(x) {
  var f = x.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return f === null ? null : [f[0], x.substring(f[0].length)];
}
var Fh, Up, Vp, Gp = ["times"];
(function(x) {
  var f, y, b, k, P, v, c, z, U, X = function(K) {
    return K = K || {}, this.isStrokeTransparent = K.isStrokeTransparent || !1, this.strokeOpacity = K.strokeOpacity || 1, this.strokeStyle = K.strokeStyle || "#000000", this.fillStyle = K.fillStyle || "#000000", this.isFillTransparent = K.isFillTransparent || !1, this.fillOpacity = K.fillOpacity || 1, this.font = K.font || "10px sans-serif", this.textBaseline = K.textBaseline || "alphabetic", this.textAlign = K.textAlign || "left", this.lineWidth = K.lineWidth || 1, this.lineJoin = K.lineJoin || "miter", this.lineCap = K.lineCap || "butt", this.path = K.path || [], this.transform = K.transform !== void 0 ? K.transform.clone() : new z(), this.globalCompositeOperation = K.globalCompositeOperation || "normal", this.globalAlpha = K.globalAlpha || 1, this.clip_path = K.clip_path || [], this.currentPoint = K.currentPoint || new v(), this.miterLimit = K.miterLimit || 10, this.lastPoint = K.lastPoint || new v(), this.lineDashOffset = K.lineDashOffset || 0, this.lineDash = K.lineDash || [], this.margin = K.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = K.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof K.ignoreClearRect != "boolean" || K.ignoreClearRect, this;
  };
  x.events.push(["initialized", function() {
    this.context2d = new O(this), f = this.internal.f2, y = this.internal.getCoordinateString, b = this.internal.getVerticalCoordinateString, k = this.internal.getHorizontalCoordinate, P = this.internal.getVerticalCoordinate, v = this.internal.Point, c = this.internal.Rectangle, z = this.internal.Matrix, U = new X();
  }]);
  var O = function(K) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var pt = K;
    Object.defineProperty(this, "pdf", { get: function() {
      return pt;
    } });
    var xt = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return xt;
    }, set: function(Qt) {
      xt = !!Qt;
    } });
    var Tt = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Tt;
    }, set: function(Qt) {
      Tt = !!Qt;
    } });
    var Et = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return Et;
    }, set: function(Qt) {
      isNaN(Qt) || (Et = Qt);
    } });
    var Rt = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return Rt;
    }, set: function(Qt) {
      isNaN(Qt) || (Rt = Qt);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return U.margin;
    }, set: function(Qt) {
      var Y;
      typeof Qt == "number" ? Y = [Qt, Qt, Qt, Qt] : ((Y = new Array(4))[0] = Qt[0], Y[1] = Qt.length >= 2 ? Qt[1] : Y[0], Y[2] = Qt.length >= 3 ? Qt[2] : Y[0], Y[3] = Qt.length >= 4 ? Qt[3] : Y[1]), U.margin = Y;
    } });
    var qt = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return qt;
    }, set: function(Qt) {
      qt = Qt;
    } });
    var Gt = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return Gt;
    }, set: function(Qt) {
      Gt = Qt;
    } });
    var we = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return we;
    }, set: function(Qt) {
      we = Qt;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return U;
    }, set: function(Qt) {
      Qt instanceof X && (U = Qt);
    } }), Object.defineProperty(this, "path", { get: function() {
      return U.path;
    }, set: function(Qt) {
      U.path = Qt;
    } });
    var be = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return be;
    }, set: function(Qt) {
      be = Qt;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(Qt) {
      var Y;
      Y = j(Qt), this.ctx.fillStyle = Y.style, this.ctx.isFillTransparent = Y.a === 0, this.ctx.fillOpacity = Y.a, this.pdf.setFillColor(Y.r, Y.g, Y.b, { a: Y.a }), this.pdf.setTextColor(Y.r, Y.g, Y.b, { a: Y.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(Qt) {
      var Y = j(Qt);
      this.ctx.strokeStyle = Y.style, this.ctx.isStrokeTransparent = Y.a === 0, this.ctx.strokeOpacity = Y.a, Y.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Y.a, this.pdf.setDrawColor(Y.r, Y.g, Y.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(Qt) {
      ["butt", "round", "square"].indexOf(Qt) !== -1 && (this.ctx.lineCap = Qt, this.pdf.setLineCap(Qt));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(Qt) {
      isNaN(Qt) || (this.ctx.lineWidth = Qt, this.pdf.setLineWidth(Qt));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(Qt) {
      ["bevel", "round", "miter"].indexOf(Qt) !== -1 && (this.ctx.lineJoin = Qt, this.pdf.setLineJoin(Qt));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(Qt) {
      isNaN(Qt) || (this.ctx.miterLimit = Qt, this.pdf.setMiterLimit(Qt));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(Qt) {
      this.ctx.textBaseline = Qt;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(Qt) {
      ["right", "end", "center", "left", "start"].indexOf(Qt) !== -1 && (this.ctx.textAlign = Qt);
    } });
    var Ie = null;
    function Pe(Qt, Y) {
      if (Ie === null) {
        var ui = function(Ge) {
          var se = [];
          return Object.keys(Ge).forEach(function(_e) {
            Ge[_e].forEach(function(ze) {
              var ke = null;
              switch (ze) {
                case "bold":
                  ke = { family: _e, weight: "bold" };
                  break;
                case "italic":
                  ke = { family: _e, style: "italic" };
                  break;
                case "bolditalic":
                  ke = { family: _e, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  ke = { family: _e };
              }
              ke !== null && (ke.ref = { name: _e, style: ze }, se.push(ke));
            });
          }), se;
        }(Qt.getFontList());
        Ie = function(Ge) {
          for (var se = {}, _e = 0; _e < Ge.length; ++_e) {
            var ze = Ku(Ge[_e]), ke = ze.family, Ze = ze.stretch, di = ze.style, ai = ze.weight;
            se[ke] = se[ke] || {}, se[ke][Ze] = se[ke][Ze] || {}, se[ke][Ze][di] = se[ke][Ze][di] || {}, se[ke][Ze][di][ai] = ze;
          }
          return se;
        }(ui.concat(Y));
      }
      return Ie;
    }
    var ti = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return ti;
    }, set: function(Qt) {
      Ie = null, ti = Qt;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(Qt) {
      var Y;
      if (this.ctx.font = Qt, (Y = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(Qt)) !== null) {
        var ui = Y[1], Ge = (Y[2], Y[3]), se = Y[4], _e = (Y[5], Y[6]), ze = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(se)[2];
        se = Math.floor(ze === "px" ? parseFloat(se) * this.pdf.internal.scaleFactor : ze === "em" ? parseFloat(se) * this.pdf.getFontSize() : parseFloat(se) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(se);
        var ke = function(ei) {
          var oi, Te, cr = [], le = ei.trim();
          if (le === "") return Gp;
          if (le in Op) return [Op[le]];
          for (; le !== ""; ) {
            switch (Te = null, oi = (le = qp(le)).charAt(0)) {
              case '"':
              case "'":
                Te = u0(le.substring(1), oi);
                break;
              default:
                Te = d0(le);
            }
            if (Te === null || (cr.push(Te[0]), (le = qp(Te[1])) !== "" && le.charAt(0) !== ",")) return Gp;
            le = le.replace(/^,/, "");
          }
          return cr;
        }(_e);
        if (this.fontFaces) {
          var Ze = h0(Pe(this.pdf, this.fontFaces), ke.map(function(ei) {
            return { family: ei, stretch: "normal", weight: Ge, style: ui };
          }));
          this.pdf.setFont(Ze.ref.name, Ze.ref.style);
        } else {
          var di = "";
          (Ge === "bold" || parseInt(Ge, 10) >= 700 || ui === "bold") && (di = "bold"), ui === "italic" && (di += "italic"), di.length === 0 && (di = "normal");
          for (var ai = "", wi = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Ei = 0; Ei < ke.length; Ei++) {
            if (this.pdf.internal.getFont(ke[Ei], di, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ai = ke[Ei];
              break;
            }
            if (di === "bolditalic" && this.pdf.internal.getFont(ke[Ei], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) ai = ke[Ei], di = "bold";
            else if (this.pdf.internal.getFont(ke[Ei], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              ai = ke[Ei], di = "normal";
              break;
            }
          }
          if (ai === "") {
            for (var oe = 0; oe < ke.length; oe++) if (wi[ke[oe]]) {
              ai = wi[ke[oe]];
              break;
            }
          }
          ai = ai === "" ? "Times" : ai, this.pdf.setFont(ai, di);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(Qt) {
      this.ctx.globalCompositeOperation = Qt;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(Qt) {
      this.ctx.globalAlpha = Qt;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(Qt) {
      this.ctx.lineDashOffset = Qt, Se.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(Qt) {
      this.ctx.lineDash = Qt, Se.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(Qt) {
      this.ctx.ignoreClearRect = !!Qt;
    } });
  };
  O.prototype.setLineDash = function(K) {
    this.lineDash = K;
  }, O.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, O.prototype.fill = function() {
    Jt.call(this, "fill", !1);
  }, O.prototype.stroke = function() {
    Jt.call(this, "stroke", !1);
  }, O.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, O.prototype.moveTo = function(K, pt) {
    if (isNaN(K) || isNaN(pt)) throw dr.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var xt = this.ctx.transform.applyToPoint(new v(K, pt));
    this.path.push({ type: "mt", x: xt.x, y: xt.y }), this.ctx.lastPoint = new v(K, pt);
  }, O.prototype.closePath = function() {
    var K = new v(0, 0), pt = 0;
    for (pt = this.path.length - 1; pt !== -1; pt--) if (this.path[pt].type === "begin" && nr(this.path[pt + 1]) === "object" && typeof this.path[pt + 1].x == "number") {
      K = new v(this.path[pt + 1].x, this.path[pt + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new v(K.x, K.y);
  }, O.prototype.lineTo = function(K, pt) {
    if (isNaN(K) || isNaN(pt)) throw dr.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var xt = this.ctx.transform.applyToPoint(new v(K, pt));
    this.path.push({ type: "lt", x: xt.x, y: xt.y }), this.ctx.lastPoint = new v(xt.x, xt.y);
  }, O.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), Jt.call(this, null, !0);
  }, O.prototype.quadraticCurveTo = function(K, pt, xt, Tt) {
    if (isNaN(xt) || isNaN(Tt) || isNaN(K) || isNaN(pt)) throw dr.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var Et = this.ctx.transform.applyToPoint(new v(xt, Tt)), Rt = this.ctx.transform.applyToPoint(new v(K, pt));
    this.path.push({ type: "qct", x1: Rt.x, y1: Rt.y, x: Et.x, y: Et.y }), this.ctx.lastPoint = new v(Et.x, Et.y);
  }, O.prototype.bezierCurveTo = function(K, pt, xt, Tt, Et, Rt) {
    if (isNaN(Et) || isNaN(Rt) || isNaN(K) || isNaN(pt) || isNaN(xt) || isNaN(Tt)) throw dr.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var qt = this.ctx.transform.applyToPoint(new v(Et, Rt)), Gt = this.ctx.transform.applyToPoint(new v(K, pt)), we = this.ctx.transform.applyToPoint(new v(xt, Tt));
    this.path.push({ type: "bct", x1: Gt.x, y1: Gt.y, x2: we.x, y2: we.y, x: qt.x, y: qt.y }), this.ctx.lastPoint = new v(qt.x, qt.y);
  }, O.prototype.arc = function(K, pt, xt, Tt, Et, Rt) {
    if (isNaN(K) || isNaN(pt) || isNaN(xt) || isNaN(Tt) || isNaN(Et)) throw dr.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (Rt = !!Rt, !this.ctx.transform.isIdentity) {
      var qt = this.ctx.transform.applyToPoint(new v(K, pt));
      K = qt.x, pt = qt.y;
      var Gt = this.ctx.transform.applyToPoint(new v(0, xt)), we = this.ctx.transform.applyToPoint(new v(0, 0));
      xt = Math.sqrt(Math.pow(Gt.x - we.x, 2) + Math.pow(Gt.y - we.y, 2));
    }
    Math.abs(Et - Tt) >= 2 * Math.PI && (Tt = 0, Et = 2 * Math.PI), this.path.push({ type: "arc", x: K, y: pt, radius: xt, startAngle: Tt, endAngle: Et, counterclockwise: Rt });
  }, O.prototype.arcTo = function(K, pt, xt, Tt, Et) {
    throw new Error("arcTo not implemented.");
  }, O.prototype.rect = function(K, pt, xt, Tt) {
    if (isNaN(K) || isNaN(pt) || isNaN(xt) || isNaN(Tt)) throw dr.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(K, pt), this.lineTo(K + xt, pt), this.lineTo(K + xt, pt + Tt), this.lineTo(K, pt + Tt), this.lineTo(K, pt), this.lineTo(K + xt, pt), this.lineTo(K, pt);
  }, O.prototype.fillRect = function(K, pt, xt, Tt) {
    if (isNaN(K) || isNaN(pt) || isNaN(xt) || isNaN(Tt)) throw dr.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!F.call(this)) {
      var Et = {};
      this.lineCap !== "butt" && (Et.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (Et.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(K, pt, xt, Tt), this.fill(), Et.hasOwnProperty("lineCap") && (this.lineCap = Et.lineCap), Et.hasOwnProperty("lineJoin") && (this.lineJoin = Et.lineJoin);
    }
  }, O.prototype.strokeRect = function(K, pt, xt, Tt) {
    if (isNaN(K) || isNaN(pt) || isNaN(xt) || isNaN(Tt)) throw dr.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    mt.call(this) || (this.beginPath(), this.rect(K, pt, xt, Tt), this.stroke());
  }, O.prototype.clearRect = function(K, pt, xt, Tt) {
    if (isNaN(K) || isNaN(pt) || isNaN(xt) || isNaN(Tt)) throw dr.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(K, pt, xt, Tt));
  }, O.prototype.save = function(K) {
    K = typeof K != "boolean" || K;
    for (var pt = this.pdf.internal.getCurrentPageInfo().pageNumber, xt = 0; xt < this.pdf.internal.getNumberOfPages(); xt++) this.pdf.setPage(xt + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(pt), K) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Tt = new X(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Tt;
    }
  }, O.prototype.restore = function(K) {
    K = typeof K != "boolean" || K;
    for (var pt = this.pdf.internal.getCurrentPageInfo().pageNumber, xt = 0; xt < this.pdf.internal.getNumberOfPages(); xt++) this.pdf.setPage(xt + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(pt), K && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, O.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var j = function(K) {
    var pt, xt, Tt, Et;
    if (K.isCanvasGradient === !0 && (K = K.getColor()), !K) return { r: 0, g: 0, b: 0, a: 0, style: K };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(K)) pt = 0, xt = 0, Tt = 0, Et = 0;
    else {
      var Rt = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(K);
      if (Rt !== null) pt = parseInt(Rt[1]), xt = parseInt(Rt[2]), Tt = parseInt(Rt[3]), Et = 1;
      else if ((Rt = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(K)) !== null) pt = parseInt(Rt[1]), xt = parseInt(Rt[2]), Tt = parseInt(Rt[3]), Et = parseFloat(Rt[4]);
      else {
        if (Et = 1, typeof K == "string" && K.charAt(0) !== "#") {
          var qt = new hf(K);
          K = qt.ok ? qt.toHex() : "#000000";
        }
        K.length === 4 ? (pt = K.substring(1, 2), pt += pt, xt = K.substring(2, 3), xt += xt, Tt = K.substring(3, 4), Tt += Tt) : (pt = K.substring(1, 3), xt = K.substring(3, 5), Tt = K.substring(5, 7)), pt = parseInt(pt, 16), xt = parseInt(xt, 16), Tt = parseInt(Tt, 16);
      }
    }
    return { r: pt, g: xt, b: Tt, a: Et, style: K };
  }, F = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, mt = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  O.prototype.fillText = function(K, pt, xt, Tt) {
    if (isNaN(pt) || isNaN(xt) || typeof K != "string") throw dr.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Tt = isNaN(Tt) ? void 0 : Tt, !F.call(this)) {
      var Et = jt(this.ctx.transform.rotation), Rt = this.ctx.transform.scaleX;
      lt.call(this, { text: K, x: pt, y: xt, scale: Rt, angle: Et, align: this.textAlign, maxWidth: Tt });
    }
  }, O.prototype.strokeText = function(K, pt, xt, Tt) {
    if (isNaN(pt) || isNaN(xt) || typeof K != "string") throw dr.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!mt.call(this)) {
      Tt = isNaN(Tt) ? void 0 : Tt;
      var Et = jt(this.ctx.transform.rotation), Rt = this.ctx.transform.scaleX;
      lt.call(this, { text: K, x: pt, y: xt, scale: Rt, renderingMode: "stroke", angle: Et, align: this.textAlign, maxWidth: Tt });
    }
  }, O.prototype.measureText = function(K) {
    if (typeof K != "string") throw dr.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var pt = this.pdf, xt = this.pdf.internal.scaleFactor, Tt = pt.internal.getFontSize(), Et = pt.getStringUnitWidth(K) * Tt / pt.internal.scaleFactor, Rt = function(qt) {
      var Gt = (qt = qt || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return Gt;
      } }), this;
    };
    return new Rt({ width: Et *= Math.round(96 * xt / 72 * 1e4) / 1e4 });
  }, O.prototype.scale = function(K, pt) {
    if (isNaN(K) || isNaN(pt)) throw dr.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var xt = new z(K, 0, 0, pt, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(xt);
  }, O.prototype.rotate = function(K) {
    if (isNaN(K)) throw dr.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var pt = new z(Math.cos(K), Math.sin(K), -Math.sin(K), Math.cos(K), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(pt);
  }, O.prototype.translate = function(K, pt) {
    if (isNaN(K) || isNaN(pt)) throw dr.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var xt = new z(1, 0, 0, 1, K, pt);
    this.ctx.transform = this.ctx.transform.multiply(xt);
  }, O.prototype.transform = function(K, pt, xt, Tt, Et, Rt) {
    if (isNaN(K) || isNaN(pt) || isNaN(xt) || isNaN(Tt) || isNaN(Et) || isNaN(Rt)) throw dr.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var qt = new z(K, pt, xt, Tt, Et, Rt);
    this.ctx.transform = this.ctx.transform.multiply(qt);
  }, O.prototype.setTransform = function(K, pt, xt, Tt, Et, Rt) {
    K = isNaN(K) ? 1 : K, pt = isNaN(pt) ? 0 : pt, xt = isNaN(xt) ? 0 : xt, Tt = isNaN(Tt) ? 1 : Tt, Et = isNaN(Et) ? 0 : Et, Rt = isNaN(Rt) ? 0 : Rt, this.ctx.transform = new z(K, pt, xt, Tt, Et, Rt);
  };
  var ot = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  O.prototype.drawImage = function(K, pt, xt, Tt, Et, Rt, qt, Gt, we) {
    var be = this.pdf.getImageProperties(K), Ie = 1, Pe = 1, ti = 1, Qt = 1;
    Tt !== void 0 && Gt !== void 0 && (ti = Gt / Tt, Qt = we / Et, Ie = be.width / Tt * Gt / Tt, Pe = be.height / Et * we / Et), Rt === void 0 && (Rt = pt, qt = xt, pt = 0, xt = 0), Tt !== void 0 && Gt === void 0 && (Gt = Tt, we = Et), Tt === void 0 && Gt === void 0 && (Gt = be.width, we = be.height);
    for (var Y, ui = this.ctx.transform.decompose(), Ge = jt(ui.rotate.shx), se = new z(), _e = (se = (se = (se = se.multiply(ui.translate)).multiply(ui.skew)).multiply(ui.scale)).applyToRectangle(new c(Rt - pt * ti, qt - xt * Qt, Tt * Ie, Et * Pe)), ze = yt.call(this, _e), ke = [], Ze = 0; Ze < ze.length; Ze += 1) ke.indexOf(ze[Ze]) === -1 && ke.push(ze[Ze]);
    if (zt(ke), this.autoPaging) for (var di = ke[0], ai = ke[ke.length - 1], wi = di; wi < ai + 1; wi++) {
      this.pdf.setPage(wi);
      var Ei = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], oe = wi === 1 ? this.posY + this.margin[0] : this.margin[0], ei = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], oi = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Te = wi === 1 ? 0 : ei + (wi - 2) * oi;
      if (this.ctx.clip_path.length !== 0) {
        var cr = this.path;
        Y = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = gt(Y, this.posX + this.margin[3], -Te + oe + this.ctx.prevPageLastElemOffset), Kt.call(this, "fill", !0), this.path = cr;
      }
      var le = JSON.parse(JSON.stringify(_e));
      le = gt([le], this.posX + this.margin[3], -Te + oe + this.ctx.prevPageLastElemOffset)[0];
      var si = (wi > di || wi < ai) && ot.call(this);
      si && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ei, oi, null).clip().discardPath()), this.pdf.addImage(K, "JPEG", le.x, le.y, le.w, le.h, null, null, Ge), si && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(K, "JPEG", _e.x, _e.y, _e.w, _e.h, null, null, Ge);
  };
  var yt = function(K, pt, xt) {
    var Tt = [];
    pt = pt || this.pdf.internal.pageSize.width, xt = xt || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var Et = this.posY + this.ctx.prevPageLastElemOffset;
    switch (K.type) {
      default:
      case "mt":
      case "lt":
        Tt.push(Math.floor((K.y + Et) / xt) + 1);
        break;
      case "arc":
        Tt.push(Math.floor((K.y + Et - K.radius) / xt) + 1), Tt.push(Math.floor((K.y + Et + K.radius) / xt) + 1);
        break;
      case "qct":
        var Rt = ee(this.ctx.lastPoint.x, this.ctx.lastPoint.y, K.x1, K.y1, K.x, K.y);
        Tt.push(Math.floor((Rt.y + Et) / xt) + 1), Tt.push(Math.floor((Rt.y + Rt.h + Et) / xt) + 1);
        break;
      case "bct":
        var qt = ie(this.ctx.lastPoint.x, this.ctx.lastPoint.y, K.x1, K.y1, K.x2, K.y2, K.x, K.y);
        Tt.push(Math.floor((qt.y + Et) / xt) + 1), Tt.push(Math.floor((qt.y + qt.h + Et) / xt) + 1);
        break;
      case "rect":
        Tt.push(Math.floor((K.y + Et) / xt) + 1), Tt.push(Math.floor((K.y + K.h + Et) / xt) + 1);
    }
    for (var Gt = 0; Gt < Tt.length; Gt += 1) for (; this.pdf.internal.getNumberOfPages() < Tt[Gt]; ) st.call(this);
    return Tt;
  }, st = function() {
    var K = this.fillStyle, pt = this.strokeStyle, xt = this.font, Tt = this.lineCap, Et = this.lineWidth, Rt = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = K, this.strokeStyle = pt, this.font = xt, this.lineCap = Tt, this.lineWidth = Et, this.lineJoin = Rt;
  }, gt = function(K, pt, xt) {
    for (var Tt = 0; Tt < K.length; Tt++) switch (K[Tt].type) {
      case "bct":
        K[Tt].x2 += pt, K[Tt].y2 += xt;
      case "qct":
        K[Tt].x1 += pt, K[Tt].y1 += xt;
      case "mt":
      case "lt":
      case "arc":
      default:
        K[Tt].x += pt, K[Tt].y += xt;
    }
    return K;
  }, zt = function(K) {
    return K.sort(function(pt, xt) {
      return pt - xt;
    });
  }, Jt = function(K, pt) {
    for (var xt, Tt, Et = this.fillStyle, Rt = this.strokeStyle, qt = this.lineCap, Gt = this.lineWidth, we = Math.abs(Gt * this.ctx.transform.scaleX), be = this.lineJoin, Ie = JSON.parse(JSON.stringify(this.path)), Pe = JSON.parse(JSON.stringify(this.path)), ti = [], Qt = 0; Qt < Pe.length; Qt++) if (Pe[Qt].x !== void 0) for (var Y = yt.call(this, Pe[Qt]), ui = 0; ui < Y.length; ui += 1) ti.indexOf(Y[ui]) === -1 && ti.push(Y[ui]);
    for (var Ge = 0; Ge < ti.length; Ge++) for (; this.pdf.internal.getNumberOfPages() < ti[Ge]; ) st.call(this);
    if (zt(ti), this.autoPaging) for (var se = ti[0], _e = ti[ti.length - 1], ze = se; ze < _e + 1; ze++) {
      this.pdf.setPage(ze), this.fillStyle = Et, this.strokeStyle = Rt, this.lineCap = qt, this.lineWidth = we, this.lineJoin = be;
      var ke = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Ze = ze === 1 ? this.posY + this.margin[0] : this.margin[0], di = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], ai = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], wi = ze === 1 ? 0 : di + (ze - 2) * ai;
      if (this.ctx.clip_path.length !== 0) {
        var Ei = this.path;
        xt = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = gt(xt, this.posX + this.margin[3], -wi + Ze + this.ctx.prevPageLastElemOffset), Kt.call(this, K, !0), this.path = Ei;
      }
      if (Tt = JSON.parse(JSON.stringify(Ie)), this.path = gt(Tt, this.posX + this.margin[3], -wi + Ze + this.ctx.prevPageLastElemOffset), pt === !1 || ze === 0) {
        var oe = (ze > se || ze < _e) && ot.call(this);
        oe && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], ke, ai, null).clip().discardPath()), Kt.call(this, K, pt), oe && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = Gt;
    }
    else this.lineWidth = we, Kt.call(this, K, pt), this.lineWidth = Gt;
    this.path = Ie;
  }, Kt = function(K, pt) {
    if ((K !== "stroke" || pt || !mt.call(this)) && (K === "stroke" || pt || !F.call(this))) {
      for (var xt, Tt, Et = [], Rt = this.path, qt = 0; qt < Rt.length; qt++) {
        var Gt = Rt[qt];
        switch (Gt.type) {
          case "begin":
            Et.push({ begin: !0 });
            break;
          case "close":
            Et.push({ close: !0 });
            break;
          case "mt":
            Et.push({ start: Gt, deltas: [], abs: [] });
            break;
          case "lt":
            var we = Et.length;
            if (Rt[qt - 1] && !isNaN(Rt[qt - 1].x) && (xt = [Gt.x - Rt[qt - 1].x, Gt.y - Rt[qt - 1].y], we > 0)) {
              for (; we >= 0; we--) if (Et[we - 1].close !== !0 && Et[we - 1].begin !== !0) {
                Et[we - 1].deltas.push(xt), Et[we - 1].abs.push(Gt);
                break;
              }
            }
            break;
          case "bct":
            xt = [Gt.x1 - Rt[qt - 1].x, Gt.y1 - Rt[qt - 1].y, Gt.x2 - Rt[qt - 1].x, Gt.y2 - Rt[qt - 1].y, Gt.x - Rt[qt - 1].x, Gt.y - Rt[qt - 1].y], Et[Et.length - 1].deltas.push(xt);
            break;
          case "qct":
            var be = Rt[qt - 1].x + 2 / 3 * (Gt.x1 - Rt[qt - 1].x), Ie = Rt[qt - 1].y + 2 / 3 * (Gt.y1 - Rt[qt - 1].y), Pe = Gt.x + 2 / 3 * (Gt.x1 - Gt.x), ti = Gt.y + 2 / 3 * (Gt.y1 - Gt.y), Qt = Gt.x, Y = Gt.y;
            xt = [be - Rt[qt - 1].x, Ie - Rt[qt - 1].y, Pe - Rt[qt - 1].x, ti - Rt[qt - 1].y, Qt - Rt[qt - 1].x, Y - Rt[qt - 1].y], Et[Et.length - 1].deltas.push(xt);
            break;
          case "arc":
            Et.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(Et[Et.length - 1].abs) && Et[Et.length - 1].abs.push(Gt);
        }
      }
      Tt = pt ? null : K === "stroke" ? "stroke" : "fill";
      for (var ui = !1, Ge = 0; Ge < Et.length; Ge++) if (Et[Ge].arc) for (var se = Et[Ge].abs, _e = 0; _e < se.length; _e++) {
        var ze = se[_e];
        ze.type === "arc" ? kt.call(this, ze.x, ze.y, ze.radius, ze.startAngle, ze.endAngle, ze.counterclockwise, void 0, pt, !ui) : It.call(this, ze.x, ze.y), ui = !0;
      }
      else if (Et[Ge].close === !0) this.pdf.internal.out("h"), ui = !1;
      else if (Et[Ge].begin !== !0) {
        var ke = Et[Ge].start.x, Ze = Et[Ge].start.y;
        St.call(this, Et[Ge].deltas, ke, Ze), ui = !0;
      }
      Tt && $t.call(this, Tt), pt && ae.call(this);
    }
  }, pe = function(K) {
    var pt = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, xt = pt * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return K - xt;
      case "top":
        return K + pt - xt;
      case "hanging":
        return K + pt - 2 * xt;
      case "middle":
        return K + pt / 2 - xt;
      case "ideographic":
        return K;
      case "alphabetic":
      default:
        return K;
    }
  }, Ot = function(K) {
    return K + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  O.prototype.createLinearGradient = function() {
    var K = function() {
    };
    return K.colorStops = [], K.addColorStop = function(pt, xt) {
      this.colorStops.push([pt, xt]);
    }, K.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, K.isCanvasGradient = !0, K;
  }, O.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, O.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var kt = function(K, pt, xt, Tt, Et, Rt, qt, Gt, we) {
    for (var be = Xt.call(this, xt, Tt, Et, Rt), Ie = 0; Ie < be.length; Ie++) {
      var Pe = be[Ie];
      Ie === 0 && (we ? at.call(this, Pe.x1 + K, Pe.y1 + pt) : It.call(this, Pe.x1 + K, Pe.y1 + pt)), Wt.call(this, K, pt, Pe.x2, Pe.y2, Pe.x3, Pe.y3, Pe.x4, Pe.y4);
    }
    Gt ? ae.call(this) : $t.call(this, qt);
  }, $t = function(K) {
    switch (K) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, ae = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, at = function(K, pt) {
    this.pdf.internal.out(y(K) + " " + b(pt) + " m");
  }, lt = function(K) {
    var pt;
    switch (K.align) {
      case "right":
      case "end":
        pt = "right";
        break;
      case "center":
        pt = "center";
        break;
      case "left":
      case "start":
      default:
        pt = "left";
    }
    var xt = this.pdf.getTextDimensions(K.text), Tt = pe.call(this, K.y), Et = Ot.call(this, Tt) - xt.h, Rt = this.ctx.transform.applyToPoint(new v(K.x, Tt)), qt = this.ctx.transform.decompose(), Gt = new z();
    Gt = (Gt = (Gt = Gt.multiply(qt.translate)).multiply(qt.skew)).multiply(qt.scale);
    for (var we, be, Ie, Pe = this.ctx.transform.applyToRectangle(new c(K.x, Tt, xt.w, xt.h)), ti = Gt.applyToRectangle(new c(K.x, Et, xt.w, xt.h)), Qt = yt.call(this, ti), Y = [], ui = 0; ui < Qt.length; ui += 1) Y.indexOf(Qt[ui]) === -1 && Y.push(Qt[ui]);
    if (zt(Y), this.autoPaging) for (var Ge = Y[0], se = Y[Y.length - 1], _e = Ge; _e < se + 1; _e++) {
      this.pdf.setPage(_e);
      var ze = _e === 1 ? this.posY + this.margin[0] : this.margin[0], ke = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Ze = this.pdf.internal.pageSize.height - this.margin[2], di = Ze - this.margin[0], ai = this.pdf.internal.pageSize.width - this.margin[1], wi = ai - this.margin[3], Ei = _e === 1 ? 0 : ke + (_e - 2) * di;
      if (this.ctx.clip_path.length !== 0) {
        var oe = this.path;
        we = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = gt(we, this.posX + this.margin[3], -1 * Ei + ze), Kt.call(this, "fill", !0), this.path = oe;
      }
      var ei = gt([JSON.parse(JSON.stringify(ti))], this.posX + this.margin[3], -Ei + ze + this.ctx.prevPageLastElemOffset)[0];
      K.scale >= 0.01 && (be = this.pdf.internal.getFontSize(), this.pdf.setFontSize(be * K.scale), Ie = this.lineWidth, this.lineWidth = Ie * K.scale);
      var oi = this.autoPaging !== "text";
      if (oi || ei.y + ei.h <= Ze) {
        if (oi || ei.y >= ze && ei.x <= ai) {
          var Te = oi ? K.text : this.pdf.splitTextToSize(K.text, K.maxWidth || ai - ei.x)[0], cr = gt([JSON.parse(JSON.stringify(Pe))], this.posX + this.margin[3], -Ei + ze + this.ctx.prevPageLastElemOffset)[0], le = oi && (_e > Ge || _e < se) && ot.call(this);
          le && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], wi, di, null).clip().discardPath()), this.pdf.text(Te, cr.x, cr.y, { angle: K.angle, align: pt, renderingMode: K.renderingMode }), le && this.pdf.restoreGraphicsState();
        }
      } else ei.y < Ze && (this.ctx.prevPageLastElemOffset += Ze - ei.y);
      K.scale >= 0.01 && (this.pdf.setFontSize(be), this.lineWidth = Ie);
    }
    else K.scale >= 0.01 && (be = this.pdf.internal.getFontSize(), this.pdf.setFontSize(be * K.scale), Ie = this.lineWidth, this.lineWidth = Ie * K.scale), this.pdf.text(K.text, Rt.x + this.posX, Rt.y + this.posY, { angle: K.angle, align: pt, renderingMode: K.renderingMode, maxWidth: K.maxWidth }), K.scale >= 0.01 && (this.pdf.setFontSize(be), this.lineWidth = Ie);
  }, It = function(K, pt, xt, Tt) {
    xt = xt || 0, Tt = Tt || 0, this.pdf.internal.out(y(K + xt) + " " + b(pt + Tt) + " l");
  }, St = function(K, pt, xt) {
    return this.pdf.lines(K, pt, xt, null, null);
  }, Wt = function(K, pt, xt, Tt, Et, Rt, qt, Gt) {
    this.pdf.internal.out([f(k(xt + K)), f(P(Tt + pt)), f(k(Et + K)), f(P(Rt + pt)), f(k(qt + K)), f(P(Gt + pt)), "c"].join(" "));
  }, Xt = function(K, pt, xt, Tt) {
    for (var Et = 2 * Math.PI, Rt = Math.PI / 2; pt > xt; ) pt -= Et;
    var qt = Math.abs(xt - pt);
    qt < Et && Tt && (qt = Et - qt);
    for (var Gt = [], we = Tt ? -1 : 1, be = pt; qt > 1e-5; ) {
      var Ie = be + we * Math.min(qt, Rt);
      Gt.push(Ht.call(this, K, be, Ie)), qt -= Math.abs(Ie - be), be = Ie;
    }
    return Gt;
  }, Ht = function(K, pt, xt) {
    var Tt = (xt - pt) / 2, Et = K * Math.cos(Tt), Rt = K * Math.sin(Tt), qt = Et, Gt = -Rt, we = qt * qt + Gt * Gt, be = we + qt * Et + Gt * Rt, Ie = 4 / 3 * (Math.sqrt(2 * we * be) - be) / (qt * Rt - Gt * Et), Pe = qt - Ie * Gt, ti = Gt + Ie * qt, Qt = Pe, Y = -ti, ui = Tt + pt, Ge = Math.cos(ui), se = Math.sin(ui);
    return { x1: K * Math.cos(pt), y1: K * Math.sin(pt), x2: Pe * Ge - ti * se, y2: Pe * se + ti * Ge, x3: Qt * Ge - Y * se, y3: Qt * se + Y * Ge, x4: K * Math.cos(xt), y4: K * Math.sin(xt) };
  }, jt = function(K) {
    return 180 * K / Math.PI;
  }, ee = function(K, pt, xt, Tt, Et, Rt) {
    var qt = K + 0.5 * (xt - K), Gt = pt + 0.5 * (Tt - pt), we = Et + 0.5 * (xt - Et), be = Rt + 0.5 * (Tt - Rt), Ie = Math.min(K, Et, qt, we), Pe = Math.max(K, Et, qt, we), ti = Math.min(pt, Rt, Gt, be), Qt = Math.max(pt, Rt, Gt, be);
    return new c(Ie, ti, Pe - Ie, Qt - ti);
  }, ie = function(K, pt, xt, Tt, Et, Rt, qt, Gt) {
    var we, be, Ie, Pe, ti, Qt, Y, ui, Ge, se, _e, ze, ke, Ze, di = xt - K, ai = Tt - pt, wi = Et - xt, Ei = Rt - Tt, oe = qt - Et, ei = Gt - Rt;
    for (be = 0; be < 41; be++) Ge = (Y = (Ie = K + (we = be / 40) * di) + we * ((ti = xt + we * wi) - Ie)) + we * (ti + we * (Et + we * oe - ti) - Y), se = (ui = (Pe = pt + we * ai) + we * ((Qt = Tt + we * Ei) - Pe)) + we * (Qt + we * (Rt + we * ei - Qt) - ui), be == 0 ? (_e = Ge, ze = se, ke = Ge, Ze = se) : (_e = Math.min(_e, Ge), ze = Math.min(ze, se), ke = Math.max(ke, Ge), Ze = Math.max(Ze, se));
    return new c(Math.round(_e), Math.round(ze), Math.round(ke - _e), Math.round(Ze - ze));
  }, Se = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var K, pt, xt = (K = this.ctx.lineDash, pt = this.ctx.lineDashOffset, JSON.stringify({ lineDash: K, lineDashOffset: pt }));
      this.prevLineDash !== xt && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = xt);
    }
  };
})(_i.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var f = function(P) {
    var v, c, z, U, X, O, j, F, mt, ot;
    for (c = [], z = 0, U = (P += v = "\0\0\0\0".slice(P.length % 4 || 4)).length; U > z; z += 4) (X = (P.charCodeAt(z) << 24) + (P.charCodeAt(z + 1) << 16) + (P.charCodeAt(z + 2) << 8) + P.charCodeAt(z + 3)) !== 0 ? (O = (X = ((X = ((X = ((X = (X - (ot = X % 85)) / 85) - (mt = X % 85)) / 85) - (F = X % 85)) / 85) - (j = X % 85)) / 85) % 85, c.push(O + 33, j + 33, F + 33, mt + 33, ot + 33)) : c.push(122);
    return function(yt, st) {
      for (var gt = st; gt > 0; gt--) yt.pop();
    }(c, v.length), String.fromCharCode.apply(String, c) + "~>";
  }, y = function(P) {
    var v, c, z, U, X, O = String, j = "length", F = 255, mt = "charCodeAt", ot = "slice", yt = "replace";
    for (P[ot](-2), P = P[ot](0, -2)[yt](/\s/g, "")[yt]("z", "!!!!!"), z = [], U = 0, X = (P += v = "uuuuu"[ot](P[j] % 5 || 5))[j]; X > U; U += 5) c = 52200625 * (P[mt](U) - 33) + 614125 * (P[mt](U + 1) - 33) + 7225 * (P[mt](U + 2) - 33) + 85 * (P[mt](U + 3) - 33) + (P[mt](U + 4) - 33), z.push(F & c >> 24, F & c >> 16, F & c >> 8, F & c);
    return function(st, gt) {
      for (var zt = gt; zt > 0; zt--) st.pop();
    }(z, v[j]), O.fromCharCode.apply(O, z);
  }, b = function(P) {
    var v = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((P = P.replace(/\s/g, "")).indexOf(">") !== -1 && (P = P.substr(0, P.indexOf(">"))), P.length % 2 && (P += "0"), v.test(P) === !1) return "";
    for (var c = "", z = 0; z < P.length; z += 2) c += String.fromCharCode("0x" + (P[z] + P[z + 1]));
    return c;
  }, k = function(P) {
    for (var v = new Uint8Array(P.length), c = P.length; c--; ) v[c] = P.charCodeAt(c);
    return P = (v = $u(v)).reduce(function(z, U) {
      return z + String.fromCharCode(U);
    }, "");
  };
  x.processDataByFilters = function(P, v) {
    var c = 0, z = P || "", U = [];
    for (typeof (v = v || []) == "string" && (v = [v]), c = 0; c < v.length; c += 1) switch (v[c]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        z = y(z), U.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        z = f(z), U.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        z = b(z), U.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        z = z.split("").map(function(X) {
          return ("0" + X.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", U.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        z = k(z), U.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + v[c] + '" is not implemented');
    }
    return { data: z, reverseChain: U.reverse().join(" ") };
  };
}(_i.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  x.loadFile = function(f, y, b) {
    return function(k, P, v) {
      P = P !== !1, v = typeof v == "function" ? v : function() {
      };
      var c = void 0;
      try {
        c = function(z, U, X) {
          var O = new XMLHttpRequest(), j = 0, F = function(mt) {
            var ot = mt.length, yt = [], st = String.fromCharCode;
            for (j = 0; j < ot; j += 1) yt.push(st(255 & mt.charCodeAt(j)));
            return yt.join("");
          };
          if (O.open("GET", z, !U), O.overrideMimeType("text/plain; charset=x-user-defined"), U === !1 && (O.onload = function() {
            O.status === 200 ? X(F(this.responseText)) : X(void 0);
          }), O.send(null), U && O.status === 200) return F(O.responseText);
        }(k, P, v);
      } catch {
      }
      return c;
    }(f, y, b);
  }, x.loadImageFile = x.loadFile;
}(_i.API), function(x) {
  function f() {
    return (vi.html2canvas ? Promise.resolve(vi.html2canvas) : import("./html2canvas.esm-d2sM-0Wm-BdPOovWT.js")).catch(function(v) {
      return Promise.reject(new Error("Could not load html2canvas: " + v));
    }).then(function(v) {
      return v.default ? v.default : v;
    });
  }
  function y() {
    return (vi.DOMPurify ? Promise.resolve(vi.DOMPurify) : import("./purify.es-CKk_t3XZ-DjG8hwOo.js")).catch(function(v) {
      return Promise.reject(new Error("Could not load dompurify: " + v));
    }).then(function(v) {
      return v.default ? v.default : v;
    });
  }
  var b = function(v) {
    var c = nr(v);
    return c === "undefined" ? "undefined" : c === "string" || v instanceof String ? "string" : c === "number" || v instanceof Number ? "number" : c === "function" || v instanceof Function ? "function" : v && v.constructor === Array ? "array" : v && v.nodeType === 1 ? "element" : c === "object" ? "object" : "unknown";
  }, k = function(v, c) {
    var z = document.createElement(v);
    for (var U in c.className && (z.className = c.className), c.innerHTML && c.dompurify && (z.innerHTML = c.dompurify.sanitize(c.innerHTML)), c.style) z.style[U] = c.style[U];
    return z;
  }, P = function v(c) {
    var z = Object.assign(v.convert(Promise.resolve()), JSON.parse(JSON.stringify(v.template))), U = v.convert(Promise.resolve(), z);
    return U = (U = U.setProgress(1, v, 1, [v])).set(c);
  };
  (P.prototype = Object.create(Promise.prototype)).constructor = P, P.convert = function(v, c) {
    return v.__proto__ = c || P.prototype, v;
  }, P.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, P.prototype.from = function(v, c) {
    return this.then(function() {
      switch (c = c || function(z) {
        switch (b(z)) {
          case "string":
            return "string";
          case "element":
            return z.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(v)) {
        case "string":
          return this.then(y).then(function(z) {
            return this.set({ src: k("div", { innerHTML: v, dompurify: z }) });
          });
        case "element":
          return this.set({ src: v });
        case "canvas":
          return this.set({ canvas: v });
        case "img":
          return this.set({ img: v });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, P.prototype.to = function(v) {
    switch (v) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, P.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var v = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, c = function z(U, X) {
        for (var O = U.nodeType === 3 ? document.createTextNode(U.nodeValue) : U.cloneNode(!1), j = U.firstChild; j; j = j.nextSibling) X !== !0 && j.nodeType === 1 && j.nodeName === "SCRIPT" || O.appendChild(z(j, X));
        return U.nodeType === 1 && (U.nodeName === "CANVAS" ? (O.width = U.width, O.height = U.height, O.getContext("2d").drawImage(U, 0, 0)) : U.nodeName !== "TEXTAREA" && U.nodeName !== "SELECT" || (O.value = U.value), O.addEventListener("load", function() {
          O.scrollTop = U.scrollTop, O.scrollLeft = U.scrollLeft;
        }, !0)), O;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      c.tagName === "BODY" && (v.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = k("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = k("div", { className: "html2pdf__container", style: v }), this.prop.container.appendChild(c), this.prop.container.firstChild.appendChild(k("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, P.prototype.toCanvas = function() {
    var v = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(v).then(f).then(function(c) {
      var z = Object.assign({}, this.opt.html2canvas);
      return delete z.onrendered, c(this.prop.container, z);
    }).then(function(c) {
      (this.opt.html2canvas.onrendered || function() {
      })(c), this.prop.canvas = c, document.body.removeChild(this.prop.overlay);
    });
  }, P.prototype.toContext2d = function() {
    var v = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(v).then(f).then(function(c) {
      var z = this.opt.jsPDF, U = this.opt.fontFaces, X = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, O = Object.assign({ async: !0, allowTaint: !0, scale: X, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete O.onrendered, z.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, z.context2d.posX = this.opt.x, z.context2d.posY = this.opt.y, z.context2d.margin = this.opt.margin, z.context2d.fontFaces = U, U) for (var j = 0; j < U.length; ++j) {
        var F = U[j], mt = F.src.find(function(ot) {
          return ot.format === "truetype";
        });
        mt && z.addFont(mt.url, F.ref.name, F.ref.style);
      }
      return O.windowHeight = O.windowHeight || 0, O.windowHeight = O.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : O.windowHeight, z.context2d.save(!0), c(this.prop.container, O);
    }).then(function(c) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(c), this.prop.canvas = c, document.body.removeChild(this.prop.overlay);
    });
  }, P.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var v = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = v;
    });
  }, P.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, P.prototype.output = function(v, c, z) {
    return (z = z || "pdf").toLowerCase() === "img" || z.toLowerCase() === "image" ? this.outputImg(v, c) : this.outputPdf(v, c);
  }, P.prototype.outputPdf = function(v, c) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(v, c);
    });
  }, P.prototype.outputImg = function(v) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (v) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + v + '" is not supported.';
      }
    });
  }, P.prototype.save = function(v) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(v ? { filename: v } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, P.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, P.prototype.set = function(v) {
    if (b(v) !== "object") return this;
    var c = Object.keys(v || {}).map(function(z) {
      if (z in P.template.prop) return function() {
        this.prop[z] = v[z];
      };
      switch (z) {
        case "margin":
          return this.setMargin.bind(this, v.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = v.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, v.pageSize);
        default:
          return function() {
            this.opt[z] = v[z];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(c);
    });
  }, P.prototype.get = function(v, c) {
    return this.then(function() {
      var z = v in P.template.prop ? this.prop[v] : this.opt[v];
      return c ? c(z) : z;
    });
  }, P.prototype.setMargin = function(v) {
    return this.then(function() {
      switch (b(v)) {
        case "number":
          v = [v, v, v, v];
        case "array":
          if (v.length === 2 && (v = [v[0], v[1], v[0], v[1]]), v.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = v;
    }).then(this.setPageSize);
  }, P.prototype.setPageSize = function(v) {
    function c(z, U) {
      return Math.floor(z * U / 72 * 96);
    }
    return this.then(function() {
      (v = v || _i.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (v.inner = { width: v.width - this.opt.margin[1] - this.opt.margin[3], height: v.height - this.opt.margin[0] - this.opt.margin[2] }, v.inner.px = { width: c(v.inner.width, v.k), height: c(v.inner.height, v.k) }, v.inner.ratio = v.inner.height / v.inner.width), this.prop.pageSize = v;
    });
  }, P.prototype.setProgress = function(v, c, z, U) {
    return v != null && (this.progress.val = v), c != null && (this.progress.state = c), z != null && (this.progress.n = z), U != null && (this.progress.stack = U), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, P.prototype.updateProgress = function(v, c, z, U) {
    return this.setProgress(v ? this.progress.val + v : null, c || null, z ? this.progress.n + z : null, U ? this.progress.stack.concat(U) : null);
  }, P.prototype.then = function(v, c) {
    var z = this;
    return this.thenCore(v, c, function(U, X) {
      return z.updateProgress(null, null, 1, [U]), Promise.prototype.then.call(this, function(O) {
        return z.updateProgress(null, U), O;
      }).then(U, X).then(function(O) {
        return z.updateProgress(1), O;
      });
    });
  }, P.prototype.thenCore = function(v, c, z) {
    z = z || Promise.prototype.then, v && (v = v.bind(this)), c && (c = c.bind(this));
    var U = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : P.convert(Object.assign({}, this), Promise.prototype), X = z.call(U, v, c);
    return P.convert(X, this.__proto__);
  }, P.prototype.thenExternal = function(v, c) {
    return Promise.prototype.then.call(this, v, c);
  }, P.prototype.thenList = function(v) {
    var c = this;
    return v.forEach(function(z) {
      c = c.thenCore(z);
    }), c;
  }, P.prototype.catch = function(v) {
    v && (v = v.bind(this));
    var c = Promise.prototype.catch.call(this, v);
    return P.convert(c, this);
  }, P.prototype.catchExternal = function(v) {
    return Promise.prototype.catch.call(this, v);
  }, P.prototype.error = function(v) {
    return this.then(function() {
      throw new Error(v);
    });
  }, P.prototype.using = P.prototype.set, P.prototype.saveAs = P.prototype.save, P.prototype.export = P.prototype.output, P.prototype.run = P.prototype.then, _i.getPageSize = function(v, c, z) {
    if (nr(v) === "object") {
      var U = v;
      v = U.orientation, c = U.unit || c, z = U.format || z;
    }
    c = c || "mm", z = z || "a4", v = ("" + (v || "P")).toLowerCase();
    var X, O = ("" + z).toLowerCase(), j = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (c) {
      case "pt":
        X = 1;
        break;
      case "mm":
        X = 72 / 25.4;
        break;
      case "cm":
        X = 72 / 2.54;
        break;
      case "in":
        X = 72;
        break;
      case "px":
        X = 0.75;
        break;
      case "pc":
      case "em":
        X = 12;
        break;
      case "ex":
        X = 6;
        break;
      default:
        throw "Invalid unit: " + c;
    }
    var F, mt = 0, ot = 0;
    if (j.hasOwnProperty(O)) mt = j[O][1] / X, ot = j[O][0] / X;
    else try {
      mt = z[1], ot = z[0];
    } catch {
      throw new Error("Invalid format: " + z);
    }
    if (v === "p" || v === "portrait") v = "p", ot > mt && (F = ot, ot = mt, mt = F);
    else {
      if (v !== "l" && v !== "landscape") throw "Invalid orientation: " + v;
      v = "l", mt > ot && (F = ot, ot = mt, mt = F);
    }
    return { width: ot, height: mt, unit: c, k: X, orientation: v };
  }, x.html = function(v, c) {
    (c = c || {}).callback = c.callback || function() {
    }, c.html2canvas = c.html2canvas || {}, c.html2canvas.canvas = c.html2canvas.canvas || this.canvas, c.jsPDF = c.jsPDF || this, c.fontFaces = c.fontFaces ? c.fontFaces.map(Ku) : null;
    var z = new P(c);
    return c.worker ? z : z.from(v).doCallback();
  };
}(_i.API), _i.API.addJS = function(x) {
  return Vp = x, this.internal.events.subscribe("postPutResources", function() {
    Fh = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Fh + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), Up = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Vp + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Fh !== void 0 && Up !== void 0 && this.internal.out("/Names <</JavaScript " + Fh + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var f;
  x.events.push(["postPutResources", function() {
    var y = this, b = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var k = y.outline.render().split(/\r\n/), P = 0; P < k.length; P++) {
      var v = k[P], c = b.exec(v);
      if (c != null) {
        var z = c[1];
        y.internal.newObjectDeferredBegin(z, !1);
      }
      y.internal.write(v);
    }
    if (this.outline.createNamedDestinations) {
      var U = this.internal.pages.length, X = [];
      for (P = 0; P < U; P++) {
        var O = y.internal.newObject();
        X.push(O);
        var j = y.internal.getPageInfo(P + 1);
        y.internal.write("<< /D[" + j.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var F = y.internal.newObject();
      for (y.internal.write("<< /Names [ "), P = 0; P < X.length; P++) y.internal.write("(page_" + (P + 1) + ")" + X[P] + " 0 R");
      y.internal.write(" ] >>", "endobj"), f = y.internal.newObject(), y.internal.write("<< /Dests " + F + " 0 R"), y.internal.write(">>", "endobj");
    }
  }]), x.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + f + " 0 R"));
  }]), x.events.push(["initialized", function() {
    var y = this;
    y.outline = { createNamedDestinations: !1, root: { children: [] } }, y.outline.add = function(b, k, P) {
      var v = { title: k, options: P, children: [] };
      return b == null && (b = this.root), b.children.push(v), v;
    }, y.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = y, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, y.outline.genIds_r = function(b) {
      b.id = y.internal.newObjectDeferred();
      for (var k = 0; k < b.children.length; k++) this.genIds_r(b.children[k]);
    }, y.outline.renderRoot = function(b) {
      this.objStart(b), this.line("/Type /Outlines"), b.children.length > 0 && (this.line("/First " + this.makeRef(b.children[0])), this.line("/Last " + this.makeRef(b.children[b.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, b)), this.objEnd();
    }, y.outline.renderItems = function(b) {
      for (var k = this.ctx.pdf.internal.getVerticalCoordinateString, P = 0; P < b.children.length; P++) {
        var v = b.children[P];
        this.objStart(v), this.line("/Title " + this.makeString(v.title)), this.line("/Parent " + this.makeRef(b)), P > 0 && this.line("/Prev " + this.makeRef(b.children[P - 1])), P < b.children.length - 1 && this.line("/Next " + this.makeRef(b.children[P + 1])), v.children.length > 0 && (this.line("/First " + this.makeRef(v.children[0])), this.line("/Last " + this.makeRef(v.children[v.children.length - 1])));
        var c = this.count = this.count_r({ count: 0 }, v);
        if (c > 0 && this.line("/Count " + c), v.options && v.options.pageNumber) {
          var z = y.internal.getPageInfo(v.options.pageNumber);
          this.line("/Dest [" + z.objId + " 0 R /XYZ 0 " + k(0) + " 0]");
        }
        this.objEnd();
      }
      for (var U = 0; U < b.children.length; U++) this.renderItems(b.children[U]);
    }, y.outline.line = function(b) {
      this.ctx.val += b + `\r
`;
    }, y.outline.makeRef = function(b) {
      return b.id + " 0 R";
    }, y.outline.makeString = function(b) {
      return "(" + y.internal.pdfEscape(b) + ")";
    }, y.outline.objStart = function(b) {
      this.ctx.val += `\r
` + b.id + ` 0 obj\r
<<\r
`;
    }, y.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, y.outline.count_r = function(b, k) {
      for (var P = 0; P < k.children.length; P++) b.count++, this.count_r(b, k.children[P]);
      return b.count;
    };
  }]);
}(_i.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var f = [192, 193, 194, 195, 196, 197, 198, 199];
  x.processJPEG = function(y, b, k, P, v, c) {
    var z, U = this.decode.DCT_DECODE, X = null;
    if (typeof y == "string" || this.__addimage__.isArrayBuffer(y) || this.__addimage__.isArrayBufferView(y)) {
      switch (y = v || y, y = this.__addimage__.isArrayBuffer(y) ? new Uint8Array(y) : y, (z = function(O) {
        for (var j, F = 256 * O.charCodeAt(4) + O.charCodeAt(5), mt = O.length, ot = { width: 0, height: 0, numcomponents: 1 }, yt = 4; yt < mt; yt += 2) {
          if (yt += F, f.indexOf(O.charCodeAt(yt + 1)) !== -1) {
            j = 256 * O.charCodeAt(yt + 5) + O.charCodeAt(yt + 6), ot = { width: 256 * O.charCodeAt(yt + 7) + O.charCodeAt(yt + 8), height: j, numcomponents: O.charCodeAt(yt + 9) };
            break;
          }
          F = 256 * O.charCodeAt(yt + 2) + O.charCodeAt(yt + 3);
        }
        return ot;
      }(y = this.__addimage__.isArrayBufferView(y) ? this.__addimage__.arrayBufferToBinaryString(y) : y)).numcomponents) {
        case 1:
          c = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          c = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          c = this.color_spaces.DEVICE_RGB;
      }
      X = { data: y, width: z.width, height: z.height, colorSpace: c, bitsPerComponent: 8, filter: U, index: b, alias: k };
    }
    return X;
  };
}(_i.API);
var kc, Bh, $p, Zp, Wp, p0 = function() {
  var x, f, y;
  function b(P) {
    var v, c, z, U, X, O, j, F, mt, ot, yt, st, gt, zt;
    for (this.data = P, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, O = null; ; ) {
      switch (v = this.readUInt32(), mt = (function() {
        var Jt, Kt;
        for (Kt = [], Jt = 0; Jt < 4; ++Jt) Kt.push(String.fromCharCode(this.data[this.pos++]));
        return Kt;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(v);
          break;
        case "fcTL":
          O && this.animation.frames.push(O), this.pos += 4, O = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, X = this.readUInt16(), U = this.readUInt16() || 100, O.delay = 1e3 * X / U, O.disposeOp = this.data[this.pos++], O.blendOp = this.data[this.pos++], O.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (mt === "fdAT" && (this.pos += 4, v -= 4), P = (O != null ? O.data : void 0) || this.imgData, st = 0; 0 <= v ? st < v : st > v; 0 <= v ? ++st : --st) P.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (z = this.palette.length / 3, this.transparency.indexed = this.read(v), this.transparency.indexed.length > z) throw new Error("More transparent colors than palette size");
              if ((ot = z - this.transparency.indexed.length) > 0) for (gt = 0; 0 <= ot ? gt < ot : gt > ot; 0 <= ot ? ++gt : --gt) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(v)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(v);
          }
          break;
        case "tEXt":
          j = (yt = this.read(v)).indexOf(0), F = String.fromCharCode.apply(String, yt.slice(0, j)), this.text[F] = String.fromCharCode.apply(String, yt.slice(j + 1));
          break;
        case "IEND":
          return O && this.animation.frames.push(O), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (zt = this.colorType) === 4 || zt === 6, c = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * c, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += v;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  b.prototype.read = function(P) {
    var v, c;
    for (c = [], v = 0; 0 <= P ? v < P : v > P; 0 <= P ? ++v : --v) c.push(this.data[this.pos++]);
    return c;
  }, b.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, b.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, b.prototype.decodePixels = function(P) {
    var v = this.pixelBitlength / 8, c = new Uint8Array(this.width * this.height * v), z = 0, U = this;
    if (P == null && (P = this.imgData), P.length === 0) return new Uint8Array(0);
    function X(O, j, F, mt) {
      var ot, yt, st, gt, zt, Jt, Kt, pe, Ot, kt, $t, ae, at, lt, It, St, Wt, Xt, Ht, jt, ee, ie = Math.ceil((U.width - O) / F), Se = Math.ceil((U.height - j) / mt), K = U.width == ie && U.height == Se;
      for (lt = v * ie, ae = K ? c : new Uint8Array(lt * Se), Jt = P.length, at = 0, yt = 0; at < Se && z < Jt; ) {
        switch (P[z++]) {
          case 0:
            for (gt = Wt = 0; Wt < lt; gt = Wt += 1) ae[yt++] = P[z++];
            break;
          case 1:
            for (gt = Xt = 0; Xt < lt; gt = Xt += 1) ot = P[z++], zt = gt < v ? 0 : ae[yt - v], ae[yt++] = (ot + zt) % 256;
            break;
          case 2:
            for (gt = Ht = 0; Ht < lt; gt = Ht += 1) ot = P[z++], st = (gt - gt % v) / v, It = at && ae[(at - 1) * lt + st * v + gt % v], ae[yt++] = (It + ot) % 256;
            break;
          case 3:
            for (gt = jt = 0; jt < lt; gt = jt += 1) ot = P[z++], st = (gt - gt % v) / v, zt = gt < v ? 0 : ae[yt - v], It = at && ae[(at - 1) * lt + st * v + gt % v], ae[yt++] = (ot + Math.floor((zt + It) / 2)) % 256;
            break;
          case 4:
            for (gt = ee = 0; ee < lt; gt = ee += 1) ot = P[z++], st = (gt - gt % v) / v, zt = gt < v ? 0 : ae[yt - v], at === 0 ? It = St = 0 : (It = ae[(at - 1) * lt + st * v + gt % v], St = st && ae[(at - 1) * lt + (st - 1) * v + gt % v]), Kt = zt + It - St, pe = Math.abs(Kt - zt), kt = Math.abs(Kt - It), $t = Math.abs(Kt - St), Ot = pe <= kt && pe <= $t ? zt : kt <= $t ? It : St, ae[yt++] = (ot + Ot) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + P[z - 1]);
        }
        if (!K) {
          var pt = ((j + at * mt) * U.width + O) * v, xt = at * lt;
          for (gt = 0; gt < ie; gt += 1) {
            for (var Tt = 0; Tt < v; Tt += 1) c[pt++] = ae[xt++];
            pt += (F - 1) * v;
          }
        }
        at++;
      }
    }
    return P = $g(P), U.interlaceMethod == 1 ? (X(0, 0, 8, 8), X(4, 0, 8, 8), X(0, 4, 4, 8), X(2, 0, 4, 4), X(0, 2, 2, 4), X(1, 0, 2, 2), X(0, 1, 1, 2)) : X(0, 0, 1, 1), c;
  }, b.prototype.decodePalette = function() {
    var P, v, c, z, U, X, O, j, F;
    for (c = this.palette, X = this.transparency.indexed || [], U = new Uint8Array((X.length || 0) + c.length), z = 0, P = 0, v = O = 0, j = c.length; O < j; v = O += 3) U[z++] = c[v], U[z++] = c[v + 1], U[z++] = c[v + 2], U[z++] = (F = X[P++]) != null ? F : 255;
    return U;
  }, b.prototype.copyToImageData = function(P, v) {
    var c, z, U, X, O, j, F, mt, ot, yt, st;
    if (z = this.colors, ot = null, c = this.hasAlphaChannel, this.palette.length && (ot = (st = this._decodedPalette) != null ? st : this._decodedPalette = this.decodePalette(), z = 4, c = !0), mt = (U = P.data || P).length, O = ot || v, X = j = 0, z === 1) for (; X < mt; ) F = ot ? 4 * v[X / 4] : j, yt = O[F++], U[X++] = yt, U[X++] = yt, U[X++] = yt, U[X++] = c ? O[F++] : 255, j = F;
    else for (; X < mt; ) F = ot ? 4 * v[X / 4] : j, U[X++] = O[F++], U[X++] = O[F++], U[X++] = O[F++], U[X++] = c ? O[F++] : 255, j = F;
  }, b.prototype.decode = function() {
    var P;
    return P = new Uint8Array(this.width * this.height * 4), this.copyToImageData(P, this.decodePixels()), P;
  };
  var k = function() {
    if (Object.prototype.toString.call(vi) === "[object Window]") {
      try {
        f = vi.document.createElement("canvas"), y = f.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return k(), x = function(P) {
    var v;
    if (k() === !0) return y.width = P.width, y.height = P.height, y.clearRect(0, 0, P.width, P.height), y.putImageData(P, 0, 0), (v = new Image()).src = f.toDataURL(), v;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, b.prototype.decodeFrames = function(P) {
    var v, c, z, U, X, O, j, F;
    if (this.animation) {
      for (F = [], c = X = 0, O = (j = this.animation.frames).length; X < O; c = ++X) v = j[c], z = P.createImageData(v.width, v.height), U = this.decodePixels(new Uint8Array(v.data)), this.copyToImageData(z, U), v.imageData = z, F.push(v.image = x(z));
      return F;
    }
  }, b.prototype.renderFrame = function(P, v) {
    var c, z, U;
    return c = (z = this.animation.frames)[v], U = z[v - 1], v === 0 && P.clearRect(0, 0, this.width, this.height), (U != null ? U.disposeOp : void 0) === 1 ? P.clearRect(U.xOffset, U.yOffset, U.width, U.height) : (U != null ? U.disposeOp : void 0) === 2 && P.putImageData(U.imageData, U.xOffset, U.yOffset), c.blendOp === 0 && P.clearRect(c.xOffset, c.yOffset, c.width, c.height), P.drawImage(c.image, c.xOffset, c.yOffset);
  }, b.prototype.animate = function(P) {
    var v, c, z, U, X, O, j = this;
    return c = 0, O = this.animation, U = O.numFrames, z = O.frames, X = O.numPlays, (v = function() {
      var F, mt;
      if (F = c++ % U, mt = z[F], j.renderFrame(P, F), U > 1 && c / U < X) return j.animation._timeout = setTimeout(v, mt.delay);
    })();
  }, b.prototype.stopAnimation = function() {
    var P;
    return clearTimeout((P = this.animation) != null ? P._timeout : void 0);
  }, b.prototype.render = function(P) {
    var v, c;
    return P._png && P._png.stopAnimation(), P._png = this, P.width = this.width, P.height = this.height, v = P.getContext("2d"), this.animation ? (this.decodeFrames(v), this.animate(v)) : (c = v.createImageData(this.width, this.height), this.copyToImageData(c, this.decodePixels()), v.putImageData(c, 0, 0));
  }, b;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function f0(x) {
  var f = 0;
  if (x[f++] !== 71 || x[f++] !== 73 || x[f++] !== 70 || x[f++] !== 56 || (x[f++] + 1 & 253) != 56 || x[f++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var y = x[f++] | x[f++] << 8, b = x[f++] | x[f++] << 8, k = x[f++], P = k >> 7, v = 1 << (7 & k) + 1;
  x[f++], x[f++];
  var c = null, z = null;
  P && (c = f, z = v, f += 3 * v);
  var U = !0, X = [], O = 0, j = null, F = 0, mt = null;
  for (this.width = y, this.height = b; U && f < x.length; ) switch (x[f++]) {
    case 33:
      switch (x[f++]) {
        case 255:
          if (x[f] !== 11 || x[f + 1] == 78 && x[f + 2] == 69 && x[f + 3] == 84 && x[f + 4] == 83 && x[f + 5] == 67 && x[f + 6] == 65 && x[f + 7] == 80 && x[f + 8] == 69 && x[f + 9] == 50 && x[f + 10] == 46 && x[f + 11] == 48 && x[f + 12] == 3 && x[f + 13] == 1 && x[f + 16] == 0) f += 14, mt = x[f++] | x[f++] << 8, f++;
          else for (f += 12; ; ) {
            if (!((at = x[f++]) >= 0)) throw Error("Invalid block size");
            if (at === 0) break;
            f += at;
          }
          break;
        case 249:
          if (x[f++] !== 4 || x[f + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var ot = x[f++];
          O = x[f++] | x[f++] << 8, j = x[f++], !(1 & ot) && (j = null), F = ot >> 2 & 7, f++;
          break;
        case 254:
          for (; ; ) {
            if (!((at = x[f++]) >= 0)) throw Error("Invalid block size");
            if (at === 0) break;
            f += at;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + x[f - 1].toString(16));
      }
      break;
    case 44:
      var yt = x[f++] | x[f++] << 8, st = x[f++] | x[f++] << 8, gt = x[f++] | x[f++] << 8, zt = x[f++] | x[f++] << 8, Jt = x[f++], Kt = Jt >> 6 & 1, pe = 1 << (7 & Jt) + 1, Ot = c, kt = z, $t = !1;
      Jt >> 7 && ($t = !0, Ot = f, kt = pe, f += 3 * pe);
      var ae = f;
      for (f++; ; ) {
        var at;
        if (!((at = x[f++]) >= 0)) throw Error("Invalid block size");
        if (at === 0) break;
        f += at;
      }
      X.push({ x: yt, y: st, width: gt, height: zt, has_local_palette: $t, palette_offset: Ot, palette_size: kt, data_offset: ae, data_length: f - ae, transparent_index: j, interlaced: !!Kt, delay: O, disposal: F });
      break;
    case 59:
      U = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + x[f - 1].toString(16));
  }
  this.numFrames = function() {
    return X.length;
  }, this.loopCount = function() {
    return mt;
  }, this.frameInfo = function(lt) {
    if (lt < 0 || lt >= X.length) throw new Error("Frame index out of range.");
    return X[lt];
  }, this.decodeAndBlitFrameBGRA = function(lt, It) {
    var St = this.frameInfo(lt), Wt = St.width * St.height, Xt = new Uint8Array(Wt);
    Xp(x, St.data_offset, Xt, Wt);
    var Ht = St.palette_offset, jt = St.transparent_index;
    jt === null && (jt = 256);
    var ee = St.width, ie = y - ee, Se = ee, K = 4 * (St.y * y + St.x), pt = 4 * ((St.y + St.height) * y + St.x), xt = K, Tt = 4 * ie;
    St.interlaced === !0 && (Tt += 4 * y * 7);
    for (var Et = 8, Rt = 0, qt = Xt.length; Rt < qt; ++Rt) {
      var Gt = Xt[Rt];
      if (Se === 0 && (Se = ee, (xt += Tt) >= pt && (Tt = 4 * ie + 4 * y * (Et - 1), xt = K + (ee + ie) * (Et << 1), Et >>= 1)), Gt === jt) xt += 4;
      else {
        var we = x[Ht + 3 * Gt], be = x[Ht + 3 * Gt + 1], Ie = x[Ht + 3 * Gt + 2];
        It[xt++] = Ie, It[xt++] = be, It[xt++] = we, It[xt++] = 255;
      }
      --Se;
    }
  }, this.decodeAndBlitFrameRGBA = function(lt, It) {
    var St = this.frameInfo(lt), Wt = St.width * St.height, Xt = new Uint8Array(Wt);
    Xp(x, St.data_offset, Xt, Wt);
    var Ht = St.palette_offset, jt = St.transparent_index;
    jt === null && (jt = 256);
    var ee = St.width, ie = y - ee, Se = ee, K = 4 * (St.y * y + St.x), pt = 4 * ((St.y + St.height) * y + St.x), xt = K, Tt = 4 * ie;
    St.interlaced === !0 && (Tt += 4 * y * 7);
    for (var Et = 8, Rt = 0, qt = Xt.length; Rt < qt; ++Rt) {
      var Gt = Xt[Rt];
      if (Se === 0 && (Se = ee, (xt += Tt) >= pt && (Tt = 4 * ie + 4 * y * (Et - 1), xt = K + (ee + ie) * (Et << 1), Et >>= 1)), Gt === jt) xt += 4;
      else {
        var we = x[Ht + 3 * Gt], be = x[Ht + 3 * Gt + 1], Ie = x[Ht + 3 * Gt + 2];
        It[xt++] = we, It[xt++] = be, It[xt++] = Ie, It[xt++] = 255;
      }
      --Se;
    }
  };
}
function Xp(x, f, y, b) {
  for (var k = x[f++], P = 1 << k, v = P + 1, c = v + 1, z = k + 1, U = (1 << z) - 1, X = 0, O = 0, j = 0, F = x[f++], mt = new Int32Array(4096), ot = null; ; ) {
    for (; X < 16 && F !== 0; ) O |= x[f++] << X, X += 8, F === 1 ? F = x[f++] : --F;
    if (X < z) break;
    var yt = O & U;
    if (O >>= z, X -= z, yt !== P) {
      if (yt === v) break;
      for (var st = yt < c ? yt : ot, gt = 0, zt = st; zt > P; ) zt = mt[zt] >> 8, ++gt;
      var Jt = zt;
      if (j + gt + (st !== yt ? 1 : 0) > b) return void dr.log("Warning, gif stream longer than expected.");
      y[j++] = Jt;
      var Kt = j += gt;
      for (st !== yt && (y[j++] = Jt), zt = st; gt--; ) zt = mt[zt], y[--Kt] = 255 & zt, zt >>= 8;
      ot !== null && c < 4096 && (mt[c++] = ot << 8 | Jt, c >= U + 1 && z < 12 && (++z, U = U << 1 | 1)), ot = yt;
    } else c = v + 1, U = (1 << (z = k + 1)) - 1, ot = null;
  }
  return j !== b && dr.log("Warning, gif stream shorter than expected."), y;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function ju(x) {
  var f, y, b, k, P, v = Math.floor, c = new Array(64), z = new Array(64), U = new Array(64), X = new Array(64), O = new Array(65535), j = new Array(65535), F = new Array(64), mt = new Array(64), ot = [], yt = 0, st = 7, gt = new Array(64), zt = new Array(64), Jt = new Array(64), Kt = new Array(256), pe = new Array(2048), Ot = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], kt = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], $t = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ae = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], at = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], lt = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], It = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], St = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], Wt = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function Xt(K, pt) {
    for (var xt = 0, Tt = 0, Et = new Array(), Rt = 1; Rt <= 16; Rt++) {
      for (var qt = 1; qt <= K[Rt]; qt++) Et[pt[Tt]] = [], Et[pt[Tt]][0] = xt, Et[pt[Tt]][1] = Rt, Tt++, xt++;
      xt *= 2;
    }
    return Et;
  }
  function Ht(K) {
    for (var pt = K[0], xt = K[1] - 1; xt >= 0; ) pt & 1 << xt && (yt |= 1 << st), xt--, --st < 0 && (yt == 255 ? (jt(255), jt(0)) : jt(yt), st = 7, yt = 0);
  }
  function jt(K) {
    ot.push(K);
  }
  function ee(K) {
    jt(K >> 8 & 255), jt(255 & K);
  }
  function ie(K, pt, xt, Tt, Et) {
    for (var Rt, qt = Et[0], Gt = Et[240], we = function(se, _e) {
      var ze, ke, Ze, di, ai, wi, Ei, oe, ei, oi, Te = 0;
      for (ei = 0; ei < 8; ++ei) {
        ze = se[Te], ke = se[Te + 1], Ze = se[Te + 2], di = se[Te + 3], ai = se[Te + 4], wi = se[Te + 5], Ei = se[Te + 6];
        var cr = ze + (oe = se[Te + 7]), le = ze - oe, si = ke + Ei, Ce = ke - Ei, zi = Ze + wi, Sr = Ze - wi, Ee = di + ai, Xr = di - ai, Vi = cr + Ee, Mr = cr - Ee, Er = si + zi, ut = si - zi;
        se[Te] = Vi + Er, se[Te + 4] = Vi - Er;
        var V = 0.707106781 * (ut + Mr);
        se[Te + 2] = Mr + V, se[Te + 6] = Mr - V;
        var Z = 0.382683433 * ((Vi = Xr + Sr) - (ut = Ce + le)), et = 0.5411961 * Vi + Z, ct = 1.306562965 * ut + Z, Pt = 0.707106781 * (Er = Sr + Ce), Mt = le + Pt, At = le - Pt;
        se[Te + 5] = At + et, se[Te + 3] = At - et, se[Te + 1] = Mt + ct, se[Te + 7] = Mt - ct, Te += 8;
      }
      for (Te = 0, ei = 0; ei < 8; ++ei) {
        ze = se[Te], ke = se[Te + 8], Ze = se[Te + 16], di = se[Te + 24], ai = se[Te + 32], wi = se[Te + 40], Ei = se[Te + 48];
        var bt = ze + (oe = se[Te + 56]), Ut = ze - oe, te = ke + Ei, Bt = ke - Ei, me = Ze + wi, Ne = Ze - wi, $e = di + ai, xi = di - ai, Ke = bt + $e, yi = bt - $e, pi = te + me, Zi = te - me;
        se[Te] = Ke + pi, se[Te + 32] = Ke - pi;
        var Bi = 0.707106781 * (Zi + yi);
        se[Te + 16] = yi + Bi, se[Te + 48] = yi - Bi;
        var li = 0.382683433 * ((Ke = xi + Ne) - (Zi = Bt + Ut)), Di = 0.5411961 * Ke + li, Gi = 1.306562965 * Zi + li, hr = 0.707106781 * (pi = Ne + Bt), pr = Ut + hr, Ar = Ut - hr;
        se[Te + 40] = Ar + Di, se[Te + 24] = Ar - Di, se[Te + 8] = pr + Gi, se[Te + 56] = pr - Gi, Te++;
      }
      for (ei = 0; ei < 64; ++ei) oi = se[ei] * _e[ei], F[ei] = oi > 0 ? oi + 0.5 | 0 : oi - 0.5 | 0;
      return F;
    }(K, pt), be = 0; be < 64; ++be) mt[Ot[be]] = we[be];
    var Ie = mt[0] - xt;
    xt = mt[0], Ie == 0 ? Ht(Tt[0]) : (Ht(Tt[j[Rt = 32767 + Ie]]), Ht(O[Rt]));
    for (var Pe = 63; Pe > 0 && mt[Pe] == 0; ) Pe--;
    if (Pe == 0) return Ht(qt), xt;
    for (var ti, Qt = 1; Qt <= Pe; ) {
      for (var Y = Qt; mt[Qt] == 0 && Qt <= Pe; ) ++Qt;
      var ui = Qt - Y;
      if (ui >= 16) {
        ti = ui >> 4;
        for (var Ge = 1; Ge <= ti; ++Ge) Ht(Gt);
        ui &= 15;
      }
      Rt = 32767 + mt[Qt], Ht(Et[(ui << 4) + j[Rt]]), Ht(O[Rt]), Qt++;
    }
    return Pe != 63 && Ht(qt), xt;
  }
  function Se(K) {
    K = Math.min(Math.max(K, 1), 100), P != K && (function(pt) {
      for (var xt = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Tt = 0; Tt < 64; Tt++) {
        var Et = v((xt[Tt] * pt + 50) / 100);
        Et = Math.min(Math.max(Et, 1), 255), c[Ot[Tt]] = Et;
      }
      for (var Rt = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], qt = 0; qt < 64; qt++) {
        var Gt = v((Rt[qt] * pt + 50) / 100);
        Gt = Math.min(Math.max(Gt, 1), 255), z[Ot[qt]] = Gt;
      }
      for (var we = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], be = 0, Ie = 0; Ie < 8; Ie++) for (var Pe = 0; Pe < 8; Pe++) U[be] = 1 / (c[Ot[be]] * we[Ie] * we[Pe] * 8), X[be] = 1 / (z[Ot[be]] * we[Ie] * we[Pe] * 8), be++;
    }(K < 50 ? Math.floor(5e3 / K) : Math.floor(200 - 2 * K)), P = K);
  }
  this.encode = function(K, pt) {
    pt && Se(pt), ot = new Array(), yt = 0, st = 7, ee(65496), ee(65504), ee(16), jt(74), jt(70), jt(73), jt(70), jt(0), jt(1), jt(1), jt(0), ee(1), ee(1), jt(0), jt(0), function() {
      ee(65499), ee(132), jt(0);
      for (var ke = 0; ke < 64; ke++) jt(c[ke]);
      jt(1);
      for (var Ze = 0; Ze < 64; Ze++) jt(z[Ze]);
    }(), function(ke, Ze) {
      ee(65472), ee(17), jt(8), ee(Ze), ee(ke), jt(3), jt(1), jt(17), jt(0), jt(2), jt(17), jt(1), jt(3), jt(17), jt(1);
    }(K.width, K.height), function() {
      ee(65476), ee(418), jt(0);
      for (var ke = 0; ke < 16; ke++) jt(kt[ke + 1]);
      for (var Ze = 0; Ze <= 11; Ze++) jt($t[Ze]);
      jt(16);
      for (var di = 0; di < 16; di++) jt(ae[di + 1]);
      for (var ai = 0; ai <= 161; ai++) jt(at[ai]);
      jt(1);
      for (var wi = 0; wi < 16; wi++) jt(lt[wi + 1]);
      for (var Ei = 0; Ei <= 11; Ei++) jt(It[Ei]);
      jt(17);
      for (var oe = 0; oe < 16; oe++) jt(St[oe + 1]);
      for (var ei = 0; ei <= 161; ei++) jt(Wt[ei]);
    }(), ee(65498), ee(12), jt(3), jt(1), jt(0), jt(2), jt(17), jt(3), jt(17), jt(0), jt(63), jt(0);
    var xt = 0, Tt = 0, Et = 0;
    yt = 0, st = 7, this.encode.displayName = "_encode_";
    for (var Rt, qt, Gt, we, be, Ie, Pe, ti, Qt, Y = K.data, ui = K.width, Ge = K.height, se = 4 * ui, _e = 0; _e < Ge; ) {
      for (Rt = 0; Rt < se; ) {
        for (be = se * _e + Rt, Pe = -1, ti = 0, Qt = 0; Qt < 64; Qt++) Ie = be + (ti = Qt >> 3) * se + (Pe = 4 * (7 & Qt)), _e + ti >= Ge && (Ie -= se * (_e + 1 + ti - Ge)), Rt + Pe >= se && (Ie -= Rt + Pe - se + 4), qt = Y[Ie++], Gt = Y[Ie++], we = Y[Ie++], gt[Qt] = (pe[qt] + pe[Gt + 256 >> 0] + pe[we + 512 >> 0] >> 16) - 128, zt[Qt] = (pe[qt + 768 >> 0] + pe[Gt + 1024 >> 0] + pe[we + 1280 >> 0] >> 16) - 128, Jt[Qt] = (pe[qt + 1280 >> 0] + pe[Gt + 1536 >> 0] + pe[we + 1792 >> 0] >> 16) - 128;
        xt = ie(gt, U, xt, f, b), Tt = ie(zt, X, Tt, y, k), Et = ie(Jt, X, Et, y, k), Rt += 32;
      }
      _e += 8;
    }
    if (st >= 0) {
      var ze = [];
      ze[1] = st + 1, ze[0] = (1 << st + 1) - 1, Ht(ze);
    }
    return ee(65497), new Uint8Array(ot);
  }, x = x || 50, function() {
    for (var K = String.fromCharCode, pt = 0; pt < 256; pt++) Kt[pt] = K(pt);
  }(), f = Xt(kt, $t), y = Xt(lt, It), b = Xt(ae, at), k = Xt(St, Wt), function() {
    for (var K = 1, pt = 2, xt = 1; xt <= 15; xt++) {
      for (var Tt = K; Tt < pt; Tt++) j[32767 + Tt] = xt, O[32767 + Tt] = [], O[32767 + Tt][1] = xt, O[32767 + Tt][0] = Tt;
      for (var Et = -(pt - 1); Et <= -K; Et++) j[32767 + Et] = xt, O[32767 + Et] = [], O[32767 + Et][1] = xt, O[32767 + Et][0] = pt - 1 + Et;
      K <<= 1, pt <<= 1;
    }
  }(), function() {
    for (var K = 0; K < 256; K++) pe[K] = 19595 * K, pe[K + 256 >> 0] = 38470 * K, pe[K + 512 >> 0] = 7471 * K + 32768, pe[K + 768 >> 0] = -11059 * K, pe[K + 1024 >> 0] = -21709 * K, pe[K + 1280 >> 0] = 32768 * K + 8421375, pe[K + 1536 >> 0] = -27439 * K, pe[K + 1792 >> 0] = -5329 * K;
  }(), Se(x);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function ja(x, f) {
  if (this.pos = 0, this.buffer = x, this.datav = new DataView(x.buffer), this.is_with_alpha = !!f, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function Hp(x) {
  function f(kt) {
    if (!kt) throw Error("assert :P");
  }
  function y(kt, $t, ae) {
    for (var at = 0; 4 > at; at++) if (kt[$t + at] != ae.charCodeAt(at)) return !0;
    return !1;
  }
  function b(kt, $t, ae, at, lt) {
    for (var It = 0; It < lt; It++) kt[$t + It] = ae[at + It];
  }
  function k(kt, $t, ae, at) {
    for (var lt = 0; lt < at; lt++) kt[$t + lt] = ae;
  }
  function P(kt) {
    return new Int32Array(kt);
  }
  function v(kt, $t) {
    for (var ae = [], at = 0; at < kt; at++) ae.push(new $t());
    return ae;
  }
  function c(kt, $t) {
    var ae = [];
    return function at(lt, It, St) {
      for (var Wt = St[It], Xt = 0; Xt < Wt && (lt.push(St.length > It + 1 ? [] : new $t()), !(St.length < It + 1)); Xt++) at(lt[Xt], It + 1, St);
    }(ae, 0, kt), ae;
  }
  var z = function() {
    var kt = this;
    function $t(p, w) {
      for (var o = 1 << w - 1 >>> 0; p & o; ) o >>>= 1;
      return o ? (p & o - 1) + o : p;
    }
    function ae(p, w, o, t, r) {
      f(!(t % o));
      do
        p[w + (t -= o)] = r;
      while (0 < t);
    }
    function at(p, w, o, t, r) {
      if (f(2328 >= r), 512 >= r) var s = P(512);
      else if ((s = P(r)) == null) return 0;
      return function(l, h, g, _, A, L) {
        var E, M, R = h, q = 1 << g, B = P(16), $ = P(16);
        for (f(A != 0), f(_ != null), f(l != null), f(0 < g), M = 0; M < A; ++M) {
          if (15 < _[M]) return 0;
          ++B[_[M]];
        }
        if (B[0] == A) return 0;
        for ($[1] = 0, E = 1; 15 > E; ++E) {
          if (B[E] > 1 << E) return 0;
          $[E + 1] = $[E] + B[E];
        }
        for (M = 0; M < A; ++M) E = _[M], 0 < _[M] && (L[$[E]++] = M);
        if ($[15] == 1) return (_ = new lt()).g = 0, _.value = L[0], ae(l, R, 1, q, _), q;
        var Q, tt = -1, nt = q - 1, it = 0, ht = 1, wt = 1, _t = 1 << g;
        for (M = 0, E = 1, A = 2; E <= g; ++E, A <<= 1) {
          if (ht += wt <<= 1, 0 > (wt -= B[E])) return 0;
          for (; 0 < B[E]; --B[E]) (_ = new lt()).g = E, _.value = L[M++], ae(l, R + it, A, _t, _), it = $t(it, E);
        }
        for (E = g + 1, A = 2; 15 >= E; ++E, A <<= 1) {
          if (ht += wt <<= 1, 0 > (wt -= B[E])) return 0;
          for (; 0 < B[E]; --B[E]) {
            if (_ = new lt(), (it & nt) != tt) {
              for (R += _t, Q = 1 << (tt = E) - g; 15 > tt && !(0 >= (Q -= B[tt])); ) ++tt, Q <<= 1;
              q += _t = 1 << (Q = tt - g), l[h + (tt = it & nt)].g = Q + g, l[h + tt].value = R - h - tt;
            }
            _.g = E - g, _.value = L[M++], ae(l, R + (it >> g), A, _t, _), it = $t(it, E);
          }
        }
        return ht != 2 * $[15] - 1 ? 0 : q;
      }(p, w, o, t, r, s);
    }
    function lt() {
      this.value = this.g = 0;
    }
    function It() {
      this.value = this.g = 0;
    }
    function St() {
      this.G = v(5, lt), this.H = P(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = v(Lr, It);
    }
    function Wt(p, w, o, t) {
      f(p != null), f(w != null), f(2147483648 > t), p.Ca = 254, p.I = 0, p.b = -8, p.Ka = 0, p.oa = w, p.pa = o, p.Jd = w, p.Yc = o + t, p.Zc = 4 <= t ? o + t - 4 + 1 : o, Rt(p);
    }
    function Xt(p, w) {
      for (var o = 0; 0 < w--; ) o |= Gt(p, 128) << w;
      return o;
    }
    function Ht(p, w) {
      var o = Xt(p, w);
      return qt(p) ? -o : o;
    }
    function jt(p, w, o, t) {
      var r, s = 0;
      for (f(p != null), f(w != null), f(4294967288 > t), p.Sb = t, p.Ra = 0, p.u = 0, p.h = 0, 4 < t && (t = 4), r = 0; r < t; ++r) s += w[o + r] << 8 * r;
      p.Ra = s, p.bb = t, p.oa = w, p.pa = o;
    }
    function ee(p) {
      for (; 8 <= p.u && p.bb < p.Sb; ) p.Ra >>>= 8, p.Ra += p.oa[p.pa + p.bb] << Rn - 8 >>> 0, ++p.bb, p.u -= 8;
      xt(p) && (p.h = 1, p.u = 0);
    }
    function ie(p, w) {
      if (f(0 <= w), !p.h && w <= sa) {
        var o = pt(p) & na[w];
        return p.u += w, ee(p), o;
      }
      return p.h = 1, p.u = 0;
    }
    function Se() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function K() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function pt(p) {
      return p.Ra >>> (p.u & Rn - 1) >>> 0;
    }
    function xt(p) {
      return f(p.bb <= p.Sb), p.h || p.bb == p.Sb && p.u > Rn;
    }
    function Tt(p, w) {
      p.u = w, p.h = xt(p);
    }
    function Et(p) {
      p.u >= Rs && (f(p.u >= Rs), ee(p));
    }
    function Rt(p) {
      f(p != null && p.oa != null), p.pa < p.Zc ? (p.I = (p.oa[p.pa++] | p.I << 8) >>> 0, p.b += 8) : (f(p != null && p.oa != null), p.pa < p.Yc ? (p.b += 8, p.I = p.oa[p.pa++] | p.I << 8) : p.Ka ? p.b = 0 : (p.I <<= 8, p.b += 8, p.Ka = 1));
    }
    function qt(p) {
      return Xt(p, 1);
    }
    function Gt(p, w) {
      var o = p.Ca;
      0 > p.b && Rt(p);
      var t = p.b, r = o * w >>> 8, s = (p.I >>> t > r) + 0;
      for (s ? (o -= r, p.I -= r + 1 << t >>> 0) : o = r + 1, t = o, r = 0; 256 <= t; ) r += 8, t >>= 8;
      return t = 7 ^ r + zr[t], p.b -= t, p.Ca = (o << t) - 1, s;
    }
    function we(p, w, o) {
      p[w + 0] = o >> 24 & 255, p[w + 1] = o >> 16 & 255, p[w + 2] = o >> 8 & 255, p[w + 3] = o >> 0 & 255;
    }
    function be(p, w) {
      return p[w + 0] << 0 | p[w + 1] << 8;
    }
    function Ie(p, w) {
      return be(p, w) | p[w + 2] << 16;
    }
    function Pe(p, w) {
      return be(p, w) | be(p, w + 2) << 16;
    }
    function ti(p, w) {
      var o = 1 << w;
      return f(p != null), f(0 < w), p.X = P(o), p.X == null ? 0 : (p.Mb = 32 - w, p.Xa = w, 1);
    }
    function Qt(p, w) {
      f(p != null), f(w != null), f(p.Xa == w.Xa), b(w.X, 0, p.X, 0, 1 << w.Xa);
    }
    function Y() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function ui(p, w, o, t) {
      f(o != null), f(t != null);
      var r = o[0], s = t[0];
      return r == 0 && (r = (p * s + w / 2) / w), s == 0 && (s = (w * r + p / 2) / p), 0 >= r || 0 >= s ? 0 : (o[0] = r, t[0] = s, 1);
    }
    function Ge(p, w) {
      return p + (1 << w) - 1 >>> w;
    }
    function se(p, w) {
      return ((4278255360 & p) + (4278255360 & w) >>> 0 & 4278255360) + ((16711935 & p) + (16711935 & w) >>> 0 & 16711935) >>> 0;
    }
    function _e(p, w) {
      kt[w] = function(o, t, r, s, l, h, g) {
        var _;
        for (_ = 0; _ < l; ++_) {
          var A = kt[p](h[g + _ - 1], r, s + _);
          h[g + _] = se(o[t + _], A);
        }
      };
    }
    function ze() {
      this.ud = this.hd = this.jd = 0;
    }
    function ke(p, w) {
      return ((4278124286 & (p ^ w)) >>> 1) + (p & w) >>> 0;
    }
    function Ze(p) {
      return 0 <= p && 256 > p ? p : 0 > p ? 0 : 255 < p ? 255 : void 0;
    }
    function di(p, w) {
      return Ze(p + (p - w + 0.5 >> 1));
    }
    function ai(p, w, o) {
      return Math.abs(w - o) - Math.abs(p - o);
    }
    function wi(p, w, o, t, r, s, l) {
      for (t = s[l - 1], o = 0; o < r; ++o) s[l + o] = t = se(p[w + o], t);
    }
    function Ei(p, w, o, t, r) {
      var s;
      for (s = 0; s < o; ++s) {
        var l = p[w + s], h = l >> 8 & 255, g = 16711935 & (g = (g = 16711935 & l) + ((h << 16) + h));
        t[r + s] = (4278255360 & l) + g >>> 0;
      }
    }
    function oe(p, w) {
      w.jd = p >> 0 & 255, w.hd = p >> 8 & 255, w.ud = p >> 16 & 255;
    }
    function ei(p, w, o, t, r, s) {
      var l;
      for (l = 0; l < t; ++l) {
        var h = w[o + l], g = h >>> 8, _ = h, A = 255 & (A = (A = h >>> 16) + ((p.jd << 24 >> 24) * (g << 24 >> 24) >>> 5));
        _ = 255 & (_ = (_ = _ + ((p.hd << 24 >> 24) * (g << 24 >> 24) >>> 5)) + ((p.ud << 24 >> 24) * (A << 24 >> 24) >>> 5)), r[s + l] = (4278255360 & h) + (A << 16) + _;
      }
    }
    function oi(p, w, o, t, r) {
      kt[w] = function(s, l, h, g, _, A, L, E, M) {
        for (g = L; g < E; ++g) for (L = 0; L < M; ++L) _[A++] = r(h[t(s[l++])]);
      }, kt[p] = function(s, l, h, g, _, A, L) {
        var E = 8 >> s.b, M = s.Ea, R = s.K[0], q = s.w;
        if (8 > E) for (s = (1 << s.b) - 1, q = (1 << E) - 1; l < h; ++l) {
          var B, $ = 0;
          for (B = 0; B < M; ++B) B & s || ($ = t(g[_++])), A[L++] = r(R[$ & q]), $ >>= E;
        }
        else kt["VP8LMapColor" + o](g, _, R, q, A, L, l, h, M);
      };
    }
    function Te(p, w, o, t, r) {
      for (o = w + o; w < o; ) {
        var s = p[w++];
        t[r++] = s >> 16 & 255, t[r++] = s >> 8 & 255, t[r++] = s >> 0 & 255;
      }
    }
    function cr(p, w, o, t, r) {
      for (o = w + o; w < o; ) {
        var s = p[w++];
        t[r++] = s >> 16 & 255, t[r++] = s >> 8 & 255, t[r++] = s >> 0 & 255, t[r++] = s >> 24 & 255;
      }
    }
    function le(p, w, o, t, r) {
      for (o = w + o; w < o; ) {
        var s = (l = p[w++]) >> 16 & 240 | l >> 12 & 15, l = l >> 0 & 240 | l >> 28 & 15;
        t[r++] = s, t[r++] = l;
      }
    }
    function si(p, w, o, t, r) {
      for (o = w + o; w < o; ) {
        var s = (l = p[w++]) >> 16 & 248 | l >> 13 & 7, l = l >> 5 & 224 | l >> 3 & 31;
        t[r++] = s, t[r++] = l;
      }
    }
    function Ce(p, w, o, t, r) {
      for (o = w + o; w < o; ) {
        var s = p[w++];
        t[r++] = s >> 0 & 255, t[r++] = s >> 8 & 255, t[r++] = s >> 16 & 255;
      }
    }
    function zi(p, w, o, t, r, s) {
      if (s == 0) for (o = w + o; w < o; ) we(t, ((s = p[w++])[0] >> 24 | s[1] >> 8 & 65280 | s[2] << 8 & 16711680 | s[3] << 24) >>> 0), r += 32;
      else b(t, r, p, w, o);
    }
    function Sr(p, w) {
      kt[w][0] = kt[p + "0"], kt[w][1] = kt[p + "1"], kt[w][2] = kt[p + "2"], kt[w][3] = kt[p + "3"], kt[w][4] = kt[p + "4"], kt[w][5] = kt[p + "5"], kt[w][6] = kt[p + "6"], kt[w][7] = kt[p + "7"], kt[w][8] = kt[p + "8"], kt[w][9] = kt[p + "9"], kt[w][10] = kt[p + "10"], kt[w][11] = kt[p + "11"], kt[w][12] = kt[p + "12"], kt[w][13] = kt[p + "13"], kt[w][14] = kt[p + "0"], kt[w][15] = kt[p + "0"];
    }
    function Ee(p) {
      return p == po || p == Ea || p == fo || p == Wo;
    }
    function Xr() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Vi() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function Mr() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Xr(), this.f.kb = new Vi(), this.sd = null;
    }
    function Er() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ut() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function V(p) {
      return alert("todo:WebPSamplerProcessPlane"), p.T;
    }
    function Z(p, w) {
      var o = p.T, t = w.ba.f.RGBA, r = t.eb, s = t.fb + p.ka * t.A, l = fi[w.ba.S], h = p.y, g = p.O, _ = p.f, A = p.N, L = p.ea, E = p.W, M = w.cc, R = w.dc, q = w.Mc, B = w.Nc, $ = p.ka, Q = p.ka + p.T, tt = p.U, nt = tt + 1 >> 1;
      for ($ == 0 ? l(h, g, null, null, _, A, L, E, _, A, L, E, r, s, null, null, tt) : (l(w.ec, w.fc, h, g, M, R, q, B, _, A, L, E, r, s - t.A, r, s, tt), ++o); $ + 2 < Q; $ += 2) M = _, R = A, q = L, B = E, A += p.Rc, E += p.Rc, s += 2 * t.A, l(h, (g += 2 * p.fa) - p.fa, h, g, M, R, q, B, _, A, L, E, r, s - t.A, r, s, tt);
      return g += p.fa, p.j + Q < p.o ? (b(w.ec, w.fc, h, g, tt), b(w.cc, w.dc, _, A, nt), b(w.Mc, w.Nc, L, E, nt), o--) : 1 & Q || l(h, g, null, null, _, A, L, E, _, A, L, E, r, s + t.A, null, null, tt), o;
    }
    function et(p, w, o) {
      var t = p.F, r = [p.J];
      if (t != null) {
        var s = p.U, l = w.ba.S, h = l == uo || l == fo;
        w = w.ba.f.RGBA;
        var g = [0], _ = p.ka;
        g[0] = p.T, p.Kb && (_ == 0 ? --g[0] : (--_, r[0] -= p.width), p.j + p.ka + p.T == p.o && (g[0] = p.o - p.j - _));
        var A = w.eb;
        _ = w.fb + _ * w.A, p = Oi(t, r[0], p.width, s, g, A, _ + (h ? 0 : 3), w.A), f(o == g), p && Ee(l) && tn(A, _, h, s, g, w.A);
      }
      return 0;
    }
    function ct(p) {
      var w = p.ma, o = w.ba.S, t = 11 > o, r = o == Ca || o == Ma || o == uo || o == Zo || o == 12 || Ee(o);
      if (w.memory = null, w.Ib = null, w.Jb = null, w.Nd = null, !rs(w.Oa, p, r ? 11 : 12)) return 0;
      if (r && Ee(o) && ye(), p.da) alert("todo:use_scaling");
      else {
        if (t) {
          if (w.Ib = V, p.Kb) {
            if (o = p.U + 1 >> 1, w.memory = P(p.U + 2 * o), w.memory == null) return 0;
            w.ec = w.memory, w.fc = 0, w.cc = w.ec, w.dc = w.fc + p.U, w.Mc = w.cc, w.Nc = w.dc + o, w.Ib = Z, ye();
          }
        } else alert("todo:EmitYUV");
        r && (w.Jb = et, t && Ft());
      }
      if (t && !Xi) {
        for (p = 0; 256 > p; ++p) _o[p] = 89858 * (p - 128) + gl >> Yo, lc[p] = -22014 * (p - 128) + gl, _l[p] = -45773 * (p - 128), yl[p] = 113618 * (p - 128) + gl >> Yo;
        for (p = Da; p < Vl; ++p) w = 76283 * (p - 16) + gl >> Yo, Ko[p - Da] = Ci(w, 255), Jo[p - Da] = Ci(w + 8 >> 4, 15);
        Xi = 1;
      }
      return 1;
    }
    function Pt(p) {
      var w = p.ma, o = p.U, t = p.T;
      return f(!(1 & p.ka)), 0 >= o || 0 >= t ? 0 : (o = w.Ib(p, w), w.Jb != null && w.Jb(p, w, o), w.Dc += o, 1);
    }
    function Mt(p) {
      p.ma.memory = null;
    }
    function At(p, w, o, t) {
      return ie(p, 8) != 47 ? 0 : (w[0] = ie(p, 14) + 1, o[0] = ie(p, 14) + 1, t[0] = ie(p, 1), ie(p, 3) != 0 ? 0 : !p.h);
    }
    function bt(p, w) {
      if (4 > p) return p + 1;
      var o = p - 2 >> 1;
      return (2 + (1 & p) << o) + ie(w, o) + 1;
    }
    function Ut(p, w) {
      return 120 < w ? w - 120 : 1 <= (o = ((o = jn[w - 1]) >> 4) * p + (8 - (15 & o))) ? o : 1;
      var o;
    }
    function te(p, w, o) {
      var t = pt(o), r = p[w += 255 & t].g - 8;
      return 0 < r && (Tt(o, o.u + 8), t = pt(o), w += p[w].value, w += t & (1 << r) - 1), Tt(o, o.u + p[w].g), p[w].value;
    }
    function Bt(p, w, o) {
      return o.g += p.g, o.value += p.value << w >>> 0, f(8 >= o.g), p.g;
    }
    function me(p, w, o) {
      var t = p.xc;
      return f((w = t == 0 ? 0 : p.vc[p.md * (o >> t) + (w >> t)]) < p.Wb), p.Ya[w];
    }
    function Ne(p, w, o, t) {
      var r = p.ab, s = p.c * w, l = p.C;
      w = l + w;
      var h = o, g = t;
      for (t = p.Ta, o = p.Ua; 0 < r--; ) {
        var _ = p.gc[r], A = l, L = w, E = h, M = g, R = (g = t, h = o, _.Ea);
        switch (f(A < L), f(L <= _.nc), _.hc) {
          case 2:
            Ia(E, M, (L - A) * R, g, h);
            break;
          case 0:
            var q = A, B = L, $ = g, Q = h, tt = (_t = _).Ea;
            q == 0 && (aa(E, M, null, null, 1, $, Q), wi(E, M + 1, 0, 0, tt - 1, $, Q + 1), M += tt, Q += tt, ++q);
            for (var nt = 1 << _t.b, it = nt - 1, ht = Ge(tt, _t.b), wt = _t.K, _t = _t.w + (q >> _t.b) * ht; q < B; ) {
              var Vt = wt, re = _t, ce = 1;
              for (Os(E, M, $, Q - tt, 1, $, Q); ce < tt; ) {
                var de = (ce & ~it) + nt;
                de > tt && (de = tt), (0, Pi[Vt[re++] >> 8 & 15])(E, M + +ce, $, Q + ce - tt, de - ce, $, Q + ce), ce = de;
              }
              M += tt, Q += tt, ++q & it || (_t += ht);
            }
            L != _.nc && b(g, h - R, g, h + (L - A - 1) * R, R);
            break;
          case 1:
            for (R = E, B = M, tt = (E = _.Ea) - (Q = E & ~($ = (M = 1 << _.b) - 1)), q = Ge(E, _.b), nt = _.K, _ = _.w + (A >> _.b) * q; A < L; ) {
              for (it = nt, ht = _, wt = new ze(), _t = B + Q, Vt = B + E; B < _t; ) oe(it[ht++], wt), xs(wt, R, B, M, g, h), B += M, h += M;
              B < Vt && (oe(it[ht++], wt), xs(wt, R, B, tt, g, h), B += tt, h += tt), ++A & $ || (_ += q);
            }
            break;
          case 3:
            if (E == g && M == h && 0 < _.b) {
              for (B = g, E = R = h + (L - A) * R - (Q = (L - A) * Ge(_.Ea, _.b)), M = g, $ = h, q = [], Q = (tt = Q) - 1; 0 <= Q; --Q) q[Q] = M[$ + Q];
              for (Q = tt - 1; 0 <= Q; --Q) B[E + Q] = q[Q];
              qr(_, A, L, g, R, g, h);
            } else qr(_, A, L, E, M, g, h);
        }
        h = t, g = o;
      }
      g != o && b(t, o, h, g, s);
    }
    function $e(p, w) {
      var o = p.V, t = p.Ba + p.c * p.C, r = w - p.C;
      if (f(w <= p.l.o), f(16 >= r), 0 < r) {
        var s = p.l, l = p.Ta, h = p.Ua, g = s.width;
        if (Ne(p, r, o, t), r = h = [h], f((o = p.C) < (t = w)), f(s.v < s.va), t > s.o && (t = s.o), o < s.j) {
          var _ = s.j - o;
          o = s.j, r[0] += _ * g;
        }
        if (o >= t ? o = 0 : (r[0] += 4 * s.v, s.ka = o - s.j, s.U = s.va - s.v, s.T = t - o, o = 1), o) {
          if (h = h[0], 11 > (o = p.ca).S) {
            var A = o.f.RGBA, L = (t = o.S, r = s.U, s = s.T, _ = A.eb, A.A), E = s;
            for (A = A.fb + p.Ma * A.A; 0 < E--; ) {
              var M = l, R = h, q = r, B = _, $ = A;
              switch (t) {
                case ho:
                  _n(M, R, q, B, $);
                  break;
                case Ca:
                  Jr(M, R, q, B, $);
                  break;
                case po:
                  Jr(M, R, q, B, $), tn(B, $, 0, q, 1, 0);
                  break;
                case fl:
                  On(M, R, q, B, $);
                  break;
                case Ma:
                  zi(M, R, q, B, $, 1);
                  break;
                case Ea:
                  zi(M, R, q, B, $, 1), tn(B, $, 0, q, 1, 0);
                  break;
                case uo:
                  zi(M, R, q, B, $, 0);
                  break;
                case fo:
                  zi(M, R, q, B, $, 0), tn(B, $, 1, q, 1, 0);
                  break;
                case Zo:
                  In(M, R, q, B, $);
                  break;
                case Wo:
                  In(M, R, q, B, $), Ii(B, $, q, 1, 0);
                  break;
                case ha:
                  bs(M, R, q, B, $);
                  break;
                default:
                  f(0);
              }
              h += g, A += L;
            }
            p.Ma += s;
          } else alert("todo:EmitRescaledRowsYUVA");
          f(p.Ma <= o.height);
        }
      }
      p.C = w, f(p.C <= p.i);
    }
    function xi(p) {
      var w;
      if (0 < p.ua) return 0;
      for (w = 0; w < p.Wb; ++w) {
        var o = p.Ya[w].G, t = p.Ya[w].H;
        if (0 < o[1][t[1] + 0].g || 0 < o[2][t[2] + 0].g || 0 < o[3][t[3] + 0].g) return 0;
      }
      return 1;
    }
    function Ke(p, w, o, t, r, s) {
      if (p.Z != 0) {
        var l = p.qd, h = p.rd;
        for (f(ks[p.Z] != null); w < o; ++w) ks[p.Z](l, h, t, r, t, r, s), l = t, h = r, r += s;
        p.qd = l, p.rd = h;
      }
    }
    function yi(p, w) {
      var o = p.l.ma, t = o.Z == 0 || o.Z == 1 ? p.l.j : p.C;
      if (t = p.C < t ? t : p.C, f(w <= p.l.o), w > t) {
        var r = p.l.width, s = o.ca, l = o.tb + r * t, h = p.V, g = p.Ba + p.c * t, _ = p.gc;
        f(p.ab == 1), f(_[0].hc == 3), Go(_[0], t, w, h, g, s, l), Ke(o, t, w, s, l, r);
      }
      p.C = p.Ma = w;
    }
    function pi(p, w, o, t, r, s, l) {
      var h = p.$ / t, g = p.$ % t, _ = p.m, A = p.s, L = o + p.$, E = L;
      r = o + t * r;
      var M = o + t * s, R = 280 + A.ua, q = p.Pb ? h : 16777216, B = 0 < A.ua ? A.Wa : null, $ = A.wc, Q = L < M ? me(A, g, h) : null;
      f(p.C < s), f(M <= r);
      var tt = !1;
      t: for (; ; ) {
        for (; tt || L < M; ) {
          var nt = 0;
          if (h >= q) {
            var it = L - o;
            f((q = p).Pb), q.wd = q.m, q.xd = it, 0 < q.s.ua && Qt(q.s.Wa, q.s.vb), q = h + Bl;
          }
          if (g & $ || (Q = me(A, g, h)), f(Q != null), Q.Qb && (w[L] = Q.qb, tt = !0), !tt) if (Et(_), Q.jc) {
            nt = _, it = w;
            var ht = L, wt = Q.pd[pt(nt) & Lr - 1];
            f(Q.jc), 256 > wt.g ? (Tt(nt, nt.u + wt.g), it[ht] = wt.value, nt = 0) : (Tt(nt, nt.u + wt.g - 256), f(256 <= wt.value), nt = wt.value), nt == 0 && (tt = !0);
          } else nt = te(Q.G[0], Q.H[0], _);
          if (_.h) break;
          if (tt || 256 > nt) {
            if (!tt) if (Q.nd) w[L] = (Q.qb | nt << 8) >>> 0;
            else {
              if (Et(_), tt = te(Q.G[1], Q.H[1], _), Et(_), it = te(Q.G[2], Q.H[2], _), ht = te(Q.G[3], Q.H[3], _), _.h) break;
              w[L] = (ht << 24 | tt << 16 | nt << 8 | it) >>> 0;
            }
            if (tt = !1, ++L, ++g >= t && (g = 0, ++h, l != null && h <= s && !(h % 16) && l(p, h), B != null)) for (; E < L; ) nt = w[E++], B.X[(506832829 * nt & 4294967295) >>> B.Mb] = nt;
          } else if (280 > nt) {
            if (nt = bt(nt - 256, _), it = te(Q.G[4], Q.H[4], _), Et(_), it = Ut(t, it = bt(it, _)), _.h) break;
            if (L - o < it || r - L < nt) break t;
            for (ht = 0; ht < nt; ++ht) w[L + ht] = w[L + ht - it];
            for (L += nt, g += nt; g >= t; ) g -= t, ++h, l != null && h <= s && !(h % 16) && l(p, h);
            if (f(L <= r), g & $ && (Q = me(A, g, h)), B != null) for (; E < L; ) nt = w[E++], B.X[(506832829 * nt & 4294967295) >>> B.Mb] = nt;
          } else {
            if (!(nt < R)) break t;
            for (tt = nt - 280, f(B != null); E < L; ) nt = w[E++], B.X[(506832829 * nt & 4294967295) >>> B.Mb] = nt;
            nt = L, f(!(tt >>> (it = B).Xa)), w[nt] = it.X[tt], tt = !0;
          }
          tt || f(_.h == xt(_));
        }
        if (p.Pb && _.h && L < r) f(p.m.h), p.a = 5, p.m = p.wd, p.$ = p.xd, 0 < p.s.ua && Qt(p.s.vb, p.s.Wa);
        else {
          if (_.h) break t;
          l != null && l(p, h > s ? s : h), p.a = 0, p.$ = L - o;
        }
        return 1;
      }
      return p.a = 3, 0;
    }
    function Zi(p) {
      f(p != null), p.vc = null, p.yc = null, p.Ya = null;
      var w = p.Wa;
      w != null && (w.X = null), p.vb = null, f(p != null);
    }
    function Bi() {
      var p = new Pa();
      return p == null ? null : (p.a = 0, p.xb = za, Sr("Predictor", "VP8LPredictors"), Sr("Predictor", "VP8LPredictors_C"), Sr("PredictorAdd", "VP8LPredictorsAdd"), Sr("PredictorAdd", "VP8LPredictorsAdd_C"), Ia = Ei, xs = ei, _n = Te, Jr = cr, In = le, bs = si, On = Ce, kt.VP8LMapColor32b = ns, kt.VP8LMapColor8b = oo, p);
    }
    function li(p, w, o, t, r) {
      var s = 1, l = [p], h = [w], g = t.m, _ = t.s, A = null, L = 0;
      t: for (; ; ) {
        if (o) for (; s && ie(g, 1); ) {
          var E = l, M = h, R = t, q = 1, B = R.m, $ = R.gc[R.ab], Q = ie(B, 2);
          if (R.Oc & 1 << Q) s = 0;
          else {
            switch (R.Oc |= 1 << Q, $.hc = Q, $.Ea = E[0], $.nc = M[0], $.K = [null], ++R.ab, f(4 >= R.ab), Q) {
              case 0:
              case 1:
                $.b = ie(B, 3) + 2, q = li(Ge($.Ea, $.b), Ge($.nc, $.b), 0, R, $.K), $.K = $.K[0];
                break;
              case 3:
                var tt, nt = ie(B, 8) + 1, it = 16 < nt ? 0 : 4 < nt ? 1 : 2 < nt ? 2 : 3;
                if (E[0] = Ge($.Ea, it), $.b = it, tt = q = li(nt, 1, 0, R, $.K)) {
                  var ht, wt = nt, _t = $, Vt = 1 << (8 >> _t.b), re = P(Vt);
                  if (re == null) tt = 0;
                  else {
                    var ce = _t.K[0], de = _t.w;
                    for (re[0] = _t.K[0][0], ht = 1; ht < 1 * wt; ++ht) re[ht] = se(ce[de + ht], re[ht - 1]);
                    for (; ht < 4 * Vt; ++ht) re[ht] = 0;
                    _t.K[0] = null, _t.K[0] = re, tt = 1;
                  }
                }
                q = tt;
                break;
              case 2:
                break;
              default:
                f(0);
            }
            s = q;
          }
        }
        if (l = l[0], h = h[0], s && ie(g, 1) && !(s = 1 <= (L = ie(g, 4)) && 11 >= L)) {
          t.a = 3;
          break t;
        }
        var ue;
        if (ue = s) e: {
          var he, fe, Oe, ve = t, xe = l, Ue = h, ni = L, ii = o, ci = ve.m, bi = ve.s, ji = [null], tr = 1, Ni = 0, ur = Ps[ni];
          i: for (; ; ) {
            if (ii && ie(ci, 1)) {
              var qi = ie(ci, 3) + 2, or = Ge(xe, qi), xr = Ge(Ue, qi), dn = or * xr;
              if (!li(or, xr, 0, ve, ji)) break i;
              for (ji = ji[0], bi.xc = qi, he = 0; he < dn; ++he) {
                var Cn = ji[he] >> 8 & 65535;
                ji[he] = Cn, Cn >= tr && (tr = Cn + 1);
              }
            }
            if (ci.h) break i;
            for (fe = 0; 5 > fe; ++fe) {
              var er = Xo[fe];
              !fe && 0 < ni && (er += 1 << ni), Ni < er && (Ni = er);
            }
            var da = v(tr * ur, lt), Mn = tr, tl = v(Mn, St);
            if (tl == null) var vo = null;
            else f(65536 >= Mn), vo = tl;
            var en = P(Ni);
            if (vo == null || en == null || da == null) {
              ve.a = 1;
              break i;
            }
            var pn = da;
            for (he = Oe = 0; he < tr; ++he) {
              var Fr = vo[he], rn = Fr.G, yr = Fr.H, Vr = 0, nn = 1, Li = 0;
              for (fe = 0; 5 > fe; ++fe) {
                er = Xo[fe], rn[fe] = pn, yr[fe] = Oe, !fe && 0 < ni && (er += 1 << ni);
                n: {
                  var Ts, pa = er, Us = ve, xo = en, Bc = pn, cc = Oe, Ls = 0, Vs = Us.m, vl = ie(Vs, 1);
                  if (k(xo, 0, 0, pa), vl) {
                    var el = ie(Vs, 1) + 1, xl = ie(Vs, 1), il = ie(Vs, xl == 0 ? 1 : 8);
                    xo[il] = 1, el == 2 && (xo[il = ie(Vs, 8)] = 1);
                    var Gs = 1;
                  } else {
                    var bo = P(19), Gl = ie(Vs, 4) + 4;
                    if (19 < Gl) {
                      Us.a = 3;
                      var $l = 0;
                      break n;
                    }
                    for (Ts = 0; Ts < Gl; ++Ts) bo[nc[Ts]] = ie(Vs, 3);
                    var hc = void 0, Zl = void 0, uc = Us, Wl = bo, Fa = pa, fa = xo, us = 0, En = uc.m, Rc = 8, wo = v(128, lt);
                    r: for (; at(wo, 0, 7, Wl, 19); ) {
                      if (ie(En, 1)) {
                        var Xh = 2 + 2 * ie(En, 3);
                        if ((hc = 2 + ie(En, Xh)) > Fa) break r;
                      } else hc = Fa;
                      for (Zl = 0; Zl < Fa && hc--; ) {
                        Et(En);
                        var Oc = wo[0 + (127 & pt(En))];
                        Tt(En, En.u + Oc.g);
                        var ir = Oc.value;
                        if (16 > ir) fa[Zl++] = ir, ir != 0 && (Rc = ir);
                        else {
                          var jc = ir == 16, qc = ir - 16, rl = Fl[qc], So = ie(En, Dl[qc]) + rl;
                          if (Zl + So > Fa) break r;
                          for (var dc = jc ? Rc : 0; 0 < So--; ) fa[Zl++] = dc;
                        }
                      }
                      us = 1;
                      break r;
                    }
                    us || (uc.a = 3), Gs = us;
                  }
                  (Gs = Gs && !Vs.h) && (Ls = at(Bc, cc, 8, xo, pa)), Gs && Ls != 0 ? $l = Ls : (Us.a = 3, $l = 0);
                }
                if ($l == 0) break i;
                if (nn && mo[fe] == 1 && (nn = pn[Oe].g == 0), Vr += pn[Oe].g, Oe += $l, 3 >= fe) {
                  var nl, pc = en[0];
                  for (nl = 1; nl < er; ++nl) en[nl] > pc && (pc = en[nl]);
                  Li += pc;
                }
              }
              if (Fr.nd = nn, Fr.Qb = 0, nn && (Fr.qb = (rn[3][yr[3] + 0].value << 24 | rn[1][yr[1] + 0].value << 16 | rn[2][yr[2] + 0].value) >>> 0, Vr == 0 && 256 > rn[0][yr[0] + 0].value && (Fr.Qb = 1, Fr.qb += rn[0][yr[0] + 0].value << 8)), Fr.jc = !Fr.Qb && 6 > Li, Fr.jc) {
                var fc, ma = Fr;
                for (fc = 0; fc < Lr; ++fc) {
                  var Ao = fc, ga = ma.pd[Ao], mc = ma.G[0][ma.H[0] + Ao];
                  256 <= mc.value ? (ga.g = mc.g + 256, ga.value = mc.value) : (ga.g = 0, ga.value = 0, Ao >>= Bt(mc, 8, ga), Ao >>= Bt(ma.G[1][ma.H[1] + Ao], 16, ga), Ao >>= Bt(ma.G[2][ma.H[2] + Ao], 0, ga), Bt(ma.G[3][ma.H[3] + Ao], 24, ga));
                }
              }
            }
            bi.vc = ji, bi.Wb = tr, bi.Ya = vo, bi.yc = da, ue = 1;
            break e;
          }
          ue = 0;
        }
        if (!(s = ue)) {
          t.a = 3;
          break t;
        }
        if (0 < L) {
          if (_.ua = 1 << L, !ti(_.Wa, L)) {
            t.a = 1, s = 0;
            break t;
          }
        } else _.ua = 0;
        var Xl = t, Uc = l, fh = h, Po = Xl.s, Vc = Po.xc;
        if (Xl.c = Uc, Xl.i = fh, Po.md = Ge(Uc, Vc), Po.wc = Vc == 0 ? -1 : (1 << Vc) - 1, o) {
          t.xb = yo;
          break t;
        }
        if ((A = P(l * h)) == null) {
          t.a = 1, s = 0;
          break t;
        }
        s = (s = pi(t, A, 0, l, h, h, null)) && !g.h;
        break t;
      }
      return s ? (r != null ? r[0] = A : (f(A == null), f(o)), t.$ = 0, o || Zi(_)) : Zi(_), s;
    }
    function Di(p, w) {
      var o = p.c * p.i, t = o + w + 16 * w;
      return f(p.c <= w), p.V = P(t), p.V == null ? (p.Ta = null, p.Ua = 0, p.a = 1, 0) : (p.Ta = p.V, p.Ua = p.Ba + o + w, 1);
    }
    function Gi(p, w) {
      var o = p.C, t = w - o, r = p.V, s = p.Ba + p.c * o;
      for (f(w <= p.l.o); 0 < t; ) {
        var l = 16 < t ? 16 : t, h = p.l.ma, g = p.l.width, _ = g * l, A = h.ca, L = h.tb + g * o, E = p.Ta, M = p.Ua;
        Ne(p, l, r, s), gr(E, M, A, L, _), Ke(h, o, o + l, A, L, g), t -= l, r += l * p.c, o += l;
      }
      f(o == w), p.C = p.Ma = w;
    }
    function hr() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function pr() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Ar() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = P(4), this.Lb = P(4);
    }
    function Es() {
      this.Yb = function() {
        var p = [];
        return function w(o, t, r) {
          for (var s = r[t], l = 0; l < s && (o.push(r.length > t + 1 ? [] : 0), !(r.length < t + 1)); l++) w(o[l], t + 1, r);
        }(p, 0, [3, 11]), p;
      }();
    }
    function Ri() {
      this.jb = P(3), this.Wc = c([4, 8], Es), this.Xc = c([4, 17], Es);
    }
    function No() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new P(4), this.od = new P(4);
    }
    function Ks() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Hr() {
      this.Na = this.la = 0;
    }
    function ln() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Do() {
      this.ad = P(384), this.Za = 0, this.Ob = P(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function mn() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Ks()), this.Y = 0, this.ya = Array(new Do()), this.aa = 0, this.l = new Dn();
    }
    function Yr() {
      this.y = P(16), this.f = P(8), this.ea = P(8);
    }
    function Js() {
      this.cb = this.a = 0, this.sc = "", this.m = new Se(), this.Od = new hr(), this.Kc = new pr(), this.ed = new No(), this.Qa = new Ar(), this.Ic = this.$c = this.Aa = 0, this.D = new mn(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = v(8, Se), this.ia = 0, this.pb = v(4, ln), this.Pa = new Ri(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Yr()), this.Hd = 0, this.rb = Array(new Hr()), this.sb = 0, this.wa = Array(new Ks()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Do()), this.L = this.aa = 0, this.gd = c([4, 2], Ks), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Dn() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function fr() {
      var p = new Js();
      return p != null && (p.a = 0, p.sc = "OK", p.cb = 0, p.Xb = 0, Ho || (Ho = va)), p;
    }
    function Ji(p, w, o) {
      return p.a == 0 && (p.a = w, p.sc = o, p.cb = 0), 0;
    }
    function gn(p, w, o) {
      return 3 <= o && p[w + 0] == 157 && p[w + 1] == 1 && p[w + 2] == 42;
    }
    function sr(p, w) {
      if (p == null) return 0;
      if (p.a = 0, p.sc = "OK", w == null) return Ji(p, 2, "null VP8Io passed to VP8GetHeaders()");
      var o = w.data, t = w.w, r = w.ha;
      if (4 > r) return Ji(p, 7, "Truncated header.");
      var s = o[t + 0] | o[t + 1] << 8 | o[t + 2] << 16, l = p.Od;
      if (l.Rb = !(1 & s), l.td = s >> 1 & 7, l.yd = s >> 4 & 1, l.ub = s >> 5, 3 < l.td) return Ji(p, 3, "Incorrect keyframe parameters.");
      if (!l.yd) return Ji(p, 4, "Frame not displayable.");
      t += 3, r -= 3;
      var h = p.Kc;
      if (l.Rb) {
        if (7 > r) return Ji(p, 7, "cannot parse picture header");
        if (!gn(o, t, r)) return Ji(p, 3, "Bad code word");
        h.c = 16383 & (o[t + 4] << 8 | o[t + 3]), h.Td = o[t + 4] >> 6, h.i = 16383 & (o[t + 6] << 8 | o[t + 5]), h.Ud = o[t + 6] >> 6, t += 7, r -= 7, p.za = h.c + 15 >> 4, p.Ub = h.i + 15 >> 4, w.width = h.c, w.height = h.i, w.Da = 0, w.j = 0, w.v = 0, w.va = w.width, w.o = w.height, w.da = 0, w.ib = w.width, w.hb = w.height, w.U = w.width, w.T = w.height, k((s = p.Pa).jb, 0, 255, s.jb.length), f((s = p.Qa) != null), s.Cb = 0, s.Bb = 0, s.Fb = 1, k(s.Zb, 0, 0, s.Zb.length), k(s.Lb, 0, 0, s.Lb);
      }
      if (l.ub > r) return Ji(p, 7, "bad partition length");
      Wt(s = p.m, o, t, l.ub), t += l.ub, r -= l.ub, l.Rb && (h.Ld = qt(s), h.Kd = qt(s)), h = p.Qa;
      var g, _ = p.Pa;
      if (f(s != null), f(h != null), h.Cb = qt(s), h.Cb) {
        if (h.Bb = qt(s), qt(s)) {
          for (h.Fb = qt(s), g = 0; 4 > g; ++g) h.Zb[g] = qt(s) ? Ht(s, 7) : 0;
          for (g = 0; 4 > g; ++g) h.Lb[g] = qt(s) ? Ht(s, 6) : 0;
        }
        if (h.Bb) for (g = 0; 3 > g; ++g) _.jb[g] = qt(s) ? Xt(s, 8) : 255;
      } else h.Bb = 0;
      if (s.Ka) return Ji(p, 3, "cannot parse segment header");
      if ((h = p.ed).zd = qt(s), h.Tb = Xt(s, 6), h.wb = Xt(s, 3), h.Pc = qt(s), h.Pc && qt(s)) {
        for (_ = 0; 4 > _; ++_) qt(s) && (h.vd[_] = Ht(s, 6));
        for (_ = 0; 4 > _; ++_) qt(s) && (h.od[_] = Ht(s, 6));
      }
      if (p.L = h.Tb == 0 ? 0 : h.zd ? 1 : 2, s.Ka) return Ji(p, 3, "cannot parse filter header");
      var A = r;
      if (r = g = t, t = g + A, h = A, p.Xb = (1 << Xt(p.m, 2)) - 1, A < 3 * (_ = p.Xb)) o = 7;
      else {
        for (g += 3 * _, h -= 3 * _, A = 0; A < _; ++A) {
          var L = o[r + 0] | o[r + 1] << 8 | o[r + 2] << 16;
          L > h && (L = h), Wt(p.Jc[+A], o, g, L), g += L, h -= L, r += 3;
        }
        Wt(p.Jc[+_], o, g, h), o = g < t ? 0 : 5;
      }
      if (o != 0) return Ji(p, o, "cannot parse partitions");
      for (o = Xt(g = p.m, 7), r = qt(g) ? Ht(g, 4) : 0, t = qt(g) ? Ht(g, 4) : 0, h = qt(g) ? Ht(g, 4) : 0, _ = qt(g) ? Ht(g, 4) : 0, g = qt(g) ? Ht(g, 4) : 0, A = p.Qa, L = 0; 4 > L; ++L) {
        if (A.Cb) {
          var E = A.Zb[L];
          A.Fb || (E += o);
        } else {
          if (0 < L) {
            p.pb[L] = p.pb[0];
            continue;
          }
          E = o;
        }
        var M = p.pb[L];
        M.Sc[0] = kn[Ci(E + r, 127)], M.Sc[1] = qs[Ci(E + 0, 127)], M.Eb[0] = 2 * kn[Ci(E + t, 127)], M.Eb[1] = 101581 * qs[Ci(E + h, 127)] >> 16, 8 > M.Eb[1] && (M.Eb[1] = 8), M.Qc[0] = kn[Ci(E + _, 117)], M.Qc[1] = qs[Ci(E + g, 127)], M.lc = E + g;
      }
      if (!l.Rb) return Ji(p, 4, "Not a key frame.");
      for (qt(s), l = p.Pa, o = 0; 4 > o; ++o) {
        for (r = 0; 8 > r; ++r) for (t = 0; 3 > t; ++t) for (h = 0; 11 > h; ++h) _ = Gt(s, qn[o][r][t][h]) ? Xt(s, 8) : Ol[o][r][t][h], l.Wc[o][r].Yb[t][h] = _;
        for (r = 0; 17 > r; ++r) l.Xc[o][r] = l.Wc[o][De[r]];
      }
      return p.kc = qt(s), p.kc && (p.Bd = Xt(s, 8)), p.cb = 1;
    }
    function va(p, w, o, t, r, s, l) {
      var h = w[r].Yb[o];
      for (o = 0; 16 > r; ++r) {
        if (!Gt(p, h[o + 0])) return r;
        for (; !Gt(p, h[o + 1]); ) if (h = w[++r].Yb[0], o = 0, r == 16) return 16;
        var g = w[r + 1].Yb;
        if (Gt(p, h[o + 2])) {
          var _ = p, A = 0;
          if (Gt(_, (E = h)[(L = o) + 3])) if (Gt(_, E[L + 6])) {
            for (h = 0, L = 2 * (A = Gt(_, E[L + 8])) + (E = Gt(_, E[L + 9 + A])), A = 0, E = Dc[L]; E[h]; ++h) A += A + Gt(_, E[h]);
            A += 3 + (8 << L);
          } else Gt(_, E[L + 7]) ? (A = 7 + 2 * Gt(_, 165), A += Gt(_, 145)) : A = 5 + Gt(_, 159);
          else A = Gt(_, E[L + 4]) ? 3 + Gt(_, E[L + 5]) : 2;
          h = g[2];
        } else A = 1, h = g[1];
        g = l + sc[r], 0 > (_ = p).b && Rt(_);
        var L, E = _.b, M = (L = _.Ca >> 1) - (_.I >> E) >> 31;
        --_.b, _.Ca += M, _.Ca |= 1, _.I -= (L + 1 & M) << E, s[g] = ((A ^ M) - M) * t[(0 < r) + 0];
      }
      return 16;
    }
    function cn(p) {
      var w = p.rb[p.sb - 1];
      w.la = 0, w.Na = 0, k(p.zc, 0, 0, p.zc.length), p.ja = 0;
    }
    function Fo(p, w) {
      if (p == null) return 0;
      if (w == null) return Ji(p, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!p.cb && !sr(p, w)) return 0;
      if (f(p.cb), w.ac == null || w.ac(w)) {
        w.ob && (p.L = 0);
        var o = ua[p.L];
        if (p.L == 2 ? (p.yb = 0, p.zb = 0) : (p.yb = w.v - o >> 4, p.zb = w.j - o >> 4, 0 > p.yb && (p.yb = 0), 0 > p.zb && (p.zb = 0)), p.Va = w.o + 15 + o >> 4, p.Hb = w.va + 15 + o >> 4, p.Hb > p.za && (p.Hb = p.za), p.Va > p.Ub && (p.Va = p.Ub), 0 < p.L) {
          var t = p.ed;
          for (o = 0; 4 > o; ++o) {
            var r;
            if (p.Qa.Cb) {
              var s = p.Qa.Lb[o];
              p.Qa.Fb || (s += t.Tb);
            } else s = t.Tb;
            for (r = 0; 1 >= r; ++r) {
              var l = p.gd[o][r], h = s;
              if (t.Pc && (h += t.vd[0], r && (h += t.od[0])), 0 < (h = 0 > h ? 0 : 63 < h ? 63 : h)) {
                var g = h;
                0 < t.wb && (g = 4 < t.wb ? g >> 2 : g >> 1) > 9 - t.wb && (g = 9 - t.wb), 1 > g && (g = 1), l.dd = g, l.tc = 2 * h + g, l.ld = 40 <= h ? 2 : 15 <= h ? 1 : 0;
              } else l.tc = 0;
              l.La = r;
            }
          }
        }
        o = 0;
      } else Ji(p, 6, "Frame setup failed"), o = p.a;
      if (o = o == 0) {
        if (o) {
          p.$c = 0, 0 < p.Aa || (p.Ic = Qe);
          t: {
            o = p.Ic, t = 4 * (g = p.za);
            var _ = 32 * g, A = g + 1, L = 0 < p.L ? g * (0 < p.Aa ? 2 : 1) : 0, E = (p.Aa == 2 ? 2 : 1) * g;
            if ((l = t + 832 + (r = 3 * (16 * o + ua[p.L]) / 2 * _) + (s = p.Fa != null && 0 < p.Fa.length ? p.Kc.c * p.Kc.i : 0)) != l) o = 0;
            else {
              if (l > p.Vb) {
                if (p.Vb = 0, p.Ec = P(l), p.Fc = 0, p.Ec == null) {
                  o = Ji(p, 1, "no memory during frame initialization.");
                  break t;
                }
                p.Vb = l;
              }
              l = p.Ec, h = p.Fc, p.Ac = l, p.Bc = h, h += t, p.Gd = v(_, Yr), p.Hd = 0, p.rb = v(A + 1, Hr), p.sb = 1, p.wa = L ? v(L, Ks) : null, p.Y = 0, p.D.Nb = 0, p.D.wa = p.wa, p.D.Y = p.Y, 0 < p.Aa && (p.D.Y += g), f(!0), p.oc = l, p.pc = h, h += 832, p.ya = v(E, Do), p.aa = 0, p.D.ya = p.ya, p.D.aa = p.aa, p.Aa == 2 && (p.D.aa += g), p.R = 16 * g, p.B = 8 * g, g = (_ = ua[p.L]) * p.R, _ = _ / 2 * p.B, p.sa = l, p.ta = h + g, p.qa = p.sa, p.ra = p.ta + 16 * o * p.R + _, p.Ha = p.qa, p.Ia = p.ra + 8 * o * p.B + _, p.$c = 0, h += r, p.mb = s ? l : null, p.nb = s ? h : null, f(h + s <= p.Fc + p.Vb), cn(p), k(p.Ac, p.Bc, 0, t), o = 1;
            }
          }
          if (o) {
            if (w.ka = 0, w.y = p.sa, w.O = p.ta, w.f = p.qa, w.N = p.ra, w.ea = p.Ha, w.Vd = p.Ia, w.fa = p.R, w.Rc = p.B, w.F = null, w.J = 0, !ca) {
              for (o = -255; 255 >= o; ++o) Ir[255 + o] = 0 > o ? -o : o;
              for (o = -1020; 1020 >= o; ++o) $i[1020 + o] = -128 > o ? -128 : 127 < o ? 127 : o;
              for (o = -112; 112 >= o; ++o) un[112 + o] = -16 > o ? -16 : 15 < o ? 15 : o;
              for (o = -255; 510 >= o; ++o) Nr[255 + o] = 0 > o ? 0 : 255 < o ? 255 : o;
              ca = 1;
            }
            ka = Ro, ws = Fi, oa = $a, Pr = Bo, Ur = zs, ar = Qn, ss = eo, lo = Aa, Ss = pl, as = io, As = dl, os = ea, js = ro, co = jo, la = es, ls = Si, Ta = Fn, Qr = Nl, Tn[0] = An, Tn[1] = xa, Tn[2] = Xa, Tn[3] = Ha, Tn[4] = Oo, Tn[5] = Ya, Tn[6] = Ns, Tn[7] = Ka, Tn[8] = El, Tn[9] = hl, cs[0] = cl, cs[1] = ta, cs[2] = fs, cs[3] = Wa, cs[4] = mr, cs[5] = wa, cs[6] = Or, Is[0] = ms, Is[1] = Za, Is[2] = zl, Is[3] = Ja, Is[4] = Ds, Is[5] = Qa, Is[6] = Sa, o = 1;
          } else o = 0;
        }
        o && (o = function(M, R) {
          for (M.M = 0; M.M < M.Va; ++M.M) {
            var q, B = M.Jc[M.M & M.Xb], $ = M.m, Q = M;
            for (q = 0; q < Q.za; ++q) {
              var tt = $, nt = Q, it = nt.Ac, ht = nt.Bc + 4 * q, wt = nt.zc, _t = nt.ya[nt.aa + q];
              if (nt.Qa.Bb ? _t.$b = Gt(tt, nt.Pa.jb[0]) ? 2 + Gt(tt, nt.Pa.jb[2]) : Gt(tt, nt.Pa.jb[1]) : _t.$b = 0, nt.kc && (_t.Ad = Gt(tt, nt.Bd)), _t.Za = !Gt(tt, 145) + 0, _t.Za) {
                var Vt = _t.Ob, re = 0;
                for (nt = 0; 4 > nt; ++nt) {
                  var ce, de = wt[0 + nt];
                  for (ce = 0; 4 > ce; ++ce) {
                    de = go[it[ht + ce]][de];
                    for (var ue = Rl[Gt(tt, de[0])]; 0 < ue; ) ue = Rl[2 * ue + Gt(tt, de[ue])];
                    de = -ue, it[ht + ce] = de;
                  }
                  b(Vt, re, it, ht, 4), re += 4, wt[0 + nt] = de;
                }
              } else de = Gt(tt, 156) ? Gt(tt, 128) ? 1 : 3 : Gt(tt, 163) ? 2 : 0, _t.Ob[0] = de, k(it, ht, de, 4), k(wt, 0, de, 4);
              _t.Dd = Gt(tt, 142) ? Gt(tt, 114) ? Gt(tt, 183) ? 1 : 3 : 2 : 0;
            }
            if (Q.m.Ka) return Ji(M, 7, "Premature end-of-partition0 encountered.");
            for (; M.ja < M.za; ++M.ja) {
              if (Q = B, tt = ($ = M).rb[$.sb - 1], it = $.rb[$.sb + $.ja], q = $.ya[$.aa + $.ja], ht = $.kc ? q.Ad : 0) tt.la = it.la = 0, q.Za || (tt.Na = it.Na = 0), q.Hc = 0, q.Gc = 0, q.ia = 0;
              else {
                var he, fe;
                if (tt = it, it = Q, ht = $.Pa.Xc, wt = $.ya[$.aa + $.ja], _t = $.pb[wt.$b], nt = wt.ad, Vt = 0, re = $.rb[$.sb - 1], de = ce = 0, k(nt, Vt, 0, 384), wt.Za) var Oe = 0, ve = ht[3];
                else {
                  ue = P(16);
                  var xe = tt.Na + re.Na;
                  if (xe = Ho(it, ht[1], xe, _t.Eb, 0, ue, 0), tt.Na = re.Na = (0 < xe) + 0, 1 < xe) ka(ue, 0, nt, Vt);
                  else {
                    var Ue = ue[0] + 3 >> 3;
                    for (ue = 0; 256 > ue; ue += 16) nt[Vt + ue] = Ue;
                  }
                  Oe = 1, ve = ht[0];
                }
                var ni = 15 & tt.la, ii = 15 & re.la;
                for (ue = 0; 4 > ue; ++ue) {
                  var ci = 1 & ii;
                  for (Ue = fe = 0; 4 > Ue; ++Ue) ni = ni >> 1 | (ci = (xe = Ho(it, ve, xe = ci + (1 & ni), _t.Sc, Oe, nt, Vt)) > Oe) << 7, fe = fe << 2 | (3 < xe ? 3 : 1 < xe ? 2 : nt[Vt + 0] != 0), Vt += 16;
                  ni >>= 4, ii = ii >> 1 | ci << 7, ce = (ce << 8 | fe) >>> 0;
                }
                for (ve = ni, Oe = ii >> 4, he = 0; 4 > he; he += 2) {
                  for (fe = 0, ni = tt.la >> 4 + he, ii = re.la >> 4 + he, ue = 0; 2 > ue; ++ue) {
                    for (ci = 1 & ii, Ue = 0; 2 > Ue; ++Ue) xe = ci + (1 & ni), ni = ni >> 1 | (ci = 0 < (xe = Ho(it, ht[2], xe, _t.Qc, 0, nt, Vt))) << 3, fe = fe << 2 | (3 < xe ? 3 : 1 < xe ? 2 : nt[Vt + 0] != 0), Vt += 16;
                    ni >>= 2, ii = ii >> 1 | ci << 5;
                  }
                  de |= fe << 4 * he, ve |= ni << 4 << he, Oe |= (240 & ii) << he;
                }
                tt.la = ve, re.la = Oe, wt.Hc = ce, wt.Gc = de, wt.ia = 43690 & de ? 0 : _t.ia, ht = !(ce | de);
              }
              if (0 < $.L && ($.wa[$.Y + $.ja] = $.gd[q.$b][q.Za], $.wa[$.Y + $.ja].La |= !ht), Q.Ka) return Ji(M, 7, "Premature end-of-file encountered.");
            }
            if (cn(M), $ = R, Q = 1, q = (B = M).D, tt = 0 < B.L && B.M >= B.zb && B.M <= B.Va, B.Aa == 0) t: {
              if (q.M = B.M, q.uc = tt, Bs(B, q), Q = 1, q = (fe = B.D).Nb, tt = (de = ua[B.L]) * B.R, it = de / 2 * B.B, ue = 16 * q * B.R, Ue = 8 * q * B.B, ht = B.sa, wt = B.ta - tt + ue, _t = B.qa, nt = B.ra - it + Ue, Vt = B.Ha, re = B.Ia - it + Ue, ii = (ni = fe.M) == 0, ce = ni >= B.Va - 1, B.Aa == 2 && Bs(B, fe), fe.uc) for (ci = (xe = B).D.M, f(xe.D.uc), fe = xe.yb; fe < xe.Hb; ++fe) {
                Oe = fe, ve = ci;
                var bi = (ji = (er = xe).D).Nb;
                he = er.R;
                var ji = ji.wa[ji.Y + Oe], tr = er.sa, Ni = er.ta + 16 * bi * he + 16 * Oe, ur = ji.dd, qi = ji.tc;
                if (qi != 0) if (f(3 <= qi), er.L == 1) 0 < Oe && ls(tr, Ni, he, qi + 4), ji.La && Qr(tr, Ni, he, qi), 0 < ve && la(tr, Ni, he, qi + 4), ji.La && Ta(tr, Ni, he, qi);
                else {
                  var or = er.B, xr = er.qa, dn = er.ra + 8 * bi * or + 8 * Oe, Cn = er.Ha, er = er.Ia + 8 * bi * or + 8 * Oe;
                  bi = ji.ld, 0 < Oe && (lo(tr, Ni, he, qi + 4, ur, bi), as(xr, dn, Cn, er, or, qi + 4, ur, bi)), ji.La && (os(tr, Ni, he, qi, ur, bi), co(xr, dn, Cn, er, or, qi, ur, bi)), 0 < ve && (ss(tr, Ni, he, qi + 4, ur, bi), Ss(xr, dn, Cn, er, or, qi + 4, ur, bi)), ji.La && (As(tr, Ni, he, qi, ur, bi), js(xr, dn, Cn, er, or, qi, ur, bi));
                }
              }
              if (B.ia && alert("todo:DitherRow"), $.put != null) {
                if (fe = 16 * ni, ni = 16 * (ni + 1), ii ? ($.y = B.sa, $.O = B.ta + ue, $.f = B.qa, $.N = B.ra + Ue, $.ea = B.Ha, $.W = B.Ia + Ue) : (fe -= de, $.y = ht, $.O = wt, $.f = _t, $.N = nt, $.ea = Vt, $.W = re), ce || (ni -= de), ni > $.o && (ni = $.o), $.F = null, $.J = null, B.Fa != null && 0 < B.Fa.length && fe < ni && ($.J = ao(B, $, fe, ni - fe), $.F = B.mb, $.F == null && $.F.length == 0)) {
                  Q = Ji(B, 3, "Could not decode alpha data.");
                  break t;
                }
                fe < $.j && (de = $.j - fe, fe = $.j, f(!(1 & de)), $.O += B.R * de, $.N += B.B * (de >> 1), $.W += B.B * (de >> 1), $.F != null && ($.J += $.width * de)), fe < ni && ($.O += $.v, $.N += $.v >> 1, $.W += $.v >> 1, $.F != null && ($.J += $.v), $.ka = fe - $.j, $.U = $.va - $.v, $.T = ni - fe, Q = $.put($));
              }
              q + 1 != B.Ic || ce || (b(B.sa, B.ta - tt, ht, wt + 16 * B.R, tt), b(B.qa, B.ra - it, _t, nt + 8 * B.B, it), b(B.Ha, B.Ia - it, Vt, re + 8 * B.B, it));
            }
            if (!Q) return Ji(M, 6, "Output aborted.");
          }
          return 1;
        }(p, w)), w.bc != null && w.bc(w), o &= 1;
      }
      return o ? (p.cb = 0, o) : 0;
    }
    function _r(p, w, o, t, r) {
      r = p[w + o + 32 * t] + (r >> 3), p[w + o + 32 * t] = -256 & r ? 0 > r ? 0 : 255 : r;
    }
    function Ga(p, w, o, t, r, s) {
      _r(p, w, 0, o, t + r), _r(p, w, 1, o, t + s), _r(p, w, 2, o, t - s), _r(p, w, 3, o, t - r);
    }
    function Rr(p) {
      return (20091 * p >> 16) + p;
    }
    function Jn(p, w, o, t) {
      var r, s = 0, l = P(16);
      for (r = 0; 4 > r; ++r) {
        var h = p[w + 0] + p[w + 8], g = p[w + 0] - p[w + 8], _ = (35468 * p[w + 4] >> 16) - Rr(p[w + 12]), A = Rr(p[w + 4]) + (35468 * p[w + 12] >> 16);
        l[s + 0] = h + A, l[s + 1] = g + _, l[s + 2] = g - _, l[s + 3] = h - A, s += 4, w++;
      }
      for (r = s = 0; 4 > r; ++r) h = (p = l[s + 0] + 4) + l[s + 8], g = p - l[s + 8], _ = (35468 * l[s + 4] >> 16) - Rr(l[s + 12]), _r(o, t, 0, 0, h + (A = Rr(l[s + 4]) + (35468 * l[s + 12] >> 16))), _r(o, t, 1, 0, g + _), _r(o, t, 2, 0, g - _), _r(o, t, 3, 0, h - A), s++, t += 32;
    }
    function Qn(p, w, o, t) {
      var r = p[w + 0] + 4, s = 35468 * p[w + 4] >> 16, l = Rr(p[w + 4]), h = 35468 * p[w + 1] >> 16;
      Ga(o, t, 0, r + l, p = Rr(p[w + 1]), h), Ga(o, t, 1, r + s, p, h), Ga(o, t, 2, r - s, p, h), Ga(o, t, 3, r - l, p, h);
    }
    function Fi(p, w, o, t, r) {
      Jn(p, w, o, t), r && Jn(p, w + 16, o, t + 4);
    }
    function $a(p, w, o, t) {
      ws(p, w + 0, o, t, 1), ws(p, w + 32, o, t + 128, 1);
    }
    function Bo(p, w, o, t) {
      var r;
      for (p = p[w + 0] + 4, r = 0; 4 > r; ++r) for (w = 0; 4 > w; ++w) _r(o, t, w, r, p);
    }
    function zs(p, w, o, t) {
      p[w + 0] && Pr(p, w + 0, o, t), p[w + 16] && Pr(p, w + 16, o, t + 4), p[w + 32] && Pr(p, w + 32, o, t + 128), p[w + 48] && Pr(p, w + 48, o, t + 128 + 4);
    }
    function Ro(p, w, o, t) {
      var r, s = P(16);
      for (r = 0; 4 > r; ++r) {
        var l = p[w + 0 + r] + p[w + 12 + r], h = p[w + 4 + r] + p[w + 8 + r], g = p[w + 4 + r] - p[w + 8 + r], _ = p[w + 0 + r] - p[w + 12 + r];
        s[0 + r] = l + h, s[8 + r] = l - h, s[4 + r] = _ + g, s[12 + r] = _ - g;
      }
      for (r = 0; 4 > r; ++r) l = (p = s[0 + 4 * r] + 3) + s[3 + 4 * r], h = s[1 + 4 * r] + s[2 + 4 * r], g = s[1 + 4 * r] - s[2 + 4 * r], _ = p - s[3 + 4 * r], o[t + 0] = l + h >> 3, o[t + 16] = _ + g >> 3, o[t + 32] = l - h >> 3, o[t + 48] = _ - g >> 3, t += 64;
    }
    function Qs(p, w, o) {
      var t, r = w - 32, s = Dr, l = 255 - p[r - 1];
      for (t = 0; t < o; ++t) {
        var h, g = s, _ = l + p[w - 1];
        for (h = 0; h < o; ++h) p[w + h] = g[_ + p[r + h]];
        w += 32;
      }
    }
    function xa(p, w) {
      Qs(p, w, 4);
    }
    function Za(p, w) {
      Qs(p, w, 8);
    }
    function ta(p, w) {
      Qs(p, w, 16);
    }
    function fs(p, w) {
      var o;
      for (o = 0; 16 > o; ++o) b(p, w + 32 * o, p, w - 32, 16);
    }
    function Wa(p, w) {
      var o;
      for (o = 16; 0 < o; --o) k(p, w, p[w - 1], 16), w += 32;
    }
    function ba(p, w, o) {
      var t;
      for (t = 0; 16 > t; ++t) k(w, o + 32 * t, p, 16);
    }
    function cl(p, w) {
      var o, t = 16;
      for (o = 0; 16 > o; ++o) t += p[w - 1 + 32 * o] + p[w + o - 32];
      ba(t >> 5, p, w);
    }
    function mr(p, w) {
      var o, t = 8;
      for (o = 0; 16 > o; ++o) t += p[w - 1 + 32 * o];
      ba(t >> 4, p, w);
    }
    function wa(p, w) {
      var o, t = 8;
      for (o = 0; 16 > o; ++o) t += p[w + o - 32];
      ba(t >> 4, p, w);
    }
    function Or(p, w) {
      ba(128, p, w);
    }
    function He(p, w, o) {
      return p + 2 * w + o + 2 >> 2;
    }
    function Xa(p, w) {
      var o, t = w - 32;
      for (t = new Uint8Array([He(p[t - 1], p[t + 0], p[t + 1]), He(p[t + 0], p[t + 1], p[t + 2]), He(p[t + 1], p[t + 2], p[t + 3]), He(p[t + 2], p[t + 3], p[t + 4])]), o = 0; 4 > o; ++o) b(p, w + 32 * o, t, 0, t.length);
    }
    function Ha(p, w) {
      var o = p[w - 1], t = p[w - 1 + 32], r = p[w - 1 + 64], s = p[w - 1 + 96];
      we(p, w + 0, 16843009 * He(p[w - 1 - 32], o, t)), we(p, w + 32, 16843009 * He(o, t, r)), we(p, w + 64, 16843009 * He(t, r, s)), we(p, w + 96, 16843009 * He(r, s, s));
    }
    function An(p, w) {
      var o, t = 4;
      for (o = 0; 4 > o; ++o) t += p[w + o - 32] + p[w - 1 + 32 * o];
      for (t >>= 3, o = 0; 4 > o; ++o) k(p, w + 32 * o, t, 4);
    }
    function Oo(p, w) {
      var o = p[w - 1 + 0], t = p[w - 1 + 32], r = p[w - 1 + 64], s = p[w - 1 - 32], l = p[w + 0 - 32], h = p[w + 1 - 32], g = p[w + 2 - 32], _ = p[w + 3 - 32];
      p[w + 0 + 96] = He(t, r, p[w - 1 + 96]), p[w + 1 + 96] = p[w + 0 + 64] = He(o, t, r), p[w + 2 + 96] = p[w + 1 + 64] = p[w + 0 + 32] = He(s, o, t), p[w + 3 + 96] = p[w + 2 + 64] = p[w + 1 + 32] = p[w + 0 + 0] = He(l, s, o), p[w + 3 + 64] = p[w + 2 + 32] = p[w + 1 + 0] = He(h, l, s), p[w + 3 + 32] = p[w + 2 + 0] = He(g, h, l), p[w + 3 + 0] = He(_, g, h);
    }
    function Ns(p, w) {
      var o = p[w + 1 - 32], t = p[w + 2 - 32], r = p[w + 3 - 32], s = p[w + 4 - 32], l = p[w + 5 - 32], h = p[w + 6 - 32], g = p[w + 7 - 32];
      p[w + 0 + 0] = He(p[w + 0 - 32], o, t), p[w + 1 + 0] = p[w + 0 + 32] = He(o, t, r), p[w + 2 + 0] = p[w + 1 + 32] = p[w + 0 + 64] = He(t, r, s), p[w + 3 + 0] = p[w + 2 + 32] = p[w + 1 + 64] = p[w + 0 + 96] = He(r, s, l), p[w + 3 + 32] = p[w + 2 + 64] = p[w + 1 + 96] = He(s, l, h), p[w + 3 + 64] = p[w + 2 + 96] = He(l, h, g), p[w + 3 + 96] = He(h, g, g);
    }
    function Ya(p, w) {
      var o = p[w - 1 + 0], t = p[w - 1 + 32], r = p[w - 1 + 64], s = p[w - 1 - 32], l = p[w + 0 - 32], h = p[w + 1 - 32], g = p[w + 2 - 32], _ = p[w + 3 - 32];
      p[w + 0 + 0] = p[w + 1 + 64] = s + l + 1 >> 1, p[w + 1 + 0] = p[w + 2 + 64] = l + h + 1 >> 1, p[w + 2 + 0] = p[w + 3 + 64] = h + g + 1 >> 1, p[w + 3 + 0] = g + _ + 1 >> 1, p[w + 0 + 96] = He(r, t, o), p[w + 0 + 64] = He(t, o, s), p[w + 0 + 32] = p[w + 1 + 96] = He(o, s, l), p[w + 1 + 32] = p[w + 2 + 96] = He(s, l, h), p[w + 2 + 32] = p[w + 3 + 96] = He(l, h, g), p[w + 3 + 32] = He(h, g, _);
    }
    function Ka(p, w) {
      var o = p[w + 0 - 32], t = p[w + 1 - 32], r = p[w + 2 - 32], s = p[w + 3 - 32], l = p[w + 4 - 32], h = p[w + 5 - 32], g = p[w + 6 - 32], _ = p[w + 7 - 32];
      p[w + 0 + 0] = o + t + 1 >> 1, p[w + 1 + 0] = p[w + 0 + 64] = t + r + 1 >> 1, p[w + 2 + 0] = p[w + 1 + 64] = r + s + 1 >> 1, p[w + 3 + 0] = p[w + 2 + 64] = s + l + 1 >> 1, p[w + 0 + 32] = He(o, t, r), p[w + 1 + 32] = p[w + 0 + 96] = He(t, r, s), p[w + 2 + 32] = p[w + 1 + 96] = He(r, s, l), p[w + 3 + 32] = p[w + 2 + 96] = He(s, l, h), p[w + 3 + 64] = He(l, h, g), p[w + 3 + 96] = He(h, g, _);
    }
    function hl(p, w) {
      var o = p[w - 1 + 0], t = p[w - 1 + 32], r = p[w - 1 + 64], s = p[w - 1 + 96];
      p[w + 0 + 0] = o + t + 1 >> 1, p[w + 2 + 0] = p[w + 0 + 32] = t + r + 1 >> 1, p[w + 2 + 32] = p[w + 0 + 64] = r + s + 1 >> 1, p[w + 1 + 0] = He(o, t, r), p[w + 3 + 0] = p[w + 1 + 32] = He(t, r, s), p[w + 3 + 32] = p[w + 1 + 64] = He(r, s, s), p[w + 3 + 64] = p[w + 2 + 64] = p[w + 0 + 96] = p[w + 1 + 96] = p[w + 2 + 96] = p[w + 3 + 96] = s;
    }
    function El(p, w) {
      var o = p[w - 1 + 0], t = p[w - 1 + 32], r = p[w - 1 + 64], s = p[w - 1 + 96], l = p[w - 1 - 32], h = p[w + 0 - 32], g = p[w + 1 - 32], _ = p[w + 2 - 32];
      p[w + 0 + 0] = p[w + 2 + 32] = o + l + 1 >> 1, p[w + 0 + 32] = p[w + 2 + 64] = t + o + 1 >> 1, p[w + 0 + 64] = p[w + 2 + 96] = r + t + 1 >> 1, p[w + 0 + 96] = s + r + 1 >> 1, p[w + 3 + 0] = He(h, g, _), p[w + 2 + 0] = He(l, h, g), p[w + 1 + 0] = p[w + 3 + 32] = He(o, l, h), p[w + 1 + 32] = p[w + 3 + 64] = He(t, o, l), p[w + 1 + 64] = p[w + 3 + 96] = He(r, t, o), p[w + 1 + 96] = He(s, r, t);
    }
    function zl(p, w) {
      var o;
      for (o = 0; 8 > o; ++o) b(p, w + 32 * o, p, w - 32, 8);
    }
    function Ja(p, w) {
      var o;
      for (o = 0; 8 > o; ++o) k(p, w, p[w - 1], 8), w += 32;
    }
    function ts(p, w, o) {
      var t;
      for (t = 0; 8 > t; ++t) k(w, o + 32 * t, p, 8);
    }
    function ms(p, w) {
      var o, t = 8;
      for (o = 0; 8 > o; ++o) t += p[w + o - 32] + p[w - 1 + 32 * o];
      ts(t >> 4, p, w);
    }
    function Qa(p, w) {
      var o, t = 4;
      for (o = 0; 8 > o; ++o) t += p[w + o - 32];
      ts(t >> 3, p, w);
    }
    function Ds(p, w) {
      var o, t = 4;
      for (o = 0; 8 > o; ++o) t += p[w - 1 + 32 * o];
      ts(t >> 3, p, w);
    }
    function Sa(p, w) {
      ts(128, p, w);
    }
    function hn(p, w, o) {
      var t = p[w - o], r = p[w + 0], s = 3 * (r - t) + $o[1020 + p[w - 2 * o] - p[w + o]], l = La[112 + (s + 4 >> 3)];
      p[w - o] = Dr[255 + t + La[112 + (s + 3 >> 3)]], p[w + 0] = Dr[255 + r - l];
    }
    function ul(p, w, o, t) {
      var r = p[w + 0], s = p[w + o];
      return kr[255 + p[w - 2 * o] - p[w - o]] > t || kr[255 + s - r] > t;
    }
    function to(p, w, o, t) {
      return 4 * kr[255 + p[w - o] - p[w + 0]] + kr[255 + p[w - 2 * o] - p[w + o]] <= t;
    }
    function gs(p, w, o, t, r) {
      var s = p[w - 3 * o], l = p[w - 2 * o], h = p[w - o], g = p[w + 0], _ = p[w + o], A = p[w + 2 * o], L = p[w + 3 * o];
      return 4 * kr[255 + h - g] + kr[255 + l - _] > t ? 0 : kr[255 + p[w - 4 * o] - s] <= r && kr[255 + s - l] <= r && kr[255 + l - h] <= r && kr[255 + L - A] <= r && kr[255 + A - _] <= r && kr[255 + _ - g] <= r;
    }
    function es(p, w, o, t) {
      var r = 2 * t + 1;
      for (t = 0; 16 > t; ++t) to(p, w + t, o, r) && hn(p, w + t, o);
    }
    function Si(p, w, o, t) {
      var r = 2 * t + 1;
      for (t = 0; 16 > t; ++t) to(p, w + t * o, 1, r) && hn(p, w + t * o, 1);
    }
    function Fn(p, w, o, t) {
      var r;
      for (r = 3; 0 < r; --r) es(p, w += 4 * o, o, t);
    }
    function Nl(p, w, o, t) {
      var r;
      for (r = 3; 0 < r; --r) Si(p, w += 4, o, t);
    }
    function Pn(p, w, o, t, r, s, l, h) {
      for (s = 2 * s + 1; 0 < r--; ) {
        if (gs(p, w, o, s, l)) if (ul(p, w, o, h)) hn(p, w, o);
        else {
          var g = p, _ = w, A = o, L = g[_ - 2 * A], E = g[_ - A], M = g[_ + 0], R = g[_ + A], q = g[_ + 2 * A], B = 27 * (Q = $o[1020 + 3 * (M - E) + $o[1020 + L - R]]) + 63 >> 7, $ = 18 * Q + 63 >> 7, Q = 9 * Q + 63 >> 7;
          g[_ - 3 * A] = Dr[255 + g[_ - 3 * A] + Q], g[_ - 2 * A] = Dr[255 + L + $], g[_ - A] = Dr[255 + E + B], g[_ + 0] = Dr[255 + M - B], g[_ + A] = Dr[255 + R - $], g[_ + 2 * A] = Dr[255 + q - Q];
        }
        w += t;
      }
    }
    function is(p, w, o, t, r, s, l, h) {
      for (s = 2 * s + 1; 0 < r--; ) {
        if (gs(p, w, o, s, l)) if (ul(p, w, o, h)) hn(p, w, o);
        else {
          var g = p, _ = w, A = o, L = g[_ - A], E = g[_ + 0], M = g[_ + A], R = La[112 + ((q = 3 * (E - L)) + 4 >> 3)], q = La[112 + (q + 3 >> 3)], B = R + 1 >> 1;
          g[_ - 2 * A] = Dr[255 + g[_ - 2 * A] + B], g[_ - A] = Dr[255 + L + q], g[_ + 0] = Dr[255 + E - R], g[_ + A] = Dr[255 + M - B];
        }
        w += t;
      }
    }
    function eo(p, w, o, t, r, s) {
      Pn(p, w, o, 1, 16, t, r, s);
    }
    function Aa(p, w, o, t, r, s) {
      Pn(p, w, 1, o, 16, t, r, s);
    }
    function dl(p, w, o, t, r, s) {
      var l;
      for (l = 3; 0 < l; --l) is(p, w += 4 * o, o, 1, 16, t, r, s);
    }
    function ea(p, w, o, t, r, s) {
      var l;
      for (l = 3; 0 < l; --l) is(p, w += 4, 1, o, 16, t, r, s);
    }
    function pl(p, w, o, t, r, s, l, h) {
      Pn(p, w, r, 1, 8, s, l, h), Pn(o, t, r, 1, 8, s, l, h);
    }
    function io(p, w, o, t, r, s, l, h) {
      Pn(p, w, 1, r, 8, s, l, h), Pn(o, t, 1, r, 8, s, l, h);
    }
    function ro(p, w, o, t, r, s, l, h) {
      is(p, w + 4 * r, r, 1, 8, s, l, h), is(o, t + 4 * r, r, 1, 8, s, l, h);
    }
    function jo(p, w, o, t, r, s, l, h) {
      is(p, w + 4, 1, r, 8, s, l, h), is(o, t + 4, 1, r, 8, s, l, h);
    }
    function Bn() {
      this.ba = new Mr(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ut(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function no() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function qo() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Uo() {
      this.ua = 0, this.Wa = new Y(), this.vb = new Y(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new St(), this.yc = new lt();
    }
    function Pa() {
      this.xb = this.a = 0, this.l = new Dn(), this.ca = new Mr(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new K(), this.Pb = 0, this.wd = new K(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Uo(), this.ab = 0, this.gc = v(4, qo), this.Oc = 0;
    }
    function so() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Dn(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function ys(p, w, o, t, r, s, l) {
      for (p = p == null ? 0 : p[w + 0], w = 0; w < l; ++w) r[s + w] = p + o[t + w] & 255, p = r[s + w];
    }
    function Vo(p, w, o, t, r, s, l) {
      var h;
      if (p == null) ys(null, null, o, t, r, s, l);
      else for (h = 0; h < l; ++h) r[s + h] = p[w + h] + o[t + h] & 255;
    }
    function ia(p, w, o, t, r, s, l) {
      if (p == null) ys(null, null, o, t, r, s, l);
      else {
        var h, g = p[w + 0], _ = g, A = g;
        for (h = 0; h < l; ++h) _ = A + (g = p[w + h]) - _, A = o[t + h] + (-256 & _ ? 0 > _ ? 0 : 255 : _) & 255, _ = g, r[s + h] = A;
      }
    }
    function ao(p, w, o, t) {
      var r = w.width, s = w.o;
      if (f(p != null && w != null), 0 > o || 0 >= t || o + t > s) return null;
      if (!p.Cc) {
        if (p.ga == null) {
          var l;
          if (p.ga = new so(), (l = p.ga == null) || (l = w.width * w.o, f(p.Gb.length == 0), p.Gb = P(l), p.Uc = 0, p.Gb == null ? l = 0 : (p.mb = p.Gb, p.nb = p.Uc, p.rc = null, l = 1), l = !l), !l) {
            l = p.ga;
            var h = p.Fa, g = p.P, _ = p.qc, A = p.mb, L = p.nb, E = g + 1, M = _ - 1, R = l.l;
            if (f(h != null && A != null && w != null), ks[0] = null, ks[1] = ys, ks[2] = Vo, ks[3] = ia, l.ca = A, l.tb = L, l.c = w.width, l.i = w.height, f(0 < l.c && 0 < l.i), 1 >= _) w = 0;
            else if (l.$a = h[g + 0] >> 0 & 3, l.Z = h[g + 0] >> 2 & 3, l.Lc = h[g + 0] >> 4 & 3, g = h[g + 0] >> 6 & 3, 0 > l.$a || 1 < l.$a || 4 <= l.Z || 1 < l.Lc || g) w = 0;
            else if (R.put = Pt, R.ac = ct, R.bc = Mt, R.ma = l, R.width = w.width, R.height = w.height, R.Da = w.Da, R.v = w.v, R.va = w.va, R.j = w.j, R.o = w.o, l.$a) t: {
              f(l.$a == 1), w = Bi();
              e: for (; ; ) {
                if (w == null) {
                  w = 0;
                  break t;
                }
                if (f(l != null), l.mc = w, w.c = l.c, w.i = l.i, w.l = l.l, w.l.ma = l, w.l.width = l.c, w.l.height = l.i, w.a = 0, jt(w.m, h, E, M), !li(l.c, l.i, 1, w, null) || (w.ab == 1 && w.gc[0].hc == 3 && xi(w.s) ? (l.ic = 1, h = w.c * w.i, w.Ta = null, w.Ua = 0, w.V = P(h), w.Ba = 0, w.V == null ? (w.a = 1, w = 0) : w = 1) : (l.ic = 0, w = Di(w, l.c)), !w)) break e;
                w = 1;
                break t;
              }
              l.mc = null, w = 0;
            }
            else w = M >= l.c * l.i;
            l = !w;
          }
          if (l) return null;
          p.ga.Lc != 1 ? p.Ga = 0 : t = s - o;
        }
        f(p.ga != null), f(o + t <= s);
        t: {
          if (w = (h = p.ga).c, s = h.l.o, h.$a == 0) {
            if (E = p.rc, M = p.Vc, R = p.Fa, g = p.P + 1 + o * w, _ = p.mb, A = p.nb + o * w, f(g <= p.P + p.qc), h.Z != 0) for (f(ks[h.Z] != null), l = 0; l < t; ++l) ks[h.Z](E, M, R, g, _, A, w), E = _, M = A, A += w, g += w;
            else for (l = 0; l < t; ++l) b(_, A, R, g, w), E = _, M = A, A += w, g += w;
            p.rc = E, p.Vc = M;
          } else {
            if (f(h.mc != null), w = o + t, f((l = h.mc) != null), f(w <= l.i), l.C >= w) w = 1;
            else if (h.ic || Ft(), h.ic) {
              h = l.V, E = l.Ba, M = l.c;
              var q = l.i, B = (R = 1, g = l.$ / M, _ = l.$ % M, A = l.m, L = l.s, l.$), $ = M * q, Q = M * w, tt = L.wc, nt = B < Q ? me(L, _, g) : null;
              f(B <= $), f(w <= q), f(xi(L));
              e: for (; ; ) {
                for (; !A.h && B < Q; ) {
                  if (_ & tt || (nt = me(L, _, g)), f(nt != null), Et(A), 256 > (q = te(nt.G[0], nt.H[0], A))) h[E + B] = q, ++B, ++_ >= M && (_ = 0, ++g <= w && !(g % 16) && yi(l, g));
                  else {
                    if (!(280 > q)) {
                      R = 0;
                      break e;
                    }
                    q = bt(q - 256, A);
                    var it, ht = te(nt.G[4], nt.H[4], A);
                    if (Et(A), !(B >= (ht = Ut(M, ht = bt(ht, A))) && $ - B >= q)) {
                      R = 0;
                      break e;
                    }
                    for (it = 0; it < q; ++it) h[E + B + it] = h[E + B + it - ht];
                    for (B += q, _ += q; _ >= M; ) _ -= M, ++g <= w && !(g % 16) && yi(l, g);
                    B < Q && _ & tt && (nt = me(L, _, g));
                  }
                  f(A.h == xt(A));
                }
                yi(l, g > w ? w : g);
                break e;
              }
              !R || A.h && B < $ ? (R = 0, l.a = A.h ? 5 : 3) : l.$ = B, w = R;
            } else w = pi(l, l.V, l.Ba, l.c, l.i, w, Gi);
            if (!w) {
              t = 0;
              break t;
            }
          }
          o + t >= s && (p.Cc = 1), t = 1;
        }
        if (!t) return null;
        if (p.Cc && ((t = p.ga) != null && (t.mc = null), p.ga = null, 0 < p.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return p.nb + o * r;
    }
    function T(p, w, o, t, r, s) {
      for (; 0 < r--; ) {
        var l, h = p, g = w + (o ? 1 : 0), _ = p, A = w + (o ? 0 : 3);
        for (l = 0; l < t; ++l) {
          var L = _[A + 4 * l];
          L != 255 && (L *= 32897, h[g + 4 * l + 0] = h[g + 4 * l + 0] * L >> 23, h[g + 4 * l + 1] = h[g + 4 * l + 1] * L >> 23, h[g + 4 * l + 2] = h[g + 4 * l + 2] * L >> 23);
        }
        w += s;
      }
    }
    function H(p, w, o, t, r) {
      for (; 0 < t--; ) {
        var s;
        for (s = 0; s < o; ++s) {
          var l = p[w + 2 * s + 0], h = 15 & (_ = p[w + 2 * s + 1]), g = 4369 * h, _ = (240 & _ | _ >> 4) * g >> 16;
          p[w + 2 * s + 0] = (240 & l | l >> 4) * g >> 16 & 240 | (15 & l | l << 4) * g >> 16 >> 4 & 15, p[w + 2 * s + 1] = 240 & _ | h;
        }
        w += r;
      }
    }
    function ft(p, w, o, t, r, s, l, h) {
      var g, _, A = 255;
      for (_ = 0; _ < r; ++_) {
        for (g = 0; g < t; ++g) {
          var L = p[w + g];
          s[l + 4 * g] = L, A &= L;
        }
        w += o, l += h;
      }
      return A != 255;
    }
    function Ct(p, w, o, t, r) {
      var s;
      for (s = 0; s < r; ++s) o[t + s] = p[w + s] >> 8;
    }
    function Ft() {
      tn = T, Ii = H, Oi = ft, gr = Ct;
    }
    function Yt(p, w, o) {
      kt[p] = function(t, r, s, l, h, g, _, A, L, E, M, R, q, B, $, Q, tt) {
        var nt, it = tt - 1 >> 1, ht = h[g + 0] | _[A + 0] << 16, wt = L[E + 0] | M[R + 0] << 16;
        f(t != null);
        var _t = 3 * ht + wt + 131074 >> 2;
        for (w(t[r + 0], 255 & _t, _t >> 16, q, B), s != null && (_t = 3 * wt + ht + 131074 >> 2, w(s[l + 0], 255 & _t, _t >> 16, $, Q)), nt = 1; nt <= it; ++nt) {
          var Vt = h[g + nt] | _[A + nt] << 16, re = L[E + nt] | M[R + nt] << 16, ce = ht + Vt + wt + re + 524296, de = ce + 2 * (Vt + wt) >> 3;
          _t = de + ht >> 1, ht = (ce = ce + 2 * (ht + re) >> 3) + Vt >> 1, w(t[r + 2 * nt - 1], 255 & _t, _t >> 16, q, B + (2 * nt - 1) * o), w(t[r + 2 * nt - 0], 255 & ht, ht >> 16, q, B + (2 * nt - 0) * o), s != null && (_t = ce + wt >> 1, ht = de + re >> 1, w(s[l + 2 * nt - 1], 255 & _t, _t >> 16, $, Q + (2 * nt - 1) * o), w(s[l + 2 * nt + 0], 255 & ht, ht >> 16, $, Q + (2 * nt + 0) * o)), ht = Vt, wt = re;
        }
        1 & tt || (_t = 3 * ht + wt + 131074 >> 2, w(t[r + tt - 1], 255 & _t, _t >> 16, q, B + (tt - 1) * o), s != null && (_t = 3 * wt + ht + 131074 >> 2, w(s[l + tt - 1], 255 & _t, _t >> 16, $, Q + (tt - 1) * o)));
      };
    }
    function ye() {
      fi[ho] = jl, fi[Ca] = ml, fi[fl] = Fc, fi[Ma] = ac, fi[uo] = Na, fi[Zo] = ql, fi[ha] = Ul, fi[po] = ml, fi[Ea] = ac, fi[fo] = Na, fi[Wo] = ql;
    }
    function Be(p) {
      return p & ~Ln ? 0 > p ? 0 : 255 : p >> oc;
    }
    function Je(p, w) {
      return Be((19077 * p >> 8) + (26149 * w >> 8) - 14234);
    }
    function mi(p, w, o) {
      return Be((19077 * p >> 8) - (6419 * w >> 8) - (13320 * o >> 8) + 8708);
    }
    function gi(p, w) {
      return Be((19077 * p >> 8) + (33050 * w >> 8) - 17685);
    }
    function ki(p, w, o, t, r) {
      t[r + 0] = Je(p, o), t[r + 1] = mi(p, w, o), t[r + 2] = gi(p, w);
    }
    function Qi(p, w, o, t, r) {
      t[r + 0] = gi(p, w), t[r + 1] = mi(p, w, o), t[r + 2] = Je(p, o);
    }
    function vr(p, w, o, t, r) {
      var s = mi(p, w, o);
      w = s << 3 & 224 | gi(p, w) >> 3, t[r + 0] = 248 & Je(p, o) | s >> 5, t[r + 1] = w;
    }
    function Ai(p, w, o, t, r) {
      var s = 240 & gi(p, w) | 15;
      t[r + 0] = 240 & Je(p, o) | mi(p, w, o) >> 4, t[r + 1] = s;
    }
    function Kr(p, w, o, t, r) {
      t[r + 0] = 255, ki(p, w, o, t, r + 1);
    }
    function Ye(p, w, o, t, r) {
      Qi(p, w, o, t, r), t[r + 3] = 255;
    }
    function yn(p, w, o, t, r) {
      ki(p, w, o, t, r), t[r + 3] = 255;
    }
    function Ci(p, w) {
      return 0 > p ? 0 : p > w ? w : p;
    }
    function Mi(p, w, o) {
      kt[p] = function(t, r, s, l, h, g, _, A, L) {
        for (var E = A + (-2 & L) * o; A != E; ) w(t[r + 0], s[l + 0], h[g + 0], _, A), w(t[r + 1], s[l + 0], h[g + 0], _, A + o), r += 2, ++l, ++g, A += 2 * o;
        1 & L && w(t[r + 0], s[l + 0], h[g + 0], _, A);
      };
    }
    function _s(p, w, o) {
      return o == 0 ? p == 0 ? w == 0 ? 6 : 5 : w == 0 ? 4 : 0 : o;
    }
    function Fs(p, w, o, t, r) {
      switch (p >>> 30) {
        case 3:
          ws(w, o, t, r, 0);
          break;
        case 2:
          ar(w, o, t, r);
          break;
        case 1:
          Pr(w, o, t, r);
      }
    }
    function Bs(p, w) {
      var o, t, r = w.M, s = w.Nb, l = p.oc, h = p.pc + 40, g = p.oc, _ = p.pc + 584, A = p.oc, L = p.pc + 600;
      for (o = 0; 16 > o; ++o) l[h + 32 * o - 1] = 129;
      for (o = 0; 8 > o; ++o) g[_ + 32 * o - 1] = 129, A[L + 32 * o - 1] = 129;
      for (0 < r ? l[h - 1 - 32] = g[_ - 1 - 32] = A[L - 1 - 32] = 129 : (k(l, h - 32 - 1, 127, 21), k(g, _ - 32 - 1, 127, 9), k(A, L - 32 - 1, 127, 9)), t = 0; t < p.za; ++t) {
        var E = w.ya[w.aa + t];
        if (0 < t) {
          for (o = -1; 16 > o; ++o) b(l, h + 32 * o - 4, l, h + 32 * o + 12, 4);
          for (o = -1; 8 > o; ++o) b(g, _ + 32 * o - 4, g, _ + 32 * o + 4, 4), b(A, L + 32 * o - 4, A, L + 32 * o + 4, 4);
        }
        var M = p.Gd, R = p.Hd + t, q = E.ad, B = E.Hc;
        if (0 < r && (b(l, h - 32, M[R].y, 0, 16), b(g, _ - 32, M[R].f, 0, 8), b(A, L - 32, M[R].ea, 0, 8)), E.Za) {
          var $ = l, Q = h - 32 + 16;
          for (0 < r && (t >= p.za - 1 ? k($, Q, M[R].y[15], 4) : b($, Q, M[R + 1].y, 0, 4)), o = 0; 4 > o; o++) $[Q + 128 + o] = $[Q + 256 + o] = $[Q + 384 + o] = $[Q + 0 + o];
          for (o = 0; 16 > o; ++o, B <<= 2) $ = l, Q = h + hs[o], Tn[E.Ob[o]]($, Q), Fs(B, q, 16 * +o, $, Q);
        } else if ($ = _s(t, r, E.Ob[0]), cs[$](l, h), B != 0) for (o = 0; 16 > o; ++o, B <<= 2) Fs(B, q, 16 * +o, l, h + hs[o]);
        for (o = E.Gc, $ = _s(t, r, E.Dd), Is[$](g, _), Is[$](A, L), B = q, $ = g, Q = _, 255 & (E = o >> 0) && (170 & E ? oa(B, 256, $, Q) : Ur(B, 256, $, Q)), E = A, B = L, 255 & (o >>= 8) && (170 & o ? oa(q, 320, E, B) : Ur(q, 320, E, B)), r < p.Ub - 1 && (b(M[R].y, 0, l, h + 480, 16), b(M[R].f, 0, g, _ + 224, 8), b(M[R].ea, 0, A, L + 224, 8)), o = 8 * s * p.B, M = p.sa, R = p.ta + 16 * t + 16 * s * p.R, q = p.qa, E = p.ra + 8 * t + o, B = p.Ha, $ = p.Ia + 8 * t + o, o = 0; 16 > o; ++o) b(M, R + o * p.R, l, h + 32 * o, 16);
        for (o = 0; 8 > o; ++o) b(q, E + o * p.B, g, _ + 32 * o, 8), b(B, $ + o * p.B, A, L + 32 * o, 8);
      }
    }
    function ra(p, w, o, t, r, s, l, h, g) {
      var _ = [0], A = [0], L = 0, E = g != null ? g.kd : 0, M = g ?? new no();
      if (p == null || 12 > o) return 7;
      M.data = p, M.w = w, M.ha = o, w = [w], o = [o], M.gb = [M.gb];
      t: {
        var R = w, q = o, B = M.gb;
        if (f(p != null), f(q != null), f(B != null), B[0] = 0, 12 <= q[0] && !y(p, R[0], "RIFF")) {
          if (y(p, R[0] + 8, "WEBP")) {
            B = 3;
            break t;
          }
          var $ = Pe(p, R[0] + 4);
          if (12 > $ || 4294967286 < $) {
            B = 3;
            break t;
          }
          if (E && $ > q[0] - 8) {
            B = 7;
            break t;
          }
          B[0] = $, R[0] += 12, q[0] -= 12;
        }
        B = 0;
      }
      if (B != 0) return B;
      for ($ = 0 < M.gb[0], o = o[0]; ; ) {
        t: {
          var Q = p;
          q = w, B = o;
          var tt = _, nt = A, it = R = [0];
          if ((_t = L = [L])[0] = 0, 8 > B[0]) B = 7;
          else {
            if (!y(Q, q[0], "VP8X")) {
              if (Pe(Q, q[0] + 4) != 10) {
                B = 3;
                break t;
              }
              if (18 > B[0]) {
                B = 7;
                break t;
              }
              var ht = Pe(Q, q[0] + 8), wt = 1 + Ie(Q, q[0] + 12);
              if (2147483648 <= wt * (Q = 1 + Ie(Q, q[0] + 15))) {
                B = 3;
                break t;
              }
              it != null && (it[0] = ht), tt != null && (tt[0] = wt), nt != null && (nt[0] = Q), q[0] += 18, B[0] -= 18, _t[0] = 1;
            }
            B = 0;
          }
        }
        if (L = L[0], R = R[0], B != 0) return B;
        if (q = !!(2 & R), !$ && L) return 3;
        if (s != null && (s[0] = !!(16 & R)), l != null && (l[0] = q), h != null && (h[0] = 0), l = _[0], R = A[0], L && q && g == null) {
          B = 0;
          break;
        }
        if (4 > o) {
          B = 7;
          break;
        }
        if ($ && L || !$ && !L && !y(p, w[0], "ALPH")) {
          o = [o], M.na = [M.na], M.P = [M.P], M.Sa = [M.Sa];
          t: {
            ht = p, B = w, $ = o;
            var _t = M.gb;
            tt = M.na, nt = M.P, it = M.Sa, wt = 22, f(ht != null), f($ != null), Q = B[0];
            var Vt = $[0];
            for (f(tt != null), f(it != null), tt[0] = null, nt[0] = null, it[0] = 0; ; ) {
              if (B[0] = Q, $[0] = Vt, 8 > Vt) {
                B = 7;
                break t;
              }
              var re = Pe(ht, Q + 4);
              if (4294967286 < re) {
                B = 3;
                break t;
              }
              var ce = 8 + re + 1 & -2;
              if (wt += ce, 0 < _t && wt > _t) {
                B = 3;
                break t;
              }
              if (!y(ht, Q, "VP8 ") || !y(ht, Q, "VP8L")) {
                B = 0;
                break t;
              }
              if (Vt[0] < ce) {
                B = 7;
                break t;
              }
              y(ht, Q, "ALPH") || (tt[0] = ht, nt[0] = Q + 8, it[0] = re), Q += ce, Vt -= ce;
            }
          }
          if (o = o[0], M.na = M.na[0], M.P = M.P[0], M.Sa = M.Sa[0], B != 0) break;
        }
        o = [o], M.Ja = [M.Ja], M.xa = [M.xa];
        t: if (_t = p, B = w, $ = o, tt = M.gb[0], nt = M.Ja, it = M.xa, ht = B[0], Q = !y(_t, ht, "VP8 "), wt = !y(_t, ht, "VP8L"), f(_t != null), f($ != null), f(nt != null), f(it != null), 8 > $[0]) B = 7;
        else {
          if (Q || wt) {
            if (_t = Pe(_t, ht + 4), 12 <= tt && _t > tt - 12) {
              B = 3;
              break t;
            }
            if (E && _t > $[0] - 8) {
              B = 7;
              break t;
            }
            nt[0] = _t, B[0] += 8, $[0] -= 8, it[0] = wt;
          } else it[0] = 5 <= $[0] && _t[ht + 0] == 47 && !(_t[ht + 4] >> 5), nt[0] = $[0];
          B = 0;
        }
        if (o = o[0], M.Ja = M.Ja[0], M.xa = M.xa[0], w = w[0], B != 0) break;
        if (4294967286 < M.Ja) return 3;
        if (h == null || q || (h[0] = M.xa ? 2 : 1), l = [l], R = [R], M.xa) {
          if (5 > o) {
            B = 7;
            break;
          }
          h = l, E = R, q = s, p == null || 5 > o ? p = 0 : 5 <= o && p[w + 0] == 47 && !(p[w + 4] >> 5) ? ($ = [0], _t = [0], tt = [0], jt(nt = new K(), p, w, o), At(nt, $, _t, tt) ? (h != null && (h[0] = $[0]), E != null && (E[0] = _t[0]), q != null && (q[0] = tt[0]), p = 1) : p = 0) : p = 0;
        } else {
          if (10 > o) {
            B = 7;
            break;
          }
          h = R, p == null || 10 > o || !gn(p, w + 3, o - 3) ? p = 0 : (E = p[w + 0] | p[w + 1] << 8 | p[w + 2] << 16, q = 16383 & (p[w + 7] << 8 | p[w + 6]), p = 16383 & (p[w + 9] << 8 | p[w + 8]), 1 & E || 3 < (E >> 1 & 7) || !(E >> 4 & 1) || E >> 5 >= M.Ja || !q || !p ? p = 0 : (l && (l[0] = q), h && (h[0] = p), p = 1));
        }
        if (!p || (l = l[0], R = R[0], L && (_[0] != l || A[0] != R))) return 3;
        g != null && (g[0] = M, g.offset = w - g.w, f(4294967286 > w - g.w), f(g.offset == g.ha - o));
        break;
      }
      return B == 0 || B == 7 && L && g == null ? (s != null && (s[0] |= M.na != null && 0 < M.na.length), t != null && (t[0] = l), r != null && (r[0] = R), 0) : B;
    }
    function rs(p, w, o) {
      var t = w.width, r = w.height, s = 0, l = 0, h = t, g = r;
      if (w.Da = p != null && 0 < p.Da, w.Da && (h = p.cd, g = p.bd, s = p.v, l = p.j, 11 > o || (s &= -2, l &= -2), 0 > s || 0 > l || 0 >= h || 0 >= g || s + h > t || l + g > r)) return 0;
      if (w.v = s, w.j = l, w.va = s + h, w.o = l + g, w.U = h, w.T = g, w.da = p != null && 0 < p.da, w.da) {
        if (!ui(h, g, o = [p.ib], s = [p.hb])) return 0;
        w.ib = o[0], w.hb = s[0];
      }
      return w.ob = p != null && p.ob, w.Kb = p == null || !p.Sd, w.da && (w.ob = w.ib < 3 * t / 4 && w.hb < 3 * r / 4, w.Kb = 0), 1;
    }
    function vs(p) {
      if (p == null) return 2;
      if (11 > p.S) {
        var w = p.f.RGBA;
        w.fb += (p.height - 1) * w.A, w.A = -w.A;
      } else w = p.f.kb, p = p.height, w.O += (p - 1) * w.fa, w.fa = -w.fa, w.N += (p - 1 >> 1) * w.Ab, w.Ab = -w.Ab, w.W += (p - 1 >> 1) * w.Db, w.Db = -w.Db, w.F != null && (w.J += (p - 1) * w.lb, w.lb = -w.lb);
      return 0;
    }
    function jr(p, w, o, t) {
      if (t == null || 0 >= p || 0 >= w) return 2;
      if (o != null) {
        if (o.Da) {
          var r = o.cd, s = o.bd, l = -2 & o.v, h = -2 & o.j;
          if (0 > l || 0 > h || 0 >= r || 0 >= s || l + r > p || h + s > w) return 2;
          p = r, w = s;
        }
        if (o.da) {
          if (!ui(p, w, r = [o.ib], s = [o.hb])) return 2;
          p = r[0], w = s[0];
        }
      }
      t.width = p, t.height = w;
      t: {
        var g = t.width, _ = t.height;
        if (p = t.S, 0 >= g || 0 >= _ || !(p >= ho && 13 > p)) p = 2;
        else {
          if (0 >= t.Rd && t.sd == null) {
            l = s = r = w = 0;
            var A = (h = g * Qo[p]) * _;
            if (11 > p || (s = (_ + 1) / 2 * (w = (g + 1) / 2), p == 12 && (l = (r = g) * _)), (_ = P(A + 2 * s + l)) == null) {
              p = 1;
              break t;
            }
            t.sd = _, 11 > p ? ((g = t.f.RGBA).eb = _, g.fb = 0, g.A = h, g.size = A) : ((g = t.f.kb).y = _, g.O = 0, g.fa = h, g.Fd = A, g.f = _, g.N = 0 + A, g.Ab = w, g.Cd = s, g.ea = _, g.W = 0 + A + s, g.Db = w, g.Ed = s, p == 12 && (g.F = _, g.J = 0 + A + 2 * s), g.Tc = l, g.lb = r);
          }
          if (w = 1, r = t.S, s = t.width, l = t.height, r >= ho && 13 > r) if (11 > r) p = t.f.RGBA, w &= (h = Math.abs(p.A)) * (l - 1) + s <= p.size, w &= h >= s * Qo[r], w &= p.eb != null;
          else {
            p = t.f.kb, h = (s + 1) / 2, A = (l + 1) / 2, g = Math.abs(p.fa), _ = Math.abs(p.Ab);
            var L = Math.abs(p.Db), E = Math.abs(p.lb), M = E * (l - 1) + s;
            w &= g * (l - 1) + s <= p.Fd, w &= _ * (A - 1) + h <= p.Cd, w = (w &= L * (A - 1) + h <= p.Ed) & g >= s & _ >= h & L >= h, w &= p.y != null, w &= p.f != null, w &= p.ea != null, r == 12 && (w &= E >= s, w &= M <= p.Tc, w &= p.F != null);
          }
          else w = 0;
          p = w ? 0 : 2;
        }
      }
      return p != 0 || o != null && o.fd && (p = vs(t)), p;
    }
    var Lr = 64, na = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], sa = 24, Rn = 32, Rs = 8, zr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    _e("Predictor0", "PredictorAdd0"), kt.Predictor0 = function() {
      return 4278190080;
    }, kt.Predictor1 = function(p) {
      return p;
    }, kt.Predictor2 = function(p, w, o) {
      return w[o + 0];
    }, kt.Predictor3 = function(p, w, o) {
      return w[o + 1];
    }, kt.Predictor4 = function(p, w, o) {
      return w[o - 1];
    }, kt.Predictor5 = function(p, w, o) {
      return ke(ke(p, w[o + 1]), w[o + 0]);
    }, kt.Predictor6 = function(p, w, o) {
      return ke(p, w[o - 1]);
    }, kt.Predictor7 = function(p, w, o) {
      return ke(p, w[o + 0]);
    }, kt.Predictor8 = function(p, w, o) {
      return ke(w[o - 1], w[o + 0]);
    }, kt.Predictor9 = function(p, w, o) {
      return ke(w[o + 0], w[o + 1]);
    }, kt.Predictor10 = function(p, w, o) {
      return ke(ke(p, w[o - 1]), ke(w[o + 0], w[o + 1]));
    }, kt.Predictor11 = function(p, w, o) {
      var t = w[o + 0];
      return 0 >= ai(t >> 24 & 255, p >> 24 & 255, (w = w[o - 1]) >> 24 & 255) + ai(t >> 16 & 255, p >> 16 & 255, w >> 16 & 255) + ai(t >> 8 & 255, p >> 8 & 255, w >> 8 & 255) + ai(255 & t, 255 & p, 255 & w) ? t : p;
    }, kt.Predictor12 = function(p, w, o) {
      var t = w[o + 0];
      return (Ze((p >> 24 & 255) + (t >> 24 & 255) - ((w = w[o - 1]) >> 24 & 255)) << 24 | Ze((p >> 16 & 255) + (t >> 16 & 255) - (w >> 16 & 255)) << 16 | Ze((p >> 8 & 255) + (t >> 8 & 255) - (w >> 8 & 255)) << 8 | Ze((255 & p) + (255 & t) - (255 & w))) >>> 0;
    }, kt.Predictor13 = function(p, w, o) {
      var t = w[o - 1];
      return (di((p = ke(p, w[o + 0])) >> 24 & 255, t >> 24 & 255) << 24 | di(p >> 16 & 255, t >> 16 & 255) << 16 | di(p >> 8 & 255, t >> 8 & 255) << 8 | di(p >> 0 & 255, t >> 0 & 255)) >>> 0;
    };
    var aa = kt.PredictorAdd0;
    kt.PredictorAdd1 = wi, _e("Predictor2", "PredictorAdd2"), _e("Predictor3", "PredictorAdd3"), _e("Predictor4", "PredictorAdd4"), _e("Predictor5", "PredictorAdd5"), _e("Predictor6", "PredictorAdd6"), _e("Predictor7", "PredictorAdd7"), _e("Predictor8", "PredictorAdd8"), _e("Predictor9", "PredictorAdd9"), _e("Predictor10", "PredictorAdd10"), _e("Predictor11", "PredictorAdd11"), _e("Predictor12", "PredictorAdd12"), _e("Predictor13", "PredictorAdd13");
    var Os = kt.PredictorAdd2;
    oi("ColorIndexInverseTransform", "MapARGB", "32b", function(p) {
      return p >> 8 & 255;
    }, function(p) {
      return p;
    }), oi("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(p) {
      return p;
    }, function(p) {
      return p >> 8 & 255;
    });
    var Ia, qr = kt.ColorIndexInverseTransform, ns = kt.MapARGB, Go = kt.VP8LColorIndexInverseTransformAlpha, oo = kt.MapAlpha, Pi = kt.VP8LPredictorsAdd = [];
    Pi.length = 16, (kt.VP8LPredictors = []).length = 16, (kt.VP8LPredictorsAdd_C = []).length = 16, (kt.VP8LPredictors_C = []).length = 16;
    var xs, _n, Jr, In, bs, On, ka, ws, ar, oa, Pr, Ur, ss, lo, Ss, as, As, os, js, co, la, ls, Ta, Qr, tn, Ii, Oi, gr, Ir = P(511), $i = P(2041), un = P(225), Nr = P(767), ca = 0, $o = $i, La = un, Dr = Nr, kr = Ir, ho = 0, Ca = 1, fl = 2, Ma = 3, uo = 4, Zo = 5, ha = 6, po = 7, Ea = 8, fo = 9, Wo = 10, Dl = [2, 3, 7], Fl = [3, 3, 11], Xo = [280, 256, 256, 256, 40], mo = [0, 1, 1, 1, 0], nc = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], jn = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Ps = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Bl = 8, kn = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], qs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], Ho = null, Dc = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], sc = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], Rl = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Ol = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], go = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], qn = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], De = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], cs = [], Tn = [], Is = [], yo = 1, za = 2, ks = [], fi = [];
    Yt("UpsampleRgbLinePair", ki, 3), Yt("UpsampleBgrLinePair", Qi, 3), Yt("UpsampleRgbaLinePair", yn, 4), Yt("UpsampleBgraLinePair", Ye, 4), Yt("UpsampleArgbLinePair", Kr, 4), Yt("UpsampleRgba4444LinePair", Ai, 2), Yt("UpsampleRgb565LinePair", vr, 2);
    var jl = kt.UpsampleRgbLinePair, Fc = kt.UpsampleBgrLinePair, ml = kt.UpsampleRgbaLinePair, ac = kt.UpsampleBgraLinePair, Na = kt.UpsampleArgbLinePair, ql = kt.UpsampleRgba4444LinePair, Ul = kt.UpsampleRgb565LinePair, Yo = 16, gl = 1 << Yo - 1, Da = -227, Vl = 482, oc = 6, Ln = (256 << oc) - 1, Xi = 0, _o = P(256), yl = P(256), _l = P(256), lc = P(256), Ko = P(Vl - Da), Jo = P(Vl - Da);
    Mi("YuvToRgbRow", ki, 3), Mi("YuvToBgrRow", Qi, 3), Mi("YuvToRgbaRow", yn, 4), Mi("YuvToBgraRow", Ye, 4), Mi("YuvToArgbRow", Kr, 4), Mi("YuvToRgba4444Row", Ai, 2), Mi("YuvToRgb565Row", vr, 2);
    var hs = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], ua = [0, 2, 8], je = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Qe = 1;
    this.WebPDecodeRGBA = function(p, w, o, t, r) {
      var s = Ca, l = new Bn(), h = new Mr();
      l.ba = h, h.S = s, h.width = [h.width], h.height = [h.height];
      var g = h.width, _ = h.height, A = new Er();
      if (A == null || p == null) var L = 2;
      else f(A != null), L = ra(p, w, o, A.width, A.height, A.Pd, A.Qd, A.format, null);
      if (L != 0 ? g = 0 : (g != null && (g[0] = A.width[0]), _ != null && (_[0] = A.height[0]), g = 1), g) {
        h.width = h.width[0], h.height = h.height[0], t != null && (t[0] = h.width), r != null && (r[0] = h.height);
        t: {
          if (t = new Dn(), (r = new no()).data = p, r.w = w, r.ha = o, r.kd = 1, w = [0], f(r != null), ((p = ra(r.data, r.w, r.ha, null, null, null, w, null, r)) == 0 || p == 7) && w[0] && (p = 4), (w = p) == 0) {
            if (f(l != null), t.data = r.data, t.w = r.w + r.offset, t.ha = r.ha - r.offset, t.put = Pt, t.ac = ct, t.bc = Mt, t.ma = l, r.xa) {
              if ((p = Bi()) == null) {
                l = 1;
                break t;
              }
              if (function(E, M) {
                var R = [0], q = [0], B = [0];
                e: for (; ; ) {
                  if (E == null) return 0;
                  if (M == null) return E.a = 2, 0;
                  if (E.l = M, E.a = 0, jt(E.m, M.data, M.w, M.ha), !At(E.m, R, q, B)) {
                    E.a = 3;
                    break e;
                  }
                  if (E.xb = za, M.width = R[0], M.height = q[0], !li(R[0], q[0], 1, E, null)) break e;
                  return 1;
                }
                return f(E.a != 0), 0;
              }(p, t)) {
                if (t = (w = jr(t.width, t.height, l.Oa, l.ba)) == 0) {
                  e: {
                    t = p;
                    i: for (; ; ) {
                      if (t == null) {
                        t = 0;
                        break e;
                      }
                      if (f(t.s.yc != null), f(t.s.Ya != null), f(0 < t.s.Wb), f((o = t.l) != null), f((r = o.ma) != null), t.xb != 0) {
                        if (t.ca = r.ba, t.tb = r.tb, f(t.ca != null), !rs(r.Oa, o, Ma)) {
                          t.a = 2;
                          break i;
                        }
                        if (!Di(t, o.width) || o.da) break i;
                        if ((o.da || Ee(t.ca.S)) && Ft(), 11 > t.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), t.ca.f.kb.F != null && Ft()), t.Pb && 0 < t.s.ua && t.s.vb.X == null && !ti(t.s.vb, t.s.Wa.Xa)) {
                          t.a = 1;
                          break i;
                        }
                        t.xb = 0;
                      }
                      if (!pi(t, t.V, t.Ba, t.c, t.i, o.o, $e)) break i;
                      r.Dc = t.Ma, t = 1;
                      break e;
                    }
                    f(t.a != 0), t = 0;
                  }
                  t = !t;
                }
                t && (w = p.a);
              } else w = p.a;
            } else {
              if ((p = new fr()) == null) {
                l = 1;
                break t;
              }
              if (p.Fa = r.na, p.P = r.P, p.qc = r.Sa, sr(p, t)) {
                if ((w = jr(t.width, t.height, l.Oa, l.ba)) == 0) {
                  if (p.Aa = 0, o = l.Oa, f((r = p) != null), o != null) {
                    if (0 < (g = 0 > (g = o.Md) ? 0 : 100 < g ? 255 : 255 * g / 100)) {
                      for (_ = A = 0; 4 > _; ++_) 12 > (L = r.pb[_]).lc && (L.ia = g * je[0 > L.lc ? 0 : L.lc] >> 3), A |= L.ia;
                      A && (alert("todo:VP8InitRandom"), r.ia = 1);
                    }
                    r.Ga = o.Id, 100 < r.Ga ? r.Ga = 100 : 0 > r.Ga && (r.Ga = 0);
                  }
                  Fo(p, t) || (w = p.a);
                }
              } else w = p.a;
            }
            w == 0 && l.Oa != null && l.Oa.fd && (w = vs(l.ba));
          }
          l = w;
        }
        s = l != 0 ? null : 11 > s ? h.f.RGBA.eb : h.f.kb.y;
      } else s = null;
      return s;
    };
    var Qo = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function U(kt, $t) {
    for (var ae = "", at = 0; at < 4; at++) ae += String.fromCharCode(kt[$t++]);
    return ae;
  }
  function X(kt, $t) {
    return (kt[$t + 0] << 0 | kt[$t + 1] << 8 | kt[$t + 2] << 16) >>> 0;
  }
  function O(kt, $t) {
    return (kt[$t + 0] << 0 | kt[$t + 1] << 8 | kt[$t + 2] << 16 | kt[$t + 3] << 24) >>> 0;
  }
  new z();
  var j = [0], F = [0], mt = [], ot = new z(), yt = x, st = function(kt, $t) {
    var ae = {}, at = 0, lt = !1, It = 0, St = 0;
    if (ae.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(pt, xt, Tt, Et) {
      for (var Rt = 0; Rt < Et; Rt++) if (pt[xt + Rt] != Tt.charCodeAt(Rt)) return !0;
      return !1;
    }(kt, $t, "RIFF", 4)) {
      var Wt, Xt;
      for (O(kt, $t += 4), $t += 8; $t < kt.length; ) {
        var Ht = U(kt, $t), jt = O(kt, $t += 4);
        $t += 4;
        var ee = jt + (1 & jt);
        switch (Ht) {
          case "VP8 ":
          case "VP8L":
            ae.frames[at] === void 0 && (ae.frames[at] = {}), (K = ae.frames[at]).src_off = lt ? St : $t - 8, K.src_size = It + jt + 8, at++, lt && (lt = !1, It = 0, St = 0);
            break;
          case "VP8X":
            (K = ae.header = {}).feature_flags = kt[$t];
            var ie = $t + 4;
            K.canvas_width = 1 + X(kt, ie), ie += 3, K.canvas_height = 1 + X(kt, ie), ie += 3;
            break;
          case "ALPH":
            lt = !0, It = ee + 8, St = $t - 8;
            break;
          case "ANIM":
            (K = ae.header).bgcolor = O(kt, $t), ie = $t + 4, K.loop_count = (Wt = kt)[(Xt = ie) + 0] << 0 | Wt[Xt + 1] << 8, ie += 2;
            break;
          case "ANMF":
            var Se, K;
            (K = ae.frames[at] = {}).offset_x = 2 * X(kt, $t), $t += 3, K.offset_y = 2 * X(kt, $t), $t += 3, K.width = 1 + X(kt, $t), $t += 3, K.height = 1 + X(kt, $t), $t += 3, K.duration = X(kt, $t), $t += 3, Se = kt[$t++], K.dispose = 1 & Se, K.blend = Se >> 1 & 1;
        }
        Ht != "ANMF" && ($t += ee);
      }
      return ae;
    }
  }(yt, 0);
  st.response = yt, st.rgbaoutput = !0, st.dataurl = !1;
  var gt = st.header ? st.header : null, zt = st.frames ? st.frames : null;
  if (gt) {
    gt.loop_counter = gt.loop_count, j = [gt.canvas_height], F = [gt.canvas_width];
    for (var Jt = 0; Jt < zt.length && zt[Jt].blend != 0; Jt++) ;
  }
  var Kt = zt[0], pe = ot.WebPDecodeRGBA(yt, Kt.src_off, Kt.src_size, F, j);
  Kt.rgba = pe, Kt.imgwidth = F[0], Kt.imgheight = j[0];
  for (var Ot = 0; Ot < F[0] * j[0] * 4; Ot++) mt[Ot] = pe[Ot];
  return this.width = F, this.height = j, this.data = mt, this;
}
(function(x) {
  var f = function() {
    return typeof $u == "function";
  }, y = function(j, F, mt, ot) {
    var yt = 4, st = v;
    switch (ot) {
      case x.image_compression.FAST:
        yt = 1, st = P;
        break;
      case x.image_compression.MEDIUM:
        yt = 6, st = c;
        break;
      case x.image_compression.SLOW:
        yt = 9, st = z;
    }
    j = b(j, F, mt, st);
    var gt = $u(j, { level: yt });
    return x.__addimage__.arrayBufferToBinaryString(gt);
  }, b = function(j, F, mt, ot) {
    for (var yt, st, gt, zt = j.length / F, Jt = new Uint8Array(j.length + zt), Kt = X(), pe = 0; pe < zt; pe += 1) {
      if (gt = pe * F, yt = j.subarray(gt, gt + F), ot) Jt.set(ot(yt, mt, st), gt + pe);
      else {
        for (var Ot, kt = Kt.length, $t = []; Ot < kt; Ot += 1) $t[Ot] = Kt[Ot](yt, mt, st);
        var ae = O($t.concat());
        Jt.set($t[ae], gt + pe);
      }
      st = yt;
    }
    return Jt;
  }, k = function(j) {
    var F = Array.apply([], j);
    return F.unshift(0), F;
  }, P = function(j, F) {
    var mt, ot = [], yt = j.length;
    ot[0] = 1;
    for (var st = 0; st < yt; st += 1) mt = j[st - F] || 0, ot[st + 1] = j[st] - mt + 256 & 255;
    return ot;
  }, v = function(j, F, mt) {
    var ot, yt = [], st = j.length;
    yt[0] = 2;
    for (var gt = 0; gt < st; gt += 1) ot = mt && mt[gt] || 0, yt[gt + 1] = j[gt] - ot + 256 & 255;
    return yt;
  }, c = function(j, F, mt) {
    var ot, yt, st = [], gt = j.length;
    st[0] = 3;
    for (var zt = 0; zt < gt; zt += 1) ot = j[zt - F] || 0, yt = mt && mt[zt] || 0, st[zt + 1] = j[zt] + 256 - (ot + yt >>> 1) & 255;
    return st;
  }, z = function(j, F, mt) {
    var ot, yt, st, gt, zt = [], Jt = j.length;
    zt[0] = 4;
    for (var Kt = 0; Kt < Jt; Kt += 1) ot = j[Kt - F] || 0, yt = mt && mt[Kt] || 0, st = mt && mt[Kt - F] || 0, gt = U(ot, yt, st), zt[Kt + 1] = j[Kt] - gt + 256 & 255;
    return zt;
  }, U = function(j, F, mt) {
    if (j === F && F === mt) return j;
    var ot = Math.abs(F - mt), yt = Math.abs(j - mt), st = Math.abs(j + F - mt - mt);
    return ot <= yt && ot <= st ? j : yt <= st ? F : mt;
  }, X = function() {
    return [k, P, v, c, z];
  }, O = function(j) {
    var F = j.map(function(mt) {
      return mt.reduce(function(ot, yt) {
        return ot + Math.abs(yt);
      }, 0);
    });
    return F.indexOf(Math.min.apply(null, F));
  };
  x.processPNG = function(j, F, mt, ot) {
    var yt, st, gt, zt, Jt, Kt, pe, Ot, kt, $t, ae, at, lt, It, St, Wt = this.decode.FLATE_DECODE, Xt = "";
    if (this.__addimage__.isArrayBuffer(j) && (j = new Uint8Array(j)), this.__addimage__.isArrayBufferView(j)) {
      if (j = (gt = new p0(j)).imgData, st = gt.bits, yt = gt.colorSpace, Jt = gt.colors, [4, 6].indexOf(gt.colorType) !== -1) {
        if (gt.bits === 8) {
          kt = (Ot = gt.pixelBitlength == 32 ? new Uint32Array(gt.decodePixels().buffer) : gt.pixelBitlength == 16 ? new Uint16Array(gt.decodePixels().buffer) : new Uint8Array(gt.decodePixels().buffer)).length, ae = new Uint8Array(kt * gt.colors), $t = new Uint8Array(kt);
          var Ht, jt = gt.pixelBitlength - gt.bits;
          for (It = 0, St = 0; It < kt; It++) {
            for (lt = Ot[It], Ht = 0; Ht < jt; ) ae[St++] = lt >>> Ht & 255, Ht += gt.bits;
            $t[It] = lt >>> Ht & 255;
          }
        }
        if (gt.bits === 16) {
          kt = (Ot = new Uint32Array(gt.decodePixels().buffer)).length, ae = new Uint8Array(kt * (32 / gt.pixelBitlength) * gt.colors), $t = new Uint8Array(kt * (32 / gt.pixelBitlength)), at = gt.colors > 1, It = 0, St = 0;
          for (var ee = 0; It < kt; ) lt = Ot[It++], ae[St++] = lt >>> 0 & 255, at && (ae[St++] = lt >>> 16 & 255, lt = Ot[It++], ae[St++] = lt >>> 0 & 255), $t[ee++] = lt >>> 16 & 255;
          st = 8;
        }
        ot !== x.image_compression.NONE && f() ? (j = y(ae, gt.width * gt.colors, gt.colors, ot), pe = y($t, gt.width, 1, ot)) : (j = ae, pe = $t, Wt = void 0);
      }
      if (gt.colorType === 3 && (yt = this.color_spaces.INDEXED, Kt = gt.palette, gt.transparency.indexed)) {
        var ie = gt.transparency.indexed, Se = 0;
        for (It = 0, kt = ie.length; It < kt; ++It) Se += ie[It];
        if ((Se /= 255) === kt - 1 && ie.indexOf(0) !== -1) zt = [ie.indexOf(0)];
        else if (Se !== kt) {
          for (Ot = gt.decodePixels(), $t = new Uint8Array(Ot.length), It = 0, kt = Ot.length; It < kt; It++) $t[It] = ie[Ot[It]];
          pe = y($t, gt.width, 1);
        }
      }
      var K = function(pt) {
        var xt;
        switch (pt) {
          case x.image_compression.FAST:
            xt = 11;
            break;
          case x.image_compression.MEDIUM:
            xt = 13;
            break;
          case x.image_compression.SLOW:
            xt = 14;
            break;
          default:
            xt = 12;
        }
        return xt;
      }(ot);
      return Wt === this.decode.FLATE_DECODE && (Xt = "/Predictor " + K + " "), Xt += "/Colors " + Jt + " /BitsPerComponent " + st + " /Columns " + gt.width, (this.__addimage__.isArrayBuffer(j) || this.__addimage__.isArrayBufferView(j)) && (j = this.__addimage__.arrayBufferToBinaryString(j)), (pe && this.__addimage__.isArrayBuffer(pe) || this.__addimage__.isArrayBufferView(pe)) && (pe = this.__addimage__.arrayBufferToBinaryString(pe)), { alias: mt, data: j, index: F, filter: Wt, decodeParameters: Xt, transparency: zt, palette: Kt, sMask: pe, predictor: K, width: gt.width, height: gt.height, bitsPerComponent: st, colorSpace: yt };
    }
  };
})(_i.API), function(x) {
  x.processGIF89A = function(f, y, b, k) {
    var P = new f0(f), v = P.width, c = P.height, z = [];
    P.decodeAndBlitFrameRGBA(0, z);
    var U = { data: z, width: v, height: c }, X = new ju(100).encode(U, 100);
    return x.processJPEG.call(this, X, y, b, k);
  }, x.processGIF87A = x.processGIF89A;
}(_i.API), ja.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var x = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(x);
    for (var f = 0; f < x; f++) {
      var y = this.datav.getUint8(this.pos++, !0), b = this.datav.getUint8(this.pos++, !0), k = this.datav.getUint8(this.pos++, !0), P = this.datav.getUint8(this.pos++, !0);
      this.palette[f] = { red: k, green: b, blue: y, quad: P };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, ja.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var x = "bit" + this.bitPP, f = this.width * this.height * 4;
    this.data = new Uint8Array(f), this[x]();
  } catch (y) {
    dr.log("bit decode error:" + y);
  }
}, ja.prototype.bit1 = function() {
  var x, f = Math.ceil(this.width / 8), y = f % 4;
  for (x = this.height - 1; x >= 0; x--) {
    for (var b = this.bottom_up ? x : this.height - 1 - x, k = 0; k < f; k++) for (var P = this.datav.getUint8(this.pos++, !0), v = b * this.width * 4 + 8 * k * 4, c = 0; c < 8 && 8 * k + c < this.width; c++) {
      var z = this.palette[P >> 7 - c & 1];
      this.data[v + 4 * c] = z.blue, this.data[v + 4 * c + 1] = z.green, this.data[v + 4 * c + 2] = z.red, this.data[v + 4 * c + 3] = 255;
    }
    y !== 0 && (this.pos += 4 - y);
  }
}, ja.prototype.bit4 = function() {
  for (var x = Math.ceil(this.width / 2), f = x % 4, y = this.height - 1; y >= 0; y--) {
    for (var b = this.bottom_up ? y : this.height - 1 - y, k = 0; k < x; k++) {
      var P = this.datav.getUint8(this.pos++, !0), v = b * this.width * 4 + 2 * k * 4, c = P >> 4, z = 15 & P, U = this.palette[c];
      if (this.data[v] = U.blue, this.data[v + 1] = U.green, this.data[v + 2] = U.red, this.data[v + 3] = 255, 2 * k + 1 >= this.width) break;
      U = this.palette[z], this.data[v + 4] = U.blue, this.data[v + 4 + 1] = U.green, this.data[v + 4 + 2] = U.red, this.data[v + 4 + 3] = 255;
    }
    f !== 0 && (this.pos += 4 - f);
  }
}, ja.prototype.bit8 = function() {
  for (var x = this.width % 4, f = this.height - 1; f >= 0; f--) {
    for (var y = this.bottom_up ? f : this.height - 1 - f, b = 0; b < this.width; b++) {
      var k = this.datav.getUint8(this.pos++, !0), P = y * this.width * 4 + 4 * b;
      if (k < this.palette.length) {
        var v = this.palette[k];
        this.data[P] = v.red, this.data[P + 1] = v.green, this.data[P + 2] = v.blue, this.data[P + 3] = 255;
      } else this.data[P] = 255, this.data[P + 1] = 255, this.data[P + 2] = 255, this.data[P + 3] = 255;
    }
    x !== 0 && (this.pos += 4 - x);
  }
}, ja.prototype.bit15 = function() {
  for (var x = this.width % 3, f = parseInt("11111", 2), y = this.height - 1; y >= 0; y--) {
    for (var b = this.bottom_up ? y : this.height - 1 - y, k = 0; k < this.width; k++) {
      var P = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var v = (P & f) / f * 255 | 0, c = (P >> 5 & f) / f * 255 | 0, z = (P >> 10 & f) / f * 255 | 0, U = P >> 15 ? 255 : 0, X = b * this.width * 4 + 4 * k;
      this.data[X] = z, this.data[X + 1] = c, this.data[X + 2] = v, this.data[X + 3] = U;
    }
    this.pos += x;
  }
}, ja.prototype.bit16 = function() {
  for (var x = this.width % 3, f = parseInt("11111", 2), y = parseInt("111111", 2), b = this.height - 1; b >= 0; b--) {
    for (var k = this.bottom_up ? b : this.height - 1 - b, P = 0; P < this.width; P++) {
      var v = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var c = (v & f) / f * 255 | 0, z = (v >> 5 & y) / y * 255 | 0, U = (v >> 11) / f * 255 | 0, X = k * this.width * 4 + 4 * P;
      this.data[X] = U, this.data[X + 1] = z, this.data[X + 2] = c, this.data[X + 3] = 255;
    }
    this.pos += x;
  }
}, ja.prototype.bit24 = function() {
  for (var x = this.height - 1; x >= 0; x--) {
    for (var f = this.bottom_up ? x : this.height - 1 - x, y = 0; y < this.width; y++) {
      var b = this.datav.getUint8(this.pos++, !0), k = this.datav.getUint8(this.pos++, !0), P = this.datav.getUint8(this.pos++, !0), v = f * this.width * 4 + 4 * y;
      this.data[v] = P, this.data[v + 1] = k, this.data[v + 2] = b, this.data[v + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, ja.prototype.bit32 = function() {
  for (var x = this.height - 1; x >= 0; x--) for (var f = this.bottom_up ? x : this.height - 1 - x, y = 0; y < this.width; y++) {
    var b = this.datav.getUint8(this.pos++, !0), k = this.datav.getUint8(this.pos++, !0), P = this.datav.getUint8(this.pos++, !0), v = this.datav.getUint8(this.pos++, !0), c = f * this.width * 4 + 4 * y;
    this.data[c] = P, this.data[c + 1] = k, this.data[c + 2] = b, this.data[c + 3] = v;
  }
}, ja.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  x.processBMP = function(f, y, b, k) {
    var P = new ja(f, !1), v = P.width, c = P.height, z = { data: P.getData(), width: v, height: c }, U = new ju(100).encode(z, 100);
    return x.processJPEG.call(this, U, y, b, k);
  };
}(_i.API), Hp.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  x.processWEBP = function(f, y, b, k) {
    var P = new Hp(f), v = P.width, c = P.height, z = { data: P.getData(), width: v, height: c }, U = new ju(100).encode(z, 100);
    return x.processJPEG.call(this, U, y, b, k);
  };
}(_i.API), _i.API.processRGBA = function(x, f, y) {
  for (var b = x.data, k = b.length, P = new Uint8Array(k / 4 * 3), v = new Uint8Array(k / 4), c = 0, z = 0, U = 0; U < k; U += 4) {
    var X = b[U], O = b[U + 1], j = b[U + 2], F = b[U + 3];
    P[c++] = X, P[c++] = O, P[c++] = j, v[z++] = F;
  }
  var mt = this.__addimage__.arrayBufferToBinaryString(P);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(v), data: mt, index: f, alias: y, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: x.width, height: x.height };
}, _i.API.setLanguage = function(x) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[x] !== void 0 && (this.internal.languageSettings.languageCode = x, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, kc = _i.API, Bh = kc.getCharWidthsArray = function(x, f) {
  var y, b, k = (f = f || {}).font || this.internal.getFont(), P = f.fontSize || this.internal.getFontSize(), v = f.charSpace || this.internal.getCharSpace(), c = f.widths ? f.widths : k.metadata.Unicode.widths, z = c.fof ? c.fof : 1, U = f.kerning ? f.kerning : k.metadata.Unicode.kerning, X = U.fof ? U.fof : 1, O = f.doKerning !== !1, j = 0, F = x.length, mt = 0, ot = c[0] || z, yt = [];
  for (y = 0; y < F; y++) b = x.charCodeAt(y), typeof k.metadata.widthOfString == "function" ? yt.push((k.metadata.widthOfGlyph(k.metadata.characterToGlyph(b)) + v * (1e3 / P) || 0) / 1e3) : (j = O && nr(U[b]) === "object" && !isNaN(parseInt(U[b][mt], 10)) ? U[b][mt] / X : 0, yt.push((c[b] || ot) / z + j)), mt = b;
  return yt;
}, $p = kc.getStringUnitWidth = function(x, f) {
  var y = (f = f || {}).fontSize || this.internal.getFontSize(), b = f.font || this.internal.getFont(), k = f.charSpace || this.internal.getCharSpace();
  return kc.processArabic && (x = kc.processArabic(x)), typeof b.metadata.widthOfString == "function" ? b.metadata.widthOfString(x, y, k) / y : Bh.apply(this, arguments).reduce(function(P, v) {
    return P + v;
  }, 0);
}, Zp = function(x, f, y, b) {
  for (var k = [], P = 0, v = x.length, c = 0; P !== v && c + f[P] < y; ) c += f[P], P++;
  k.push(x.slice(0, P));
  var z = P;
  for (c = 0; P !== v; ) c + f[P] > b && (k.push(x.slice(z, P)), c = 0, z = P), c += f[P], P++;
  return z !== P && k.push(x.slice(z, P)), k;
}, Wp = function(x, f, y) {
  y || (y = {});
  var b, k, P, v, c, z, U, X = [], O = [X], j = y.textIndent || 0, F = 0, mt = 0, ot = x.split(" "), yt = Bh.apply(this, [" ", y])[0];
  if (z = y.lineIndent === -1 ? ot[0].length + 2 : y.lineIndent || 0) {
    var st = Array(z).join(" "), gt = [];
    ot.map(function(Jt) {
      (Jt = Jt.split(/\s*\n/)).length > 1 ? gt = gt.concat(Jt.map(function(Kt, pe) {
        return (pe && Kt.length ? `
` : "") + Kt;
      })) : gt.push(Jt[0]);
    }), ot = gt, z = $p.apply(this, [st, y]);
  }
  for (P = 0, v = ot.length; P < v; P++) {
    var zt = 0;
    if (b = ot[P], z && b[0] == `
` && (b = b.substr(1), zt = 1), j + F + (mt = (k = Bh.apply(this, [b, y])).reduce(function(Jt, Kt) {
      return Jt + Kt;
    }, 0)) > f || zt) {
      if (mt > f) {
        for (c = Zp.apply(this, [b, k, f - (j + F), f]), X.push(c.shift()), X = [c.pop()]; c.length; ) O.push([c.shift()]);
        mt = k.slice(b.length - (X[0] ? X[0].length : 0)).reduce(function(Jt, Kt) {
          return Jt + Kt;
        }, 0);
      } else X = [b];
      O.push(X), j = mt + z, F = yt;
    } else X.push(b), j += F + mt, F = yt;
  }
  return U = z ? function(Jt, Kt) {
    return (Kt ? st : "") + Jt.join(" ");
  } : function(Jt) {
    return Jt.join(" ");
  }, O.map(U);
}, kc.splitTextToSize = function(x, f, y) {
  var b, k = (y = y || {}).fontSize || this.internal.getFontSize(), P = (function(X) {
    if (X.widths && X.kerning) return { widths: X.widths, kerning: X.kerning };
    var O = this.internal.getFont(X.fontName, X.fontStyle);
    return O.metadata.Unicode ? { widths: O.metadata.Unicode.widths || { 0: 1 }, kerning: O.metadata.Unicode.kerning || {} } : { font: O.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, y);
  b = Array.isArray(x) ? x : String(x).split(/\r?\n/);
  var v = 1 * this.internal.scaleFactor * f / k;
  P.textIndent = y.textIndent ? 1 * y.textIndent * this.internal.scaleFactor / k : 0, P.lineIndent = y.lineIndent;
  var c, z, U = [];
  for (c = 0, z = b.length; c < z; c++) U = U.concat(Wp.apply(this, [b[c], v, P]));
  return U;
}, function(x) {
  x.__fontmetrics__ = x.__fontmetrics__ || {};
  for (var f = "klmnopqrstuvwxyz", y = {}, b = {}, k = 0; k < f.length; k++) y[f[k]] = "0123456789abcdef"[k], b["0123456789abcdef"[k]] = f[k];
  var P = function(O) {
    return "0x" + parseInt(O, 10).toString(16);
  }, v = x.__fontmetrics__.compress = function(O) {
    var j, F, mt, ot, yt = ["{"];
    for (var st in O) {
      if (j = O[st], isNaN(parseInt(st, 10)) ? F = "'" + st + "'" : (st = parseInt(st, 10), F = (F = P(st).slice(2)).slice(0, -1) + b[F.slice(-1)]), typeof j == "number") j < 0 ? (mt = P(j).slice(3), ot = "-") : (mt = P(j).slice(2), ot = ""), mt = ot + mt.slice(0, -1) + b[mt.slice(-1)];
      else {
        if (nr(j) !== "object") throw new Error("Don't know what to do with value type " + nr(j) + ".");
        mt = v(j);
      }
      yt.push(F + mt);
    }
    return yt.push("}"), yt.join("");
  }, c = x.__fontmetrics__.uncompress = function(O) {
    if (typeof O != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var j, F, mt, ot, yt = {}, st = 1, gt = yt, zt = [], Jt = "", Kt = "", pe = O.length - 1, Ot = 1; Ot < pe; Ot += 1) (ot = O[Ot]) == "'" ? j ? (mt = j.join(""), j = void 0) : j = [] : j ? j.push(ot) : ot == "{" ? (zt.push([gt, mt]), gt = {}, mt = void 0) : ot == "}" ? ((F = zt.pop())[0][F[1]] = gt, mt = void 0, gt = F[0]) : ot == "-" ? st = -1 : mt === void 0 ? y.hasOwnProperty(ot) ? (Jt += y[ot], mt = parseInt(Jt, 16) * st, st = 1, Jt = "") : Jt += ot : y.hasOwnProperty(ot) ? (Kt += y[ot], gt[mt] = parseInt(Kt, 16) * st, st = 1, mt = void 0, Kt = "") : Kt += ot;
    return yt;
  }, z = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, U = { Unicode: { Courier: z, "Courier-Bold": z, "Courier-BoldOblique": z, "Courier-Oblique": z, Helvetica: z, "Helvetica-Bold": z, "Helvetica-BoldOblique": z, "Helvetica-Oblique": z, "Times-Roman": z, "Times-Bold": z, "Times-BoldItalic": z, "Times-Italic": z } }, X = { Unicode: { "Courier-Oblique": c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  x.events.push(["addFont", function(O) {
    var j = O.font, F = X.Unicode[j.postScriptName];
    F && (j.metadata.Unicode = {}, j.metadata.Unicode.widths = F.widths, j.metadata.Unicode.kerning = F.kerning);
    var mt = U.Unicode[j.postScriptName];
    mt && (j.metadata.Unicode.encoding = mt, j.encoding = mt.codePages[0]);
  }]);
}(_i.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var f = function(y) {
    for (var b = y.length, k = new Uint8Array(b), P = 0; P < b; P++) k[P] = y.charCodeAt(P);
    return k;
  };
  x.API.events.push(["addFont", function(y) {
    var b = void 0, k = y.font, P = y.instance;
    if (!k.isStandardFont) {
      if (P === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + k.postScriptName + "').");
      if (typeof (b = P.existsFileInVFS(k.postScriptName) === !1 ? P.loadFile(k.postScriptName) : P.getFileFromVFS(k.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + k.postScriptName + "').");
      (function(v, c) {
        c = /^\x00\x01\x00\x00/.test(c) ? f(c) : f(ch(c)), v.metadata = x.API.TTFFont.open(c), v.metadata.Unicode = v.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, v.metadata.glyIdsUsed = [0];
      })(k, b);
    }
  }]);
}(_i), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(x) {
  function f() {
    return (vi.canvg ? Promise.resolve(vi.canvg) : import("./index.es-oS9LRiBp-C_Ba31ye.js")).catch(function(y) {
      return Promise.reject(new Error("Could not load canvg: " + y));
    }).then(function(y) {
      return y.default ? y.default : y;
    });
  }
  _i.API.addSvgAsImage = function(y, b, k, P, v, c, z, U) {
    if (isNaN(b) || isNaN(k)) throw dr.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(P) || isNaN(v)) throw dr.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var X = document.createElement("canvas");
    X.width = P, X.height = v;
    var O = X.getContext("2d");
    O.fillStyle = "#fff", O.fillRect(0, 0, X.width, X.height);
    var j = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, F = this;
    return f().then(function(mt) {
      return mt.fromString(O, y, j);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(mt) {
      return mt.render(j);
    }).then(function() {
      F.addImage(X.toDataURL("image/jpeg", 1), b, k, P, v, z, U);
    });
  };
}(), _i.API.putTotalPages = function(x) {
  var f, y = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (f = new RegExp(x, "g"), y = this.internal.getNumberOfPages()) : (f = new RegExp(this.pdfEscape16(x, this.internal.getFont()), "g"), y = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var b = 1; b <= this.internal.getNumberOfPages(); b++) for (var k = 0; k < this.internal.pages[b].length; k++) this.internal.pages[b][k] = this.internal.pages[b][k].replace(f, y);
  return this;
}, _i.API.viewerPreferences = function(x, f) {
  var y;
  x = x || {}, f = f || !1;
  var b, k, P, v = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, c = Object.keys(v), z = [], U = 0, X = 0, O = 0;
  function j(mt, ot) {
    var yt, st = !1;
    for (yt = 0; yt < mt.length; yt += 1) mt[yt] === ot && (st = !0);
    return st;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(v)), this.internal.viewerpreferences.isSubscribed = !1), y = this.internal.viewerpreferences.configuration, x === "reset" || f === !0) {
    var F = c.length;
    for (O = 0; O < F; O += 1) y[c[O]].value = y[c[O]].defaultValue, y[c[O]].explicitSet = !1;
  }
  if (nr(x) === "object") {
    for (k in x) if (P = x[k], j(c, k) && P !== void 0) {
      if (y[k].type === "boolean" && typeof P == "boolean") y[k].value = P;
      else if (y[k].type === "name" && j(y[k].valueSet, P)) y[k].value = P;
      else if (y[k].type === "integer" && Number.isInteger(P)) y[k].value = P;
      else if (y[k].type === "array") {
        for (U = 0; U < P.length; U += 1) if (b = !0, P[U].length === 1 && typeof P[U][0] == "number") z.push(String(P[U] - 1));
        else if (P[U].length > 1) {
          for (X = 0; X < P[U].length; X += 1) typeof P[U][X] != "number" && (b = !1);
          b === !0 && z.push([P[U][0] - 1, P[U][1] - 1].join(" "));
        }
        y[k].value = "[" + z.join(" ") + "]";
      } else y[k].value = y[k].defaultValue;
      y[k].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var mt, ot = [];
    for (mt in y) y[mt].explicitSet === !0 && (y[mt].type === "name" ? ot.push("/" + mt + " /" + y[mt].value) : ot.push("/" + mt + " " + y[mt].value));
    ot.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + ot.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = y, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(x) {
  var f = function() {
    var b = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', k = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), P = unescape(encodeURIComponent(b)), v = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), c = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), z = unescape(encodeURIComponent("</x:xmpmeta>")), U = P.length + v.length + c.length + k.length + z.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + U + " >>"), this.internal.write("stream"), this.internal.write(k + P + v + c + z), this.internal.write("endstream"), this.internal.write("endobj");
  }, y = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  x.addMetadata = function(b, k) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: b, namespaceuri: k || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", y), this.internal.events.subscribe("postPutResources", f)), this;
  };
}(_i.API), function(x) {
  var f = x.API, y = f.pdfEscape16 = function(P, v) {
    for (var c, z = v.metadata.Unicode.widths, U = ["", "0", "00", "000", "0000"], X = [""], O = 0, j = P.length; O < j; ++O) {
      if (c = v.metadata.characterToGlyph(P.charCodeAt(O)), v.metadata.glyIdsUsed.push(c), v.metadata.toUnicode[c] = P.charCodeAt(O), z.indexOf(c) == -1 && (z.push(c), z.push([parseInt(v.metadata.widthOfGlyph(c), 10)])), c == "0") return X.join("");
      c = c.toString(16), X.push(U[4 - c.length], c);
    }
    return X.join("");
  }, b = function(P) {
    var v, c, z, U, X, O, j;
    for (X = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, z = [], O = 0, j = (c = Object.keys(P).sort(function(F, mt) {
      return F - mt;
    })).length; O < j; O++) v = c[O], z.length >= 100 && (X += `
` + z.length + ` beginbfchar
` + z.join(`
`) + `
endbfchar`, z = []), P[v] !== void 0 && P[v] !== null && typeof P[v].toString == "function" && (U = ("0000" + P[v].toString(16)).slice(-4), v = ("0000" + (+v).toString(16)).slice(-4), z.push("<" + v + "><" + U + ">"));
    return z.length && (X += `
` + z.length + ` beginbfchar
` + z.join(`
`) + `
endbfchar
`), X += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  f.events.push(["putFont", function(P) {
    (function(v) {
      var c = v.font, z = v.out, U = v.newObject, X = v.putStream;
      if (c.metadata instanceof x.API.TTFFont && c.encoding === "Identity-H") {
        for (var O = c.metadata.Unicode.widths, j = c.metadata.subset.encode(c.metadata.glyIdsUsed, 1), F = "", mt = 0; mt < j.length; mt++) F += String.fromCharCode(j[mt]);
        var ot = U();
        X({ data: F, addLength1: !0, objectId: ot }), z("endobj");
        var yt = U();
        X({ data: b(c.metadata.toUnicode), addLength1: !0, objectId: yt }), z("endobj");
        var st = U();
        z("<<"), z("/Type /FontDescriptor"), z("/FontName /" + Lc(c.fontName)), z("/FontFile2 " + ot + " 0 R"), z("/FontBBox " + x.API.PDFObject.convert(c.metadata.bbox)), z("/Flags " + c.metadata.flags), z("/StemV " + c.metadata.stemV), z("/ItalicAngle " + c.metadata.italicAngle), z("/Ascent " + c.metadata.ascender), z("/Descent " + c.metadata.decender), z("/CapHeight " + c.metadata.capHeight), z(">>"), z("endobj");
        var gt = U();
        z("<<"), z("/Type /Font"), z("/BaseFont /" + Lc(c.fontName)), z("/FontDescriptor " + st + " 0 R"), z("/W " + x.API.PDFObject.convert(O)), z("/CIDToGIDMap /Identity"), z("/DW 1000"), z("/Subtype /CIDFontType2"), z("/CIDSystemInfo"), z("<<"), z("/Supplement 0"), z("/Registry (Adobe)"), z("/Ordering (" + c.encoding + ")"), z(">>"), z(">>"), z("endobj"), c.objectNumber = U(), z("<<"), z("/Type /Font"), z("/Subtype /Type0"), z("/ToUnicode " + yt + " 0 R"), z("/BaseFont /" + Lc(c.fontName)), z("/Encoding /" + c.encoding), z("/DescendantFonts [" + gt + " 0 R]"), z(">>"), z("endobj"), c.isAlreadyPutted = !0;
      }
    })(P);
  }]), f.events.push(["putFont", function(P) {
    (function(v) {
      var c = v.font, z = v.out, U = v.newObject, X = v.putStream;
      if (c.metadata instanceof x.API.TTFFont && c.encoding === "WinAnsiEncoding") {
        for (var O = c.metadata.rawData, j = "", F = 0; F < O.length; F++) j += String.fromCharCode(O[F]);
        var mt = U();
        X({ data: j, addLength1: !0, objectId: mt }), z("endobj");
        var ot = U();
        X({ data: b(c.metadata.toUnicode), addLength1: !0, objectId: ot }), z("endobj");
        var yt = U();
        z("<<"), z("/Descent " + c.metadata.decender), z("/CapHeight " + c.metadata.capHeight), z("/StemV " + c.metadata.stemV), z("/Type /FontDescriptor"), z("/FontFile2 " + mt + " 0 R"), z("/Flags 96"), z("/FontBBox " + x.API.PDFObject.convert(c.metadata.bbox)), z("/FontName /" + Lc(c.fontName)), z("/ItalicAngle " + c.metadata.italicAngle), z("/Ascent " + c.metadata.ascender), z(">>"), z("endobj"), c.objectNumber = U();
        for (var st = 0; st < c.metadata.hmtx.widths.length; st++) c.metadata.hmtx.widths[st] = parseInt(c.metadata.hmtx.widths[st] * (1e3 / c.metadata.head.unitsPerEm));
        z("<</Subtype/TrueType/Type/Font/ToUnicode " + ot + " 0 R/BaseFont/" + Lc(c.fontName) + "/FontDescriptor " + yt + " 0 R/Encoding/" + c.encoding + " /FirstChar 29 /LastChar 255 /Widths " + x.API.PDFObject.convert(c.metadata.hmtx.widths) + ">>"), z("endobj"), c.isAlreadyPutted = !0;
      }
    })(P);
  }]);
  var k = function(P) {
    var v, c = P.text || "", z = P.x, U = P.y, X = P.options || {}, O = P.mutex || {}, j = O.pdfEscape, F = O.activeFontKey, mt = O.fonts, ot = F, yt = "", st = 0, gt = "", zt = mt[ot].encoding;
    if (mt[ot].encoding !== "Identity-H") return { text: c, x: z, y: U, options: X, mutex: O };
    for (gt = c, ot = F, Array.isArray(c) && (gt = c[0]), st = 0; st < gt.length; st += 1) mt[ot].metadata.hasOwnProperty("cmap") && (v = mt[ot].metadata.cmap.unicode.codeMap[gt[st].charCodeAt(0)]), v || gt[st].charCodeAt(0) < 256 && mt[ot].metadata.hasOwnProperty("Unicode") ? yt += gt[st] : yt += "";
    var Jt = "";
    return parseInt(ot.slice(1)) < 14 || zt === "WinAnsiEncoding" ? Jt = j(yt, ot).split("").map(function(Kt) {
      return Kt.charCodeAt(0).toString(16);
    }).join("") : zt === "Identity-H" && (Jt = y(yt, mt[ot])), O.isHex = !0, { text: Jt, x: z, y: U, options: X, mutex: O };
  };
  f.events.push(["postProcessText", function(P) {
    var v = P.text || "", c = [], z = { text: v, x: P.x, y: P.y, options: P.options, mutex: P.mutex };
    if (Array.isArray(v)) {
      var U = 0;
      for (U = 0; U < v.length; U += 1) Array.isArray(v[U]) && v[U].length === 3 ? c.push([k(Object.assign({}, z, { text: v[U][0] })).text, v[U][1], v[U][2]]) : c.push(k(Object.assign({}, z, { text: v[U] })).text);
      P.text = c;
    } else P.text = k(Object.assign({}, z, { text: v })).text;
  }]);
}(_i), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(x) {
  var f = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  x.existsFileInVFS = function(y) {
    return f.call(this), this.internal.vFS[y] !== void 0;
  }, x.addFileToVFS = function(y, b) {
    return f.call(this), this.internal.vFS[y] = b, this;
  }, x.getFileFromVFS = function(y) {
    return f.call(this), this.internal.vFS[y] !== void 0 ? this.internal.vFS[y] : null;
  };
}(_i.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(x) {
  x.__bidiEngine__ = x.prototype.__bidiEngine__ = function(b) {
    var k, P, v, c, z, U, X, O = f, j = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], F = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], mt = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, ot = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, yt = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], st = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), gt = !1, zt = 0;
    this.__bidiEngine__ = {};
    var Jt = function(at) {
      var lt = at.charCodeAt(), It = lt >> 8, St = ot[It];
      return St !== void 0 ? O[256 * St + (255 & lt)] : It === 252 || It === 253 ? "AL" : st.test(It) ? "L" : It === 8 ? "R" : "N";
    }, Kt = function(at) {
      for (var lt, It = 0; It < at.length; It++) {
        if ((lt = Jt(at.charAt(It))) === "L") return !1;
        if (lt === "R") return !0;
      }
      return !1;
    }, pe = function(at, lt, It, St) {
      var Wt, Xt, Ht, jt, ee = lt[St];
      switch (ee) {
        case "L":
        case "R":
          gt = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          gt && (ee = "AN");
          break;
        case "AL":
          gt = !0, ee = "R";
          break;
        case "WS":
          ee = "N";
          break;
        case "CS":
          St < 1 || St + 1 >= lt.length || (Wt = It[St - 1]) !== "EN" && Wt !== "AN" || (Xt = lt[St + 1]) !== "EN" && Xt !== "AN" ? ee = "N" : gt && (Xt = "AN"), ee = Xt === Wt ? Xt : "N";
          break;
        case "ES":
          ee = (Wt = St > 0 ? It[St - 1] : "B") === "EN" && St + 1 < lt.length && lt[St + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (St > 0 && It[St - 1] === "EN") {
            ee = "EN";
            break;
          }
          if (gt) {
            ee = "N";
            break;
          }
          for (Ht = St + 1, jt = lt.length; Ht < jt && lt[Ht] === "ET"; ) Ht++;
          ee = Ht < jt && lt[Ht] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (v && !c) {
            for (jt = lt.length, Ht = St + 1; Ht < jt && lt[Ht] === "NSM"; ) Ht++;
            if (Ht < jt) {
              var ie = at[St], Se = ie >= 1425 && ie <= 2303 || ie === 64286;
              if (Wt = lt[Ht], Se && (Wt === "R" || Wt === "AL")) {
                ee = "R";
                break;
              }
            }
          }
          ee = St < 1 || (Wt = lt[St - 1]) === "B" ? "N" : It[St - 1];
          break;
        case "B":
          gt = !1, k = !0, ee = zt;
          break;
        case "S":
          P = !0, ee = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          gt = !1;
          break;
        case "BN":
          ee = "N";
      }
      return ee;
    }, Ot = function(at, lt, It) {
      var St = at.split("");
      return It && kt(St, It, { hiLevel: zt }), St.reverse(), lt && lt.reverse(), St.join("");
    }, kt = function(at, lt, It) {
      var St, Wt, Xt, Ht, jt, ee = -1, ie = at.length, Se = 0, K = [], pt = zt ? F : j, xt = [];
      for (gt = !1, k = !1, P = !1, Wt = 0; Wt < ie; Wt++) xt[Wt] = Jt(at[Wt]);
      for (Xt = 0; Xt < ie; Xt++) {
        if (jt = Se, K[Xt] = pe(at, xt, K, Xt), St = 240 & (Se = pt[jt][mt[K[Xt]]]), Se &= 15, lt[Xt] = Ht = pt[Se][5], St > 0) if (St === 16) {
          for (Wt = ee; Wt < Xt; Wt++) lt[Wt] = 1;
          ee = -1;
        } else ee = -1;
        if (pt[Se][6]) ee === -1 && (ee = Xt);
        else if (ee > -1) {
          for (Wt = ee; Wt < Xt; Wt++) lt[Wt] = Ht;
          ee = -1;
        }
        xt[Xt] === "B" && (lt[Xt] = 0), It.hiLevel |= Ht;
      }
      P && function(Tt, Et, Rt) {
        for (var qt = 0; qt < Rt; qt++) if (Tt[qt] === "S") {
          Et[qt] = zt;
          for (var Gt = qt - 1; Gt >= 0 && Tt[Gt] === "WS"; Gt--) Et[Gt] = zt;
        }
      }(xt, lt, ie);
    }, $t = function(at, lt, It, St, Wt) {
      if (!(Wt.hiLevel < at)) {
        if (at === 1 && zt === 1 && !k) return lt.reverse(), void (It && It.reverse());
        for (var Xt, Ht, jt, ee, ie = lt.length, Se = 0; Se < ie; ) {
          if (St[Se] >= at) {
            for (jt = Se + 1; jt < ie && St[jt] >= at; ) jt++;
            for (ee = Se, Ht = jt - 1; ee < Ht; ee++, Ht--) Xt = lt[ee], lt[ee] = lt[Ht], lt[Ht] = Xt, It && (Xt = It[ee], It[ee] = It[Ht], It[Ht] = Xt);
            Se = jt;
          }
          Se++;
        }
      }
    }, ae = function(at, lt, It) {
      var St = at.split(""), Wt = { hiLevel: zt };
      return It || (It = []), kt(St, It, Wt), function(Xt, Ht, jt) {
        if (jt.hiLevel !== 0 && X) for (var ee, ie = 0; ie < Xt.length; ie++) Ht[ie] === 1 && (ee = yt.indexOf(Xt[ie])) >= 0 && (Xt[ie] = yt[ee + 1]);
      }(St, It, Wt), $t(2, St, lt, It, Wt), $t(1, St, lt, It, Wt), St.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(at, lt, It) {
      if (function(Wt, Xt) {
        if (Xt) for (var Ht = 0; Ht < Wt.length; Ht++) Xt[Ht] = Ht;
        c === void 0 && (c = Kt(Wt)), U === void 0 && (U = Kt(Wt));
      }(at, lt), v || !z || U) if (v && z && c ^ U) zt = c ? 1 : 0, at = Ot(at, lt, It);
      else if (!v && z && U) zt = c ? 1 : 0, at = ae(at, lt, It), at = Ot(at, lt);
      else if (!v || c || z || U) {
        if (v && !z && c ^ U) at = Ot(at, lt), c ? (zt = 0, at = ae(at, lt, It)) : (zt = 1, at = ae(at, lt, It), at = Ot(at, lt));
        else if (v && c && !z && U) zt = 1, at = ae(at, lt, It), at = Ot(at, lt);
        else if (!v && !z && c ^ U) {
          var St = X;
          c ? (zt = 1, at = ae(at, lt, It), zt = 0, X = !1, at = ae(at, lt, It), X = St) : (zt = 0, at = ae(at, lt, It), at = Ot(at, lt), zt = 1, X = !1, at = ae(at, lt, It), X = St, at = Ot(at, lt));
        }
      } else zt = 0, at = ae(at, lt, It);
      else zt = c ? 1 : 0, at = ae(at, lt, It);
      return at;
    }, this.__bidiEngine__.setOptions = function(at) {
      at && (v = at.isInputVisual, z = at.isOutputVisual, c = at.isInputRtl, U = at.isOutputRtl, X = at.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(b), this.__bidiEngine__;
  };
  var f = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], y = new x.__bidiEngine__({ isInputVisual: !0 });
  x.API.events.push(["postProcessText", function(b) {
    var k = b.text, P = (b.x, b.y, b.options || {}), v = (b.mutex, P.lang, []);
    if (P.isInputVisual = typeof P.isInputVisual != "boolean" || P.isInputVisual, y.setOptions(P), Object.prototype.toString.call(k) === "[object Array]") {
      var c = 0;
      for (v = [], c = 0; c < k.length; c += 1) Object.prototype.toString.call(k[c]) === "[object Array]" ? v.push([y.doBidiReorder(k[c][0]), k[c][1], k[c][2]]) : v.push([y.doBidiReorder(k[c])]);
      b.text = v;
    } else b.text = y.doBidiReorder(k);
    y.setOptions({ isInputVisual: !0 });
  }]);
}(_i), _i.API.TTFFont = function() {
  function x(f) {
    var y;
    if (this.rawData = f, y = this.contents = new Ml(f), this.contents.pos = 4, y.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    y.pos = 0, this.parse(), this.subset = new L0(this), this.registerTTF();
  }
  return x.open = function(f) {
    return new x(f);
  }, x.prototype.parse = function() {
    return this.directory = new m0(this.contents), this.head = new y0(this), this.name = new w0(this), this.cmap = new xf(this), this.toUnicode = {}, this.hhea = new _0(this), this.maxp = new S0(this), this.hmtx = new A0(this), this.post = new x0(this), this.os2 = new v0(this), this.loca = new T0(this), this.glyf = new P0(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, x.prototype.registerTTF = function() {
    var f, y, b, k, P;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var v, c, z, U;
      for (U = [], v = 0, c = (z = this.bbox).length; v < c; v++) f = z[v], U.push(Math.round(f * this.scaleFactor));
      return U;
    }).call(this), this.stemV = 0, this.post.exists ? (b = 255 & (k = this.post.italic_angle), 32768 & (y = k >> 16) && (y = -(1 + (65535 ^ y))), this.italicAngle = +(y + "." + b)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (P = this.familyClass) === 1 || P === 2 || P === 3 || P === 4 || P === 5 || P === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, x.prototype.characterToGlyph = function(f) {
    var y;
    return ((y = this.cmap.unicode) != null ? y.codeMap[f] : void 0) || 0;
  }, x.prototype.widthOfGlyph = function(f) {
    var y;
    return y = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(f).advance * y;
  }, x.prototype.widthOfString = function(f, y, b) {
    var k, P, v, c;
    for (v = 0, P = 0, c = (f = "" + f).length; 0 <= c ? P < c : P > c; P = 0 <= c ? ++P : --P) k = f.charCodeAt(P), v += this.widthOfGlyph(this.characterToGlyph(k)) + b * (1e3 / y) || 0;
    return v * (y / 1e3);
  }, x.prototype.lineHeight = function(f, y) {
    var b;
    return y == null && (y = !1), b = y ? this.lineGap : 0, (this.ascender + b - this.decender) / 1e3 * f;
  }, x;
}();
var Va, Ml = function() {
  function x(f) {
    this.data = f ?? [], this.pos = 0, this.length = this.data.length;
  }
  return x.prototype.readByte = function() {
    return this.data[this.pos++];
  }, x.prototype.writeByte = function(f) {
    return this.data[this.pos++] = f;
  }, x.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, x.prototype.writeUInt32 = function(f) {
    return this.writeByte(f >>> 24 & 255), this.writeByte(f >> 16 & 255), this.writeByte(f >> 8 & 255), this.writeByte(255 & f);
  }, x.prototype.readInt32 = function() {
    var f;
    return (f = this.readUInt32()) >= 2147483648 ? f - 4294967296 : f;
  }, x.prototype.writeInt32 = function(f) {
    return f < 0 && (f += 4294967296), this.writeUInt32(f);
  }, x.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, x.prototype.writeUInt16 = function(f) {
    return this.writeByte(f >> 8 & 255), this.writeByte(255 & f);
  }, x.prototype.readInt16 = function() {
    var f;
    return (f = this.readUInt16()) >= 32768 ? f - 65536 : f;
  }, x.prototype.writeInt16 = function(f) {
    return f < 0 && (f += 65536), this.writeUInt16(f);
  }, x.prototype.readString = function(f) {
    var y, b;
    for (b = [], y = 0; 0 <= f ? y < f : y > f; y = 0 <= f ? ++y : --y) b[y] = String.fromCharCode(this.readByte());
    return b.join("");
  }, x.prototype.writeString = function(f) {
    var y, b, k;
    for (k = [], y = 0, b = f.length; 0 <= b ? y < b : y > b; y = 0 <= b ? ++y : --y) k.push(this.writeByte(f.charCodeAt(y)));
    return k;
  }, x.prototype.readShort = function() {
    return this.readInt16();
  }, x.prototype.writeShort = function(f) {
    return this.writeInt16(f);
  }, x.prototype.readLongLong = function() {
    var f, y, b, k, P, v, c, z;
    return f = this.readByte(), y = this.readByte(), b = this.readByte(), k = this.readByte(), P = this.readByte(), v = this.readByte(), c = this.readByte(), z = this.readByte(), 128 & f ? -1 * (72057594037927940 * (255 ^ f) + 281474976710656 * (255 ^ y) + 1099511627776 * (255 ^ b) + 4294967296 * (255 ^ k) + 16777216 * (255 ^ P) + 65536 * (255 ^ v) + 256 * (255 ^ c) + (255 ^ z) + 1) : 72057594037927940 * f + 281474976710656 * y + 1099511627776 * b + 4294967296 * k + 16777216 * P + 65536 * v + 256 * c + z;
  }, x.prototype.writeLongLong = function(f) {
    var y, b;
    return y = Math.floor(f / 4294967296), b = 4294967295 & f, this.writeByte(y >> 24 & 255), this.writeByte(y >> 16 & 255), this.writeByte(y >> 8 & 255), this.writeByte(255 & y), this.writeByte(b >> 24 & 255), this.writeByte(b >> 16 & 255), this.writeByte(b >> 8 & 255), this.writeByte(255 & b);
  }, x.prototype.readInt = function() {
    return this.readInt32();
  }, x.prototype.writeInt = function(f) {
    return this.writeInt32(f);
  }, x.prototype.read = function(f) {
    var y, b;
    for (y = [], b = 0; 0 <= f ? b < f : b > f; b = 0 <= f ? ++b : --b) y.push(this.readByte());
    return y;
  }, x.prototype.write = function(f) {
    var y, b, k, P;
    for (P = [], b = 0, k = f.length; b < k; b++) y = f[b], P.push(this.writeByte(y));
    return P;
  }, x;
}(), m0 = function() {
  var x;
  function f(y) {
    var b, k, P;
    for (this.scalarType = y.readInt(), this.tableCount = y.readShort(), this.searchRange = y.readShort(), this.entrySelector = y.readShort(), this.rangeShift = y.readShort(), this.tables = {}, k = 0, P = this.tableCount; 0 <= P ? k < P : k > P; k = 0 <= P ? ++k : --k) b = { tag: y.readString(4), checksum: y.readInt(), offset: y.readInt(), length: y.readInt() }, this.tables[b.tag] = b;
  }
  return f.prototype.encode = function(y) {
    var b, k, P, v, c, z, U, X, O, j, F, mt, ot;
    for (ot in F = Object.keys(y).length, z = Math.log(2), O = 16 * Math.floor(Math.log(F) / z), v = Math.floor(O / z), X = 16 * F - O, (k = new Ml()).writeInt(this.scalarType), k.writeShort(F), k.writeShort(O), k.writeShort(v), k.writeShort(X), P = 16 * F, U = k.pos + P, c = null, mt = [], y) for (j = y[ot], k.writeString(ot), k.writeInt(x(j)), k.writeInt(U), k.writeInt(j.length), mt = mt.concat(j), ot === "head" && (c = U), U += j.length; U % 4; ) mt.push(0), U++;
    return k.write(mt), b = 2981146554 - x(k.data), k.pos = c + 8, k.writeUInt32(b), k.data;
  }, x = function(y) {
    var b, k, P, v;
    for (y = bf.call(y); y.length % 4; ) y.push(0);
    for (P = new Ml(y), k = 0, b = 0, v = y.length; b < v; b = b += 4) k += P.readUInt32();
    return 4294967295 & k;
  }, f;
}(), g0 = {}.hasOwnProperty, zo = function(x, f) {
  for (var y in f) g0.call(f, y) && (x[y] = f[y]);
  function b() {
    this.constructor = x;
  }
  return b.prototype = f.prototype, x.prototype = new b(), x.__super__ = f.prototype, x;
};
Va = function() {
  function x(f) {
    var y;
    this.file = f, y = this.file.directory.tables[this.tag], this.exists = !!y, y && (this.offset = y.offset, this.length = y.length, this.parse(this.file.contents));
  }
  return x.prototype.parse = function() {
  }, x.prototype.encode = function() {
  }, x.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, x;
}();
var y0 = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "head", f.prototype.parse = function(y) {
    return y.pos = this.offset, this.version = y.readInt(), this.revision = y.readInt(), this.checkSumAdjustment = y.readInt(), this.magicNumber = y.readInt(), this.flags = y.readShort(), this.unitsPerEm = y.readShort(), this.created = y.readLongLong(), this.modified = y.readLongLong(), this.xMin = y.readShort(), this.yMin = y.readShort(), this.xMax = y.readShort(), this.yMax = y.readShort(), this.macStyle = y.readShort(), this.lowestRecPPEM = y.readShort(), this.fontDirectionHint = y.readShort(), this.indexToLocFormat = y.readShort(), this.glyphDataFormat = y.readShort();
  }, f.prototype.encode = function(y) {
    var b;
    return (b = new Ml()).writeInt(this.version), b.writeInt(this.revision), b.writeInt(this.checkSumAdjustment), b.writeInt(this.magicNumber), b.writeShort(this.flags), b.writeShort(this.unitsPerEm), b.writeLongLong(this.created), b.writeLongLong(this.modified), b.writeShort(this.xMin), b.writeShort(this.yMin), b.writeShort(this.xMax), b.writeShort(this.yMax), b.writeShort(this.macStyle), b.writeShort(this.lowestRecPPEM), b.writeShort(this.fontDirectionHint), b.writeShort(y), b.writeShort(this.glyphDataFormat), b.data;
  }, f;
}(), Yp = function() {
  function x(f, y) {
    var b, k, P, v, c, z, U, X, O, j, F, mt, ot, yt, st, gt, zt;
    switch (this.platformID = f.readUInt16(), this.encodingID = f.readShort(), this.offset = y + f.readInt(), O = f.pos, f.pos = this.offset, this.format = f.readUInt16(), this.length = f.readUInt16(), this.language = f.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (z = 0; z < 256; ++z) this.codeMap[z] = f.readByte();
        break;
      case 4:
        for (F = f.readUInt16(), j = F / 2, f.pos += 6, P = function() {
          var Jt, Kt;
          for (Kt = [], z = Jt = 0; 0 <= j ? Jt < j : Jt > j; z = 0 <= j ? ++Jt : --Jt) Kt.push(f.readUInt16());
          return Kt;
        }(), f.pos += 2, ot = function() {
          var Jt, Kt;
          for (Kt = [], z = Jt = 0; 0 <= j ? Jt < j : Jt > j; z = 0 <= j ? ++Jt : --Jt) Kt.push(f.readUInt16());
          return Kt;
        }(), U = function() {
          var Jt, Kt;
          for (Kt = [], z = Jt = 0; 0 <= j ? Jt < j : Jt > j; z = 0 <= j ? ++Jt : --Jt) Kt.push(f.readUInt16());
          return Kt;
        }(), X = function() {
          var Jt, Kt;
          for (Kt = [], z = Jt = 0; 0 <= j ? Jt < j : Jt > j; z = 0 <= j ? ++Jt : --Jt) Kt.push(f.readUInt16());
          return Kt;
        }(), k = (this.length - f.pos + this.offset) / 2, c = function() {
          var Jt, Kt;
          for (Kt = [], z = Jt = 0; 0 <= k ? Jt < k : Jt > k; z = 0 <= k ? ++Jt : --Jt) Kt.push(f.readUInt16());
          return Kt;
        }(), z = st = 0, zt = P.length; st < zt; z = ++st) for (yt = P[z], b = gt = mt = ot[z]; mt <= yt ? gt <= yt : gt >= yt; b = mt <= yt ? ++gt : --gt) X[z] === 0 ? v = b + U[z] : (v = c[X[z] / 2 + (b - mt) - (j - z)] || 0) !== 0 && (v += U[z]), this.codeMap[b] = 65535 & v;
    }
    f.pos = O;
  }
  return x.encode = function(f, y) {
    var b, k, P, v, c, z, U, X, O, j, F, mt, ot, yt, st, gt, zt, Jt, Kt, pe, Ot, kt, $t, ae, at, lt, It, St, Wt, Xt, Ht, jt, ee, ie, Se, K, pt, xt, Tt, Et, Rt, qt, Gt, we, be, Ie;
    switch (St = new Ml(), v = Object.keys(f).sort(function(Pe, ti) {
      return Pe - ti;
    }), y) {
      case "macroman":
        for (ot = 0, yt = function() {
          var Pe = [];
          for (mt = 0; mt < 256; ++mt) Pe.push(0);
          return Pe;
        }(), gt = { 0: 0 }, P = {}, Wt = 0, ee = v.length; Wt < ee; Wt++) gt[Gt = f[k = v[Wt]]] == null && (gt[Gt] = ++ot), P[k] = { old: f[k], new: gt[f[k]] }, yt[k] = gt[f[k]];
        return St.writeUInt16(1), St.writeUInt16(0), St.writeUInt32(12), St.writeUInt16(0), St.writeUInt16(262), St.writeUInt16(0), St.write(yt), { charMap: P, subtable: St.data, maxGlyphID: ot + 1 };
      case "unicode":
        for (lt = [], O = [], zt = 0, gt = {}, b = {}, st = U = null, Xt = 0, ie = v.length; Xt < ie; Xt++) gt[Kt = f[k = v[Xt]]] == null && (gt[Kt] = ++zt), b[k] = { old: Kt, new: gt[Kt] }, c = gt[Kt] - k, st != null && c === U || (st && O.push(st), lt.push(k), U = c), st = k;
        for (st && O.push(st), O.push(65535), lt.push(65535), ae = 2 * ($t = lt.length), kt = 2 * Math.pow(Math.log($t) / Math.LN2, 2), j = Math.log(kt / 2) / Math.LN2, Ot = 2 * $t - kt, z = [], pe = [], F = [], mt = Ht = 0, Se = lt.length; Ht < Se; mt = ++Ht) {
          if (at = lt[mt], X = O[mt], at === 65535) {
            z.push(0), pe.push(0);
            break;
          }
          if (at - (It = b[at].new) >= 32768) for (z.push(0), pe.push(2 * (F.length + $t - mt)), k = jt = at; at <= X ? jt <= X : jt >= X; k = at <= X ? ++jt : --jt) F.push(b[k].new);
          else z.push(It - at), pe.push(0);
        }
        for (St.writeUInt16(3), St.writeUInt16(1), St.writeUInt32(12), St.writeUInt16(4), St.writeUInt16(16 + 8 * $t + 2 * F.length), St.writeUInt16(0), St.writeUInt16(ae), St.writeUInt16(kt), St.writeUInt16(j), St.writeUInt16(Ot), Rt = 0, K = O.length; Rt < K; Rt++) k = O[Rt], St.writeUInt16(k);
        for (St.writeUInt16(0), qt = 0, pt = lt.length; qt < pt; qt++) k = lt[qt], St.writeUInt16(k);
        for (we = 0, xt = z.length; we < xt; we++) c = z[we], St.writeUInt16(c);
        for (be = 0, Tt = pe.length; be < Tt; be++) Jt = pe[be], St.writeUInt16(Jt);
        for (Ie = 0, Et = F.length; Ie < Et; Ie++) ot = F[Ie], St.writeUInt16(ot);
        return { charMap: b, subtable: St.data, maxGlyphID: zt + 1 };
    }
  }, x;
}(), xf = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "cmap", f.prototype.parse = function(y) {
    var b, k, P;
    for (y.pos = this.offset, this.version = y.readUInt16(), P = y.readUInt16(), this.tables = [], this.unicode = null, k = 0; 0 <= P ? k < P : k > P; k = 0 <= P ? ++k : --k) b = new Yp(y, this.offset), this.tables.push(b), b.isUnicode && this.unicode == null && (this.unicode = b);
    return !0;
  }, f.encode = function(y, b) {
    var k, P;
    return b == null && (b = "macroman"), k = Yp.encode(y, b), (P = new Ml()).writeUInt16(0), P.writeUInt16(1), k.table = P.data.concat(k.subtable), k;
  }, f;
}(), _0 = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "hhea", f.prototype.parse = function(y) {
    return y.pos = this.offset, this.version = y.readInt(), this.ascender = y.readShort(), this.decender = y.readShort(), this.lineGap = y.readShort(), this.advanceWidthMax = y.readShort(), this.minLeftSideBearing = y.readShort(), this.minRightSideBearing = y.readShort(), this.xMaxExtent = y.readShort(), this.caretSlopeRise = y.readShort(), this.caretSlopeRun = y.readShort(), this.caretOffset = y.readShort(), y.pos += 8, this.metricDataFormat = y.readShort(), this.numberOfMetrics = y.readUInt16();
  }, f;
}(), v0 = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "OS/2", f.prototype.parse = function(y) {
    if (y.pos = this.offset, this.version = y.readUInt16(), this.averageCharWidth = y.readShort(), this.weightClass = y.readUInt16(), this.widthClass = y.readUInt16(), this.type = y.readShort(), this.ySubscriptXSize = y.readShort(), this.ySubscriptYSize = y.readShort(), this.ySubscriptXOffset = y.readShort(), this.ySubscriptYOffset = y.readShort(), this.ySuperscriptXSize = y.readShort(), this.ySuperscriptYSize = y.readShort(), this.ySuperscriptXOffset = y.readShort(), this.ySuperscriptYOffset = y.readShort(), this.yStrikeoutSize = y.readShort(), this.yStrikeoutPosition = y.readShort(), this.familyClass = y.readShort(), this.panose = function() {
      var b, k;
      for (k = [], b = 0; b < 10; ++b) k.push(y.readByte());
      return k;
    }(), this.charRange = function() {
      var b, k;
      for (k = [], b = 0; b < 4; ++b) k.push(y.readInt());
      return k;
    }(), this.vendorID = y.readString(4), this.selection = y.readShort(), this.firstCharIndex = y.readShort(), this.lastCharIndex = y.readShort(), this.version > 0 && (this.ascent = y.readShort(), this.descent = y.readShort(), this.lineGap = y.readShort(), this.winAscent = y.readShort(), this.winDescent = y.readShort(), this.codePageRange = function() {
      var b, k;
      for (k = [], b = 0; b < 2; b = ++b) k.push(y.readInt());
      return k;
    }(), this.version > 1)) return this.xHeight = y.readShort(), this.capHeight = y.readShort(), this.defaultChar = y.readShort(), this.breakChar = y.readShort(), this.maxContext = y.readShort();
  }, f;
}(), x0 = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "post", f.prototype.parse = function(y) {
    var b, k, P;
    switch (y.pos = this.offset, this.format = y.readInt(), this.italicAngle = y.readInt(), this.underlinePosition = y.readShort(), this.underlineThickness = y.readShort(), this.isFixedPitch = y.readInt(), this.minMemType42 = y.readInt(), this.maxMemType42 = y.readInt(), this.minMemType1 = y.readInt(), this.maxMemType1 = y.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var v;
        for (k = y.readUInt16(), this.glyphNameIndex = [], v = 0; 0 <= k ? v < k : v > k; v = 0 <= k ? ++v : --v) this.glyphNameIndex.push(y.readUInt16());
        for (this.names = [], P = []; y.pos < this.offset + this.length; ) b = y.readByte(), P.push(this.names.push(y.readString(b)));
        return P;
      case 151552:
        return k = y.readUInt16(), this.offsets = y.read(k);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var c, z, U;
          for (U = [], v = c = 0, z = this.file.maxp.numGlyphs; 0 <= z ? c < z : c > z; v = 0 <= z ? ++c : --c) U.push(y.readUInt32());
          return U;
        }).call(this);
    }
  }, f;
}(), b0 = function(x, f) {
  this.raw = x, this.length = x.length, this.platformID = f.platformID, this.encodingID = f.encodingID, this.languageID = f.languageID;
}, w0 = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "name", f.prototype.parse = function(y) {
    var b, k, P, v, c, z, U, X, O, j, F;
    for (y.pos = this.offset, y.readShort(), b = y.readShort(), z = y.readShort(), k = [], v = 0; 0 <= b ? v < b : v > b; v = 0 <= b ? ++v : --v) k.push({ platformID: y.readShort(), encodingID: y.readShort(), languageID: y.readShort(), nameID: y.readShort(), length: y.readShort(), offset: this.offset + z + y.readShort() });
    for (U = {}, v = O = 0, j = k.length; O < j; v = ++O) P = k[v], y.pos = P.offset, X = y.readString(P.length), c = new b0(X, P), U[F = P.nameID] == null && (U[F] = []), U[P.nameID].push(c);
    this.strings = U, this.copyright = U[0], this.fontFamily = U[1], this.fontSubfamily = U[2], this.uniqueSubfamily = U[3], this.fontName = U[4], this.version = U[5];
    try {
      this.postscriptName = U[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = U[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = U[7], this.manufacturer = U[8], this.designer = U[9], this.description = U[10], this.vendorUrl = U[11], this.designerUrl = U[12], this.license = U[13], this.licenseUrl = U[14], this.preferredFamily = U[15], this.preferredSubfamily = U[17], this.compatibleFull = U[18], this.sampleText = U[19];
  }, f;
}(), S0 = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "maxp", f.prototype.parse = function(y) {
    return y.pos = this.offset, this.version = y.readInt(), this.numGlyphs = y.readUInt16(), this.maxPoints = y.readUInt16(), this.maxContours = y.readUInt16(), this.maxCompositePoints = y.readUInt16(), this.maxComponentContours = y.readUInt16(), this.maxZones = y.readUInt16(), this.maxTwilightPoints = y.readUInt16(), this.maxStorage = y.readUInt16(), this.maxFunctionDefs = y.readUInt16(), this.maxInstructionDefs = y.readUInt16(), this.maxStackElements = y.readUInt16(), this.maxSizeOfInstructions = y.readUInt16(), this.maxComponentElements = y.readUInt16(), this.maxComponentDepth = y.readUInt16();
  }, f;
}(), A0 = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "hmtx", f.prototype.parse = function(y) {
    var b, k, P, v, c, z, U;
    for (y.pos = this.offset, this.metrics = [], b = 0, z = this.file.hhea.numberOfMetrics; 0 <= z ? b < z : b > z; b = 0 <= z ? ++b : --b) this.metrics.push({ advance: y.readUInt16(), lsb: y.readInt16() });
    for (P = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var X, O;
      for (O = [], b = X = 0; 0 <= P ? X < P : X > P; b = 0 <= P ? ++X : --X) O.push(y.readInt16());
      return O;
    }(), this.widths = (function() {
      var X, O, j, F;
      for (F = [], X = 0, O = (j = this.metrics).length; X < O; X++) v = j[X], F.push(v.advance);
      return F;
    }).call(this), k = this.widths[this.widths.length - 1], U = [], b = c = 0; 0 <= P ? c < P : c > P; b = 0 <= P ? ++c : --c) U.push(this.widths.push(k));
    return U;
  }, f.prototype.forGlyph = function(y) {
    return y in this.metrics ? this.metrics[y] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[y - this.metrics.length] };
  }, f;
}(), bf = [].slice, P0 = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "glyf", f.prototype.parse = function() {
    return this.cache = {};
  }, f.prototype.glyphFor = function(y) {
    var b, k, P, v, c, z, U, X, O, j;
    return y in this.cache ? this.cache[y] : (v = this.file.loca, b = this.file.contents, k = v.indexOf(y), (P = v.lengthOf(y)) === 0 ? this.cache[y] = null : (b.pos = this.offset + k, c = (z = new Ml(b.read(P))).readShort(), X = z.readShort(), j = z.readShort(), U = z.readShort(), O = z.readShort(), this.cache[y] = c === -1 ? new k0(z, X, j, U, O) : new I0(z, c, X, j, U, O), this.cache[y]));
  }, f.prototype.encode = function(y, b, k) {
    var P, v, c, z, U;
    for (c = [], v = [], z = 0, U = b.length; z < U; z++) P = y[b[z]], v.push(c.length), P && (c = c.concat(P.encode(k)));
    return v.push(c.length), { table: c, offsets: v };
  }, f;
}(), I0 = function() {
  function x(f, y, b, k, P, v) {
    this.raw = f, this.numberOfContours = y, this.xMin = b, this.yMin = k, this.xMax = P, this.yMax = v, this.compound = !1;
  }
  return x.prototype.encode = function() {
    return this.raw.data;
  }, x;
}(), k0 = function() {
  function x(f, y, b, k, P) {
    var v, c;
    for (this.raw = f, this.xMin = y, this.yMin = b, this.xMax = k, this.yMax = P, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], v = this.raw; c = v.readShort(), this.glyphOffsets.push(v.pos), this.glyphIDs.push(v.readUInt16()), 32 & c; ) v.pos += 1 & c ? 4 : 2, 128 & c ? v.pos += 8 : 64 & c ? v.pos += 4 : 8 & c && (v.pos += 2);
  }
  return x.prototype.encode = function() {
    var f, y, b;
    for (y = new Ml(bf.call(this.raw.data)), f = 0, b = this.glyphIDs.length; f < b; ++f) y.pos = this.glyphOffsets[f];
    return y.data;
  }, x;
}(), T0 = function(x) {
  function f() {
    return f.__super__.constructor.apply(this, arguments);
  }
  return zo(f, Va), f.prototype.tag = "loca", f.prototype.parse = function(y) {
    var b, k;
    return y.pos = this.offset, b = this.file.head.indexToLocFormat, this.offsets = b === 0 ? (function() {
      var P, v;
      for (v = [], k = 0, P = this.length; k < P; k += 2) v.push(2 * y.readUInt16());
      return v;
    }).call(this) : (function() {
      var P, v;
      for (v = [], k = 0, P = this.length; k < P; k += 4) v.push(y.readUInt32());
      return v;
    }).call(this);
  }, f.prototype.indexOf = function(y) {
    return this.offsets[y];
  }, f.prototype.lengthOf = function(y) {
    return this.offsets[y + 1] - this.offsets[y];
  }, f.prototype.encode = function(y, b) {
    for (var k = new Uint32Array(this.offsets.length), P = 0, v = 0, c = 0; c < k.length; ++c) if (k[c] = P, v < b.length && b[v] == c) {
      ++v, k[c] = P;
      var z = this.offsets[c], U = this.offsets[c + 1] - z;
      U > 0 && (P += U);
    }
    for (var X = new Array(4 * k.length), O = 0; O < k.length; ++O) X[4 * O + 3] = 255 & k[O], X[4 * O + 2] = (65280 & k[O]) >> 8, X[4 * O + 1] = (16711680 & k[O]) >> 16, X[4 * O] = (4278190080 & k[O]) >> 24;
    return X;
  }, f;
}(), L0 = function() {
  function x(f) {
    this.font = f, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return x.prototype.generateCmap = function() {
    var f, y, b, k, P;
    for (y in k = this.font.cmap.tables[0].codeMap, f = {}, P = this.subset) b = P[y], f[y] = k[b];
    return f;
  }, x.prototype.glyphsFor = function(f) {
    var y, b, k, P, v, c, z;
    for (k = {}, v = 0, c = f.length; v < c; v++) k[P = f[v]] = this.font.glyf.glyphFor(P);
    for (P in y = [], k) (b = k[P]) != null && b.compound && y.push.apply(y, b.glyphIDs);
    if (y.length > 0) for (P in z = this.glyphsFor(y)) b = z[P], k[P] = b;
    return k;
  }, x.prototype.encode = function(f, y) {
    var b, k, P, v, c, z, U, X, O, j, F, mt, ot, yt, st;
    for (k in b = xf.encode(this.generateCmap(), "unicode"), v = this.glyphsFor(f), F = { 0: 0 }, st = b.charMap) F[(z = st[k]).old] = z.new;
    for (mt in j = b.maxGlyphID, v) mt in F || (F[mt] = j++);
    return X = function(gt) {
      var zt, Jt;
      for (zt in Jt = {}, gt) Jt[gt[zt]] = zt;
      return Jt;
    }(F), O = Object.keys(X).sort(function(gt, zt) {
      return gt - zt;
    }), ot = function() {
      var gt, zt, Jt;
      for (Jt = [], gt = 0, zt = O.length; gt < zt; gt++) c = O[gt], Jt.push(X[c]);
      return Jt;
    }(), P = this.font.glyf.encode(v, ot, F), U = this.font.loca.encode(P.offsets, ot), yt = { cmap: this.font.cmap.raw(), glyf: P.table, loca: U, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(y) }, this.font.os2.exists && (yt["OS/2"] = this.font.os2.raw()), this.font.directory.encode(yt);
  }, x;
}();
_i.API.PDFObject = function() {
  var x;
  function f() {
  }
  return x = function(y, b) {
    return (Array(b + 1).join("0") + y).slice(-b);
  }, f.convert = function(y) {
    var b, k, P, v;
    if (Array.isArray(y)) return "[" + function() {
      var c, z, U;
      for (U = [], c = 0, z = y.length; c < z; c++) b = y[c], U.push(f.convert(b));
      return U;
    }().join(" ") + "]";
    if (typeof y == "string") return "/" + y;
    if (y != null && y.isString) return "(" + y + ")";
    if (y instanceof Date) return "(D:" + x(y.getUTCFullYear(), 4) + x(y.getUTCMonth(), 2) + x(y.getUTCDate(), 2) + x(y.getUTCHours(), 2) + x(y.getUTCMinutes(), 2) + x(y.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(y) === "[object Object]") {
      for (k in P = ["<<"], y) v = y[k], P.push("/" + k + " " + f.convert(v));
      return P.push(">>"), P.join(`
`);
    }
    return "" + y;
  }, f;
}();
const Wh = {
  "circle-radius": 8,
  "circle-color": "red",
  "circle-stroke-width": 1,
  "circle-stroke-color": "black"
}, dh = {
  style: {
    textSize: 16,
    textHaloColor: "#FFFFFF",
    textHaloWidth: 0.8,
    textColor: "#000000",
    fallbackTextFont: ["Open Sans Regular"]
  },
  visibility: "visible",
  position: "bottom-right"
}, ph = {
  image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>',
  imageName: "gl-export-north-icon",
  imageSizeFraction: 0.05,
  visibility: "visible",
  position: "top-right"
};
class wf {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. default is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(f, y = tc.A4, b = 300, k = hh.PNG, P = ic.mm, v = "map", c = "maplibregl-marker", z = Wh, U = "maplibregl-ctrl-attrib-inner", X = dh, O = ph) {
    Wi(this, "map"), Wi(this, "width"), Wi(this, "height"), Wi(this, "dpi"), Wi(this, "format"), Wi(this, "unit"), Wi(this, "fileName"), Wi(this, "markerClassName"), Wi(this, "markerCirclePaint"), Wi(this, "attributionClassName"), Wi(this, "attributionOptions"), Wi(this, "northIconOptions"), this.map = f, this.width = y[0], this.height = y[1], this.dpi = b, this.format = k, this.unit = P, this.fileName = v, this.markerClassName = c, this.markerCirclePaint = z, this.attributionClassName = U, this.attributionOptions = X, this.northIconOptions = O;
  }
  renderMapPost(f) {
    return f;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(f) {
    const y = this.getMarkers();
    for (let b = 0; b < y.length; b++) {
      const k = y.item(b);
      if (!k) continue;
      const P = k.getAttribute("style");
      if (!P) continue;
      const v = /translate\(([^,]+)px,\s*([^,]+)px\)/, c = P.match(v);
      if (!c) continue;
      const z = parseInt(c[1]), U = parseInt(c[2]), X = this.map.unproject([z, U]), O = `point${b}`;
      f.addSource(O, {
        type: "geojson",
        data: {
          type: "Point",
          coordinates: [X.lng, X.lat]
        }
      }), f.addLayer({
        id: O,
        source: O,
        type: "circle",
        paint: this.markerCirclePaint
      });
    }
    return f;
  }
  /**
   * Generate and download Map image
   */
  generate() {
    const f = this;
    this.addLoader(), this.showLoader();
    const y = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return f.dpi / 96;
      }
    });
    const b = document.createElement("div");
    b.className = "hidden-map", document.body.appendChild(b);
    const k = document.createElement("div");
    k.style.width = this.toPixels(this.width), k.style.height = this.toPixels(this.height), b.appendChild(k);
    const P = this.map.getStyle();
    if (P && P.sources) {
      const c = P.sources;
      Object.keys(c).forEach((z) => {
        const U = c[z];
        Object.keys(U).forEach((X) => {
          U[X] || delete U[X];
        });
      });
    }
    let v = this.getRenderedMap(k, P);
    v.on("load", () => {
      this.addNorthIconToMap(v).then(() => {
        v.once("idle", () => {
          this.addAttributions(v) ? v.once("idle", () => {
            v = this.renderMapPost(v), this.getMarkers().length === 0 ? this.exportImage(v, b, y) : (v = this.renderMarkers(v), v.once("idle", () => {
              this.exportImage(v, b, y);
            }));
          }) : (v = this.renderMapPost(v), this.getMarkers().length === 0 ? this.exportImage(v, b, y) : (v = this.renderMarkers(v), v.once("idle", () => {
            this.exportImage(v, b, y);
          })));
        });
      });
    });
  }
  stripHtml(f) {
    const y = document.createElement("div");
    return y.innerHTML = f, y.textContent || y.innerText || "";
  }
  /**
   * Get icon width against exported map size by using fraction rate
   * @param renderMap Map object
   * @param fraction adjust icon size by using this fraction rate. Default is 8%
   * @returns Icon width calculated
   */
  getIconWidth(f, y) {
    const b = f.getContainer(), k = parseInt(b.style.width.replace("px", ""));
    return parseInt(`${k * y}`);
  }
  /**
   * Get element position's pixel values based on selected position setting
   * @param renderMap Map object
   * @param position Position of element inserted
   * @param offset Offset value to adjust position
   * @returns Pixels [width, height]
   */
  getElementPosition(f, y, b = 0) {
    const k = f.getContainer();
    let P = 0, v = 0;
    switch (y) {
      case "top-left":
        P = 0 + b, v = 0 + b;
        break;
      case "top-right":
        P = parseInt(k.style.width.replace("px", "")) - b, v = 0 + b;
        break;
      case "bottom-left":
        P = 0 + b, v = parseInt(k.style.height.replace("px", "")) - b;
        break;
      case "bottom-right":
        P = parseInt(k.style.width.replace("px", "")) - b, v = parseInt(k.style.height.replace("px", "")) - b;
        break;
    }
    return [P, v];
  }
  /**
   * Add North Icon SVG to map object
   * @param renderMap Map object
   * @returns void
   */
  addNorthIconImage(f) {
    const y = this.getIconWidth(f, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((b) => {
      const k = new Image(y, y);
      k.onload = () => {
        this.northIconOptions.imageName && f.addImage(this.northIconOptions.imageName, k), b();
      };
      function P(v) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(v);
      }
      this.northIconOptions.image && (k.src = P(this.northIconOptions.image));
    });
  }
  /**
   * Add North Icon Symbol layer to renderMap object
   * @param renderMap Map object
   * @returns
   */
  addNorthIconToMap(f) {
    let y = this.northIconOptions.visibility ?? "visible";
    return f.getZoom() < 2 && this.width > this.height && (y = "none"), new Promise((b) => {
      this.addNorthIconImage(f).then(() => {
        const k = this.getIconWidth(
          f,
          this.northIconOptions.imageSizeFraction ?? 0.08
        ) * 0.8, P = this.getElementPosition(
          f,
          this.northIconOptions.position ?? "top-right",
          k
        ), v = f.unproject(P), c = this.northIconOptions.imageName ?? "gl-export-north-icon";
        f.addSource(c, {
          type: "geojson",
          data: {
            type: "Feature",
            geometry: {
              type: "Point",
              coordinates: [v.lng, v.lat]
            },
            properties: {}
          }
        }), f.addLayer({
          id: c,
          source: c,
          type: "symbol",
          layout: {
            "icon-image": c,
            "icon-size": 1,
            "icon-rotate": f.getBearing() * -1,
            "icon-allow-overlap": !0,
            "icon-ignore-placement": !0,
            visibility: y
          },
          paint: {}
        }), b();
      });
    });
  }
  addAttributions(f) {
    var y;
    if (!this.map.getStyle().glyphs) return !1;
    const b = f.getContainer(), k = this.attributionOptions.position ?? "bottom-right", P = this.getElementPosition(f, k, 5), v = P[0], c = f.unproject(P), z = b.getElementsByClassName(this.attributionClassName), U = [];
    if ((z == null ? void 0 : z.length) > 0) {
      const yt = z.item(0);
      if (yt)
        for (let st = 0; st < yt.children.length; st++) {
          const gt = yt.children.item(st);
          gt && U.push(this.stripHtml(gt.outerHTML));
        }
    } else {
      const yt = this.map.getStyle().sources;
      Object.keys(yt).forEach((st) => {
        const gt = yt[st];
        if ("attribution" in gt) {
          const zt = gt.attribution;
          U.push(this.stripHtml(zt));
        }
      });
    }
    if (U.length === 0) return !1;
    const X = U.join(" | "), O = "attribution";
    f.addSource(O, {
      type: "geojson",
      data: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [c.lng, c.lat]
        },
        properties: {
          attribution: X
        }
      }
    });
    const j = this.map.getStyle().layers.filter(
      (yt) => yt.type === "symbol" && yt.layout && "text-font" in yt.layout
    ), F = j.length > 0 && j[0].layout ? j[0].layout["text-font"] : (y = this.attributionOptions.style) == null ? void 0 : y.fallbackTextFont;
    let mt = this.attributionOptions.visibility ?? "visible";
    f.getZoom() < 2 && this.width > this.height && (mt = "none");
    const ot = this.attributionOptions.style;
    return f.addLayer({
      id: O,
      source: O,
      type: "symbol",
      layout: {
        "text-field": ["get", "attribution"],
        "text-font": F,
        "text-max-width": parseInt(`${v / ot.textSize}`),
        "text-anchor": k,
        "text-justify": ["top-right", "bottom-right"].includes(k) ? "right" : "left",
        "text-size": ot.textSize,
        "text-allow-overlap": !0,
        visibility: mt
      },
      paint: {
        "text-halo-color": ot.textHaloColor,
        "text-halo-width": ot.textHaloWidth,
        "text-color": ot.textColor
      }
    }), !0;
  }
  exportImage(f, y, b) {
    var k;
    const P = f.getCanvas(), v = `${this.fileName}.pdf`;
    window.sessionStorage.getItem("generateLegend") == "true" ? this.toPNG(P, v) : this.toPDF(f, v), f.remove(), (k = y.parentNode) == null || k.removeChild(y), Object.defineProperty(window, "devicePixelRatio", {
      get() {
        return b;
      }
    }), y.remove(), this.hideLoader();
  }
  /**
   * Convert canvas to PNG
   * @param canvas Canvas element
   * @param fileName file name
   */
  toPNG(f, y) {
    const b = document.getElementById("MapImage");
    b && (b.src = f.toDataURL());
    const k = document.getElementById("ExportButton");
    k && k.click(), console.log("Map exported");
  }
  /**
   * Convert canvas to JPEG
   * @param canvas Canvas element
   * @param fileName file name
   */
  /*
  private toJPEG(canvas: HTMLCanvasElement, fileName: string) {
  	const uri = canvas.toDataURL('image/jpeg', 0.85);
  	const a = document.createElement('a');
  	a.href = uri;
  	a.download = fileName;
  	a.click();
  	a.remove();
  }
  */
  /**
   * Convert Map object to PDF
   * @param map Map object
   * @param fileName file name
   */
  toPDF(f, y) {
    const b = f.getCanvas(), k = new _i({
      orientation: this.width > this.height ? "l" : "p",
      unit: this.unit,
      compress: !0,
      format: [this.width, this.height]
    });
    k.addImage(
      b.toDataURL("image/png"),
      "png",
      0,
      0,
      this.width,
      this.height,
      void 0,
      "FAST"
    );
    const { lng: P, lat: v } = f.getCenter();
    k.setProperties({
      title: f.getStyle().name,
      subject: `center: [${P}, ${v}], zoom: ${f.getZoom()}`,
      creator: "Mapbox GL Export Plugin",
      author: "(c)Mapbox, (c)OpenStreetMap"
    }), k.save(y);
  }
  /**
   * Convert canvas to SVG
   * @param canvas Canvas element
   * @param fileName file name
   */
  /*
  	private toSVG(canvas: HTMLCanvasElement, fileName: string) {
  		const uri = canvas.toDataURL('image/png');
  
  		const pxWidth = Number(this.toPixels(this.width, this.dpi).replace('px', ''));
  		const pxHeight = Number(this.toPixels(this.height, this.dpi).replace('px', ''));
  
  		const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" 
        xmlns:xlink="http://www.w3.org/1999/xlink" 
        version="1.1" 
        width="${pxWidth}" 
        height="${pxHeight}" 
        viewBox="0 0 ${pxWidth} ${pxHeight}" 
        xml:space="preserve">
          <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
        xlink:href="${uri}" width="${pxWidth}" height="${pxHeight}"></image>
      </svg>`;
  
  		const a = document.createElement('a');
  		a.href = `data:application/xml,${encodeURIComponent(svg)}`;
  		a.download = fileName;
  		a.click();
  		a.remove();
  	}
  	*/
  /**
   * Convert mm/inch to pixel
   * @param length mm/inch length
   * @param conversionFactor DPI value. default is 96.
   */
  toPixels(f, y = 96) {
    return this.unit === ic.mm && (y /= 25.4), `${y * f}px`;
  }
  /**
   * Add loader in the parent element of maplibre map.
   */
  addLoader() {
    var f;
    const y = (f = this.map.getCanvas().parentElement) == null ? void 0 : f.parentElement;
    if (!y || y.getElementsByClassName("map-export-loader").length > 0) return;
    const b = document.createElement("span");
    b.classList.add("map-export-loader"), b.classList.add("loader-default"), y.appendChild(b);
  }
  /**
   * Show loader
   */
  showLoader() {
    var f, y;
    const b = (f = this.map.getCanvas().parentElement) == null ? void 0 : f.parentElement;
    if (!b) return;
    const k = b.getElementsByClassName("map-export-loader");
    k && k.length > 0 && ((y = k.item(0)) == null || y.classList.add("is-active"));
  }
  /**
   * Hide loader
   */
  hideLoader() {
    var f, y;
    const b = (f = this.map.getCanvas().parentElement) == null ? void 0 : f.parentElement;
    if (!b) return;
    const k = b.getElementsByClassName("map-export-loader");
    k && k.length > 0 && ((y = k.item(0)) == null || y.classList.remove("is-active"));
  }
}
class C0 extends wf {
  /**
   * Constructor
   * @param map MaplibreMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. default is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(f, y = tc.A4, b = 300, k = hh.PNG, P = ic.mm, v = "map", c = Wh, z = dh, U = ph) {
    super(
      f,
      y,
      b,
      k,
      P,
      v,
      "maplibregl-marker",
      c,
      "maplibregl-ctrl-attrib-inner",
      z,
      U
    );
  }
  getRenderedMap(f, y) {
    const b = new fg.Map({
      container: f,
      style: y,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transform request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (b.setMaxPitch(85), b.setPitch(this.map.getPitch()));
    const k = (this.map.style.imageManager || {}).images || [];
    return Object.keys(k).forEach((P) => {
      k[P].data && b.addImage(P, k[P].data);
    }), b;
  }
  renderMapPost(f) {
    const y = this.map.getTerrain();
    return y && f.setTerrain({
      source: y.source,
      exaggeration: y.exaggeration
    }), f;
  }
}
class M0 {
  constructor(f) {
    Wi(this, "controlContainer"), Wi(this, "exportContainer"), Wi(this, "crosshair"), Wi(this, "printableArea"), Wi(this, "map"), Wi(this, "exportButton"), Wi(this, "options", {
      PageSize: tc.A4,
      PageOrientation: zh.Landscape,
      Format: hh.PDF,
      DPI: Lp[300],
      Crosshair: !1,
      PrintableArea: !1,
      Local: "en",
      AllowedSizes: Object.keys(tc),
      Filename: "map",
      markerCirclePaint: Wh,
      attributionOptions: dh,
      northIconOptions: ph
    }), Wi(this, "MAPLIB_CSS_PREFIX", "maplibregl"), f && (f.attributionOptions = Object.assign(
      dh,
      f.attributionOptions
    ), f.northIconOptions = Object.assign(ph, f.northIconOptions), this.options = Object.assign(this.options, f)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const f = this.options.Local ?? "en";
    return Eg(f);
  }
  onAdd(f) {
    var y;
    this.map = f, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const b = document.createElement("TABLE");
    b.className = "print-table";
    const k = {};
    (y = this.options.AllowedSizes) == null || y.forEach((O) => {
      tc[O] && (k[O] = tc[O]);
    });
    const P = this.createSelection(
      k,
      this.getTranslation().PageSize,
      "page-size",
      this.options.PageSize,
      (O, j) => JSON.stringify(O[j])
    );
    b.appendChild(P);
    const v = this.createSelection(
      zh,
      this.getTranslation().PageOrientation,
      "page-orientation",
      this.options.PageOrientation,
      (O, j) => O[j]
    );
    b.appendChild(v);
    const c = this.createSelection(
      Lp,
      this.getTranslation().DPI,
      "dpi-type",
      this.options.DPI,
      (O, j) => O[j]
    );
    b.appendChild(c);
    const z = { Yes: "true", No: "false" }, U = this.createSelection(
      z,
      "Generate Legend",
      "generate-legend",
      "false",
      (O, j) => O[j]
    );
    b.appendChild(U), this.exportContainer.appendChild(b);
    const X = document.createElement("button");
    return X.type = "button", X.textContent = this.getTranslation().Generate, X.classList.add("generate-button"), X.addEventListener("click", () => {
      const O = document.getElementById("mapbox-gl-export-page-size"), j = document.getElementById("mapbox-gl-export-page-orientation"), F = document.getElementById("mapbox-gl-export-dpi-type"), mt = document.getElementById("mapbox-gl-export-generate-legend"), ot = j.value;
      let yt = JSON.parse(O.value);
      ot === zh.Portrait && (yt = yt.reverse()), window.sessionStorage.setItem("ExportPageSize", JSON.stringify(yt)), window.sessionStorage.setItem("generateLegend", mt.value), this.generateMap(
        f,
        yt,
        Number(F.value),
        //formatType.value as FormatType,
        hh.PNG,
        ic.mm,
        this.options.Filename
      );
    }), this.exportContainer.appendChild(X), this.controlContainer;
  }
  generateMap(f, y, b, k, P, v) {
    new C0(
      f,
      y,
      b,
      k,
      P,
      v,
      this.options.markerCirclePaint,
      this.options.attributionOptions,
      this.options.northIconOptions
    ).generate();
  }
  createSelection(f, y, b, k, P) {
    const v = document.createElement("label");
    v.textContent = y;
    const c = document.createElement("select");
    c.setAttribute("id", `mapbox-gl-export-${b}`), c.style.width = "100%", Object.keys(f).forEach((O) => {
      const j = document.createElement("option");
      j.setAttribute("value", P(f, O)), j.appendChild(document.createTextNode(O)), j.setAttribute("name", b), k === f[O] && (j.selected = !0), c.appendChild(j);
    }), c.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const z = document.createElement("TR"), U = document.createElement("TD"), X = document.createElement("TD");
    return U.appendChild(v), X.appendChild(c), z.appendChild(U), z.appendChild(X), z;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(f) {
    this.controlContainer && !this.controlContainer.contains(f.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(f) {
    this.options.Crosshair === !0 && (f === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new yg(this.map), this.crosshair.create()));
  }
  togglePrintableArea(f) {
    this.options.PrintableArea === !0 && (f === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new _g(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0)
      return;
    const f = document.getElementById("mapbox-gl-export-page-size"), y = document.getElementById("mapbox-gl-export-page-orientation").value;
    let b = JSON.parse(f.value);
    y === zh.Portrait && (b = b.reverse()), this.printableArea.updateArea(b[0], b[1]);
  }
}
class E0 extends wf {
  /**
   * Constructor
   * @param map MapboxMap object
   * @param size layout size. default is A4
   * @param dpi dpi value. default is 300
   * @param format image format. default is PNG
   * @param unit length unit. default is mm
   * @param fileName file name. default is 'map'
   */
  constructor(y, b = tc.A4, k = 300, P = hh.PNG, v = ic.mm, c = "map", z = Wh, U = dh, X = ph, O) {
    super(
      // eslint-disable-next-line
      // @ts-ignore
      y,
      b,
      k,
      P,
      v,
      c,
      "mapboxgl-marker",
      z,
      "mapboxgl-ctrl-attrib-inner",
      U,
      X
    );
    Eu(this, "accesstoken");
    this.accesstoken = O;
  }
  /**
   * This function is required to solve an error of Converting circular structure to JSON in mapbox
   */
  stringify(y) {
    let b = [];
    const k = JSON.stringify(y, function(P, v) {
      if (typeof v == "object" && v !== null) {
        if (b.indexOf(v) !== -1)
          return;
        b.push(v);
      }
      return v;
    });
    return b = null, k;
  }
  // eslint-disable-next-line
  // @ts-ignore
  getRenderedMap(y, b) {
    var c;
    const k = this.stringify(b), P = new dg({
      accessToken: this.accesstoken || ug.accessToken,
      container: y,
      style: JSON.parse(k),
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transform request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    }), v = (this.map.style.imageManager || {}).images || [];
    return v && ((c = Object.keys(v)) == null ? void 0 : c.length) > 0 && Object.keys(v).forEach((z) => {
      z && v[z].data && P.addImage(z, v[z].data);
    }), P;
  }
}
class D0 extends M0 {
  constructor(y) {
    super(y);
    Eu(this, "accessToken");
    this.MAPLIB_CSS_PREFIX = "mapboxgl", this.accessToken = y.accessToken;
  }
  // eslint-disable-next-line
  // @ts-ignore
  generateMap(y, b, k, P, v, c) {
    new E0(
      y,
      b,
      k,
      P,
      v,
      c,
      this.options.markerCirclePaint,
      this.options.attributionOptions,
      this.options.northIconOptions,
      this.accessToken
    ).generate();
  }
}
export {
  tc as I,
  D0 as M,
  nr as d,
  zh as s,
  Lp as u,
  hh as v
};
//# sourceMappingURL=index-H2O54h29.js.map
